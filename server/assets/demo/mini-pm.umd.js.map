{"version":3,"file":"mini-pm.umd.js","sources":["../src/types/types.ts","../src/rrweb/snapshot/types.ts","../src/constants.ts","../src/utils/console.ts","../src/config/config.ts","../src/rrweb/snapshot/utils.ts","../src/rrweb/snapshot/snapshot.ts","../src/rrweb/types.ts","../src/rrweb/utils.ts","../src/rrweb/record/mutation.ts","../src/rrweb/record/stringify.ts","../src/rrweb/record/error-stack-parser.ts","../src/rrweb/record/observer.ts","../src/rrweb/record/index.ts","../src/rrweb/record/iframe-manager.ts","../src/rrweb/record/shadow-dom-manager.ts","../src/rrweb/packer/pack.ts","../src/rrweb/packer/base.ts","../src/error-trace/index.ts","../src/utils/ReportData.ts","../src/utils/helper.ts","../src/performance/record-storage.ts","../src/performance/record-client-navigator.ts","../src/performance/record-timing.ts","../src/utils/navigator-information.ts","../src/utils/vitals-score.ts","../src/utils/report-performance.ts","../src/utils/log.ts","../src/utils/metrics.ts","../src/performance/paint.ts","../src/performance/longtask.ts","../src/performance/first-input.ts","../src/performance/resource.ts","../src/performance/layout-shift.ts","../src/performance/performance-observer.ts","../src/index.ts"],"sourcesContent":["import { recordOptions } from \"../rrweb/types\";\n\nexport interface PerformanceMonitoringOptions {\n  isObserverResourceTiming?: boolean | undefined,\n  isObserverElementTiming?: boolean | undefined,\n  maxTime?: number | undefined,\n  captureError?: boolean | undefined,\n  reportData?: ReportDataAchieve | undefined,\n  fetchDomain?: string | undefined,\n  errLogRoute?: string | undefined,\n  errEventRoute?: string | undefined,\n  logRoute?: string | undefined,\n  analyticsTracker?: ((options: AnalyticsTrackerOptions) => void) | undefined,\n  recordOptions?: recordOptions<any> | undefined\n}\n\nexport interface StorageOpt {\n  quota?: number | undefined,\n  usage?: number | undefined,\n  usageDetails: { [key: string]: any }\n}\n\nexport interface TimingOpt {\n  // The time to initiate the network is from AppCache to ResponseEnd\n  // 发起网络的时间是从AppCache到ResponseEnd\n  fetchTime: number,\n  // Response time\n  // 响应时间\n  workerTime: number,\n  // Network request time\n  // 网络请求时间\n  networkTime: number,\n  // Server response time\n  // 服务器响应时间\n  downloadTime: number,\n  // The time when the browser received the first byte of the server\n  // 浏览器接收服务端的第一个字节的时间\n  timeToFirstByte: number,\n  // Request header size\n  // 请求头大小\n  headerSize: number,\n  // dns resolution time\n  // dns解析时间\n  dnsLookupTime: number,\n  // tcp connection time\n  // tcp连接时间\n  tcpTime: number,\n  // Blank screen time\n  // 白屏时间\n  firstPaintTime: number,\n  // dom rendering time\n  // dom渲染时间\n  domRenderTime: number,\n  // onload time\n  // onload时间\n  onloadTime: number,\n  // dom parsing time\n  // dom解析时间\n  domParseTime: number,\n}\n\nexport interface NavigatorOpt {\n  // 浏览器信息\n  // Browser information\n  userAgent: string,\n  // User's internet speed\n  // 用户的网速\n  connection: {\n    downlink?: number,\n    effectiveType?: EffectiveType,\n    rtt?: number,\n    saveData?: boolean,\n    [key: string]: unknown,\n    bandwidth?: string\n  }\n}\n\nexport interface ReportDataAchieve {\n  fetch: (label: AskLevel, body: string, uri: string) => void\n}\n\nexport interface PerformanceObservers {\n  [eventType: string]: PerformanceObserver | null;\n}\n\nexport enum AskLevel {\n  URGENT = 1,\n  IDLE = 2,\n}\n\nexport type PerformanceObserverEventType =\n  | \"paint\"\n  | \"longtask\"\n  | \"first-input\"\n  | \"largest-contentful-paint\"\n  | \"resource\"\n  | \"layout-shift\"\n  | \"element\"\n\nexport type VitalsScore = 'good' | 'needsImprovement' | 'poor' | null;\n\nexport interface AnalyticsTrackerOptions {\n  metricName: string;\n  data: TimingOpt | number | NavigatorOpt;\n  eventProperties: object | undefined;\n  navigatorInformation: unknown;\n  vitalsScore: VitalsScore;\n}\n\nexport interface NavigatorInformation {\n  deviceMemory?: number;\n  hardwareConcurrency?: number;\n  isLowEndDevice?: boolean;\n  isLowEndExperience?: boolean;\n  serviceWorkerStatus?: 'controlled' | 'supported' | 'unsupported';\n}\n\nexport type EffectiveType =\n  | '2g'\n  | '3g'\n  | '4g'\n  | '5g'\n  | 'slow-2g'\n  | 'lte';\n\nexport interface PerformanceEntryEncapsulation extends PerformanceEntry {\n  identifier: any;\n  value?: number | undefined;\n  hadRecentInput?: PerformanceEntryEncapsulation | undefined;\n  initiatorType?: string;\n  decodedBodySize?: number;\n  processingStart: DOMHighResTimeStamp;\n  target?: Node;\n  renderTime?: number\n}\n\nexport interface ResourceTime {\n  beacon: number;\n  css: number;\n  fetch: number;\n  img: number;\n  other: number;\n  script: number;\n  total: number;\n  xmlhttprequest: number;\n  [key: string]: number\n}","export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n\nexport type MaskTextFn = (text: string) => string;\n","interface Navigator {\n  sendBeacon: any\n  connection?: any\n  storage: any\n  userAgent: string\n  deviceMemory: number;\n  hardwareConcurrency: number;\n  serviceWorker?: {\n    controller?: string;\n  };\n}\n\nexport const W = window\nexport const WP = W.performance\nexport const WN = W.navigator as any as Navigator\nexport const C = W.console\nexport const D = document","import { C } from \"../constants\"\n\nconst prefix = \"mini-pm🐢：\"\n\nexport const log = (message: any, ...options: any[]): void => C.log(prefix, message, ...options)\n\nexport const warn = (message: any, ...options: any[]) => C.warn(prefix, message, ...options)\n\nexport const error = (message: any, ...options: any[]) => C.error(prefix, message, ...options)","import type { AnalyticsTrackerOptions, PerformanceMonitoringOptions } from \"../types/types\";\nimport { log } from \"../utils/console\";\n\nexport const config: PerformanceMonitoringOptions = {\n  isObserverResourceTiming: false,\n  isObserverElementTiming: false,\n  maxTime: 15000,\n  captureError: true,\n  reportData: undefined,\n  analyticsTracker: (options: AnalyticsTrackerOptions) => {\n    log(options)\n  },\n  recordOptions: {},\n  fetchDomain: \"\",\n  errLogRoute: \"\",\n  errEventRoute: \"\",\n  logRoute: \"\"\n}","import { INode } from './types';\n\nexport function isElement(n: Node | INode): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n  MaskTextFn,\n} from './types';\nimport { isElement, isShadowRoot } from './utils';\n\nlet _id = 1;\nconst tagNameRegex = RegExp('[^a-z0-9-_]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule)\n    ? getCssRulesString(rule.styleSheet) || ''\n    : rule.cssText;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin;\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    var chars,\n      match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  let output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        let c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n\nfunction getHref() {\n  // return a href without hash\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: string,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || ((name === 'href' || name === 'xlink:href') && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    value &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    // tslint:disable-next-line: prefer-for-of\n    for (let eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      const className = element.classList[eIndex];\n      if (blockClass.test(className)) {\n        return true;\n      }\n    }\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nexport function needMaskingText(\n  node: Node | null,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (typeof maskTextClass === 'string') {\n      if ((node as HTMLElement).classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (maskTextClass.test(className)) {\n          return true;\n        }\n      });\n    }\n    if (maskTextSelector) {\n      if ((node as HTMLElement).matches(maskTextSelector)) {\n        return true;\n      }\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    listener();\n    return;\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    recordCanvas: boolean;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    recordCanvas,\n  } = options;\n  // Only record root id when document object is not the base document\n  let rootId: number | undefined;\n  if (((doc as unknown) as INode).__sn) {\n    const docId = ((doc as unknown) as INode).__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      return {\n        type: NodeType.Document,\n        childNodes: [],\n        rootId,\n      };\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, tagName, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        const cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value =\n            maskInputOptions[attributes.type as keyof MaskInputOptions] ||\n            maskInputOptions[tagName as keyof MaskInputOptions]\n              ? '*'.repeat(value.length)\n              : value;\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        const selectValue = (n as HTMLOptionElement).parentElement;\n        if (attributes.value === (selectValue as HTMLSelectElement).value) {\n          attributes.selected = (n as HTMLOptionElement).selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL();\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      // block element\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      // iframe\n      if (tagName === 'iframe') {\n        delete attributes.src;\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n        rootId,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n      if (isStyle && textContent) {\n        textContent = absoluteToStylesheet(textContent, getHref());\n      }\n      if (isScript) {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      if (\n        !isStyle &&\n        !isScript &&\n        needMaskingText(n, maskTextClass, maskTextSelector) &&\n        textContent\n      ) {\n        textContent = maskTextFn\n          ? maskTextFn(textContent)\n          : textContent.replace(/[\\S]/g, '*');\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n        rootId,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      (sn.tagName === 'script' ||\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script'))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions?: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskTextFn,\n    slimDOMOptions,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    recordCanvas,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  if (onSerialize) {\n    onSerialize(n as INode);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      map,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      serializedNode.isShadowHost = true;\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            map,\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            slimDOMOptions,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(n as INode, serializedIframeNode);\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    slimDOM?: boolean | SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    blockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskTextFn,\n    slimDOM = false,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","import {\n  serializedNodeWithId,\n  idNodeMap,\n  INode,\n  MaskInputOptions,\n  SlimDOMOptions,\n} from './snapshot';\nimport { PackFn, UnpackFn } from './packer/base';\nimport { FontFaceDescriptors } from 'css-font-loading-module';\nimport { IframeManager } from './record/iframe-manager';\nimport { ShadowDomManager } from './record/shadow-dom-manager';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n  Custom,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport type logEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type customEvent<T = unknown> = {\n  type: EventType.Custom;\n  data: {\n    tag: string;\n    payload: T;\n  };\n};\n\nexport type styleSheetEvent = {};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n  TouchMove,\n  MediaInteraction,\n  StyleSheetRule,\n  CanvasMutation,\n  Font,\n  Log,\n  Drag,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source:\n  | IncrementalSource.MouseMove\n  | IncrementalSource.TouchMove\n  | IncrementalSource.Drag;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimension;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type mediaInteractionData = {\n  source: IncrementalSource.MediaInteraction;\n} & mediaInteractionParam;\n\nexport type styleSheetRuleData = {\n  source: IncrementalSource.StyleSheetRule;\n} & styleSheetRuleParam;\n\nexport type canvasMutationData = {\n  source: IncrementalSource.CanvasMutation;\n} & canvasMutationParam;\n\nexport type fontData = {\n  source: IncrementalSource.Font;\n} & fontParam;\n\nexport type logData = {\n  source: IncrementalSource.Log;\n} & LogParam;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData\n  | mediaInteractionData\n  | styleSheetRuleData\n  | canvasMutationData\n  | fontData\n  | logData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent\n  | logEvent\n  | customEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type blockClass = string | RegExp;\n\nexport type maskTextClass = string | RegExp;\n\nexport type SamplingStrategy = Partial<{\n  /**\n   * false means not to record mouse/touch move events\n   * number is the throttle threshold of recording mouse/touch move\n   */\n  mousemove: boolean | number;\n  /**\n   * number is the throttle threshold of mouse/touch move callback\n   */\n  mousemoveCallback: number;\n  /**\n   * false means not to record mouse interaction events\n   * can also specify record some kinds of mouse interactions\n   */\n  mouseInteraction: boolean | Record<string, boolean | undefined>;\n  /**\n   * number is the throttle threshold of recording scroll\n   */\n  scroll: number;\n  /**\n   * 'all' will record all the input events\n   * 'last' will only record the last input value while input a sequence of chars\n   */\n  input: 'all' | 'last';\n}>;\n\nexport type recordOptions<T> = {\n  emit?: (e: T, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n  blockClass?: blockClass;\n  blockSelector?: string;\n  ignoreClass?: string;\n  maskTextClass?: maskTextClass;\n  maskTextSelector?: string;\n  maskAllInputs?: boolean;\n  maskInputOptions?: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  slimDOMOptions?: SlimDOMOptions | 'all' | true;\n  inlineStylesheet?: boolean;\n  hooks?: hooksParam;\n  packFn?: PackFn;\n  sampling?: SamplingStrategy;\n  recordCanvas?: boolean;\n  collectFonts?: boolean;\n  // departed, please use sampling options\n  mousemoveWait?: number;\n  recordLog?: boolean | LogRecordOptions;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n  mediaInteractionCb: mediaInteractionCallback;\n  blockClass: blockClass;\n  blockSelector: string | null;\n  ignoreClass: string;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  maskInputOptions: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  inlineStylesheet: boolean;\n  styleSheetRuleCb: styleSheetRuleCallback;\n  canvasMutationCb: canvasMutationCallback;\n  fontCb: fontCallback;\n  logCb: logCallback;\n  logOptions: LogRecordOptions;\n  sampling: SamplingStrategy;\n  recordCanvas: boolean;\n  collectFonts: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  doc: Document;\n  mirror: Mirror;\n  iframeManager: IframeManager;\n  shadowDomManager: ShadowDomManager;\n};\n\nexport type hooksParam = {\n  mutation?: mutationCallBack;\n  mousemove?: mousemoveCallBack;\n  mouseInteraction?: mouseInteractionCallBack;\n  scroll?: scrollCallback;\n  viewportResize?: viewportResizeCallback;\n  input?: inputCallback;\n  mediaInteaction?: mediaInteractionCallback;\n  styleSheetRule?: styleSheetRuleCallback;\n  canvasMutation?: canvasMutationCallback;\n  font?: fontCallback;\n  log?: logCallback;\n};\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\nexport type mutationRecord = {\n  type: string;\n  target: Node;\n  oldValue: string | null;\n  addedNodes: NodeList;\n  removedNodes: NodeList;\n  attributeName: string | null;\n};\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n  isShadow?: boolean;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  // Newly recorded mutations will not have previousId any more, just for compatibility\n  previousId?: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\nexport type mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n  isAttachIframe?: true;\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (\n  p: mousePosition[],\n  source:\n    | IncrementalSource.MouseMove\n    | IncrementalSource.TouchMove\n    | IncrementalSource.Drag,\n) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove_Departed, // we will start a separate observer for touch move event\n  TouchEnd,\n}\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type styleSheetAddRule = {\n  rule: string;\n  index?: number;\n};\n\nexport type styleSheetDeleteRule = {\n  index: number;\n};\n\nexport type styleSheetRuleParam = {\n  id: number;\n  removes?: styleSheetDeleteRule[];\n  adds?: styleSheetAddRule[];\n};\n\nexport type styleSheetRuleCallback = (s: styleSheetRuleParam) => void;\n\nexport type canvasMutationCallback = (p: canvasMutationParam) => void;\n\nexport type canvasMutationParam = {\n  id: number;\n  property: string;\n  args: Array<unknown>;\n  setter?: true;\n};\n\nexport type fontParam = {\n  family: string;\n  fontSource: string;\n  buffer: boolean;\n  descriptors?: FontFaceDescriptors;\n};\n\nexport type LogLevel =\n  | 'assert'\n  | 'clear'\n  | 'count'\n  | 'countReset'\n  | 'debug'\n  | 'dir'\n  | 'dirxml'\n  | 'error'\n  | 'group'\n  | 'groupCollapsed'\n  | 'groupEnd'\n  | 'info'\n  | 'log'\n  | 'table'\n  | 'time'\n  | 'timeEnd'\n  | 'timeLog'\n  | 'trace'\n  | 'warn';\n\n/* fork from interface Console */\n// all kinds of console functions\nexport type Logger = {\n  assert?: typeof console.assert;\n  clear?: typeof console.clear;\n  count?: typeof console.count;\n  countReset?: typeof console.countReset;\n  debug?: typeof console.debug;\n  dir?: typeof console.dir;\n  dirxml?: typeof console.dirxml;\n  error?: typeof console.error;\n  group?: typeof console.group;\n  groupCollapsed?: typeof console.groupCollapsed;\n  groupEnd?: () => void;\n  info?: typeof console.info;\n  log?: typeof console.log;\n  table?: typeof console.table;\n  time?: typeof console.time;\n  timeEnd?: typeof console.timeEnd;\n  timeLog?: typeof console.timeLog;\n  trace?: typeof console.trace;\n  warn?: typeof console.warn;\n};\n\n/**\n * define an interface to replay log records\n * (data: logData) => void> function to display the log data\n */\nexport type ReplayLogger = Partial<Record<LogLevel, (data: logData) => void>>;\n\nexport type LogParam = {\n  level: LogLevel;\n  trace: string[];\n  payload: string[];\n};\n\nexport type fontCallback = (p: fontParam) => void;\n\nexport type logCallback = (p: LogParam) => void;\n\nexport type viewportResizeDimension = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimension) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport const enum MediaInteractions {\n  Play,\n  Pause,\n}\n\nexport type mediaInteractionParam = {\n  type: MediaInteractions;\n  id: number;\n};\n\nexport type mediaInteractionCallback = (p: mediaInteractionParam) => void;\n\nexport type DocumentDimension = {\n  x: number;\n  y: number;\n  // scale value relative to its parent iframe\n  relativeScale: number;\n  // scale value relative to the root iframe\n  absoluteScale: number;\n};\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n  reset: () => void;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type playerConfig = {\n  speed: number;\n  maxSpeed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: boolean;\n  showWarning: boolean;\n  showDebug: boolean;\n  blockClass: string;\n  liveMode: boolean;\n  insertStyleRules: string[];\n  triggerFocus: boolean;\n  UNSAFE_replayCanvas: boolean;\n  pauseAnimation?: boolean;\n  mouseTail:\n  | boolean\n  | {\n    duration?: number;\n    lineCap?: string;\n    lineWidth?: number;\n    strokeStyle?: string;\n  };\n  unpackFn?: UnpackFn;\n  logConfig: LogReplayConfig;\n};\n\nexport type LogReplayConfig = {\n  level?: LogLevel[] | undefined;\n  replayLogger: ReplayLogger | undefined;\n};\n\nexport type playerMetaData = {\n  startTime: number;\n  endTime: number;\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport type Handler = (event?: unknown) => void;\n\nexport type Emitter = {\n  on(type: string, handler: Handler): void;\n  emit(type: string, event?: unknown): void;\n  off(type: string, handler: Handler): void;\n};\n\nexport type Arguments<T> = T extends (...payload: infer U) => unknown\n  ? U\n  : unknown;\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n  MouseInteraction = 'mouse-interaction',\n  EventCast = 'event-cast',\n  CustomEvent = 'custom-event',\n  Flush = 'flush',\n  StateChange = 'state-change',\n  PlayBack = 'play-back',\n}\n\nexport type MaskInputFn = (text: string) => string;\n\nexport type MaskTextFn = (text: string) => string;\n\n// store the state that would be changed during the process(unmount from dom and mount again)\nexport type ElementState = {\n  // [scrollLeft,scrollTop]\n  scroll?: [number, number];\n};\n\nexport type StringifyOptions = {\n  // limit of string length\n  stringLengthLimit?: number;\n  /**\n   * limit of number of keys in an object\n   * if an object contains more keys than this limit, we would call its toString function directly\n   */\n  numOfKeysLimit: number;\n};\n\nexport type LogRecordOptions = {\n  level?: LogLevel[] | undefined;\n  lengthThreshold?: number;\n  stringifyOptions?: StringifyOptions;\n  logger?: Logger;\n};\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n  blockClass,\n  eventWithTime,\n  EventType,\n  IncrementalSource,\n  addedNodeMutation,\n  removedNodeMutation,\n  textMutation,\n  attributeMutation,\n  mutationData,\n  scrollData,\n  inputData,\n  DocumentDimension,\n} from './types';\nimport {\n  INode,\n  IGNORED_NODE,\n  serializedNodeWithId,\n  NodeType,\n  isShadowRoot,\n} from './snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | Window = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport function createMirror(): Mirror {\n  return {\n    map: {},\n    getId(n) {\n      // if n is not a serialized INode, use -1 as its id.\n      if (!n.__sn) {\n        return -1;\n      }\n      return n.__sn.id;\n    },\n    getNode(id) {\n      return this.map[id] || null;\n    },\n    // TODO: use a weakmap to get rid of manually memory management\n    removeNodeFromMap(n) {\n      const id = n.__sn && n.__sn.id;\n      delete this.map[id];\n      if (n.childNodes) {\n        n.childNodes.forEach((child) =>\n          this.removeNodeFromMap((child as Node) as INode),\n        );\n      }\n    },\n    has(id) {\n      return this.map.hasOwnProperty(id);\n    },\n    reset() {\n      this.map = {};\n    },\n  };\n}\n\n// https://github.com/rrweb-io/rrweb/pull/407\nconst DEPARTED_MIRROR_ACCESS_WARNING =\n  'Please stop import mirror directly. Instead of that,' +\n  '\\r\\n' +\n  'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\n  '\\r\\n' +\n  'or you can use record.mirror to access the mirror instance during recording.';\nexport let _mirror: Mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n};\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === 'map') {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: number | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function (arg: T) {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait - (now - previous);\n    let context = this;\n    let args = arguments as any;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        window.clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = window.setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n  isRevoked?: boolean,\n  win = window,\n): hookResetter {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked\n      ? d\n      : {\n        set(value) {\n          // put hooked setter into event loop to avoid of set latency\n          setTimeout(() => {\n            d.set!.call(this, value);\n          }, 0);\n          if (original && original.set) {\n            original.set.call(this, value);\n          }\n        },\n      },\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\n\n// copy from https://github.com/getsentry/sentry-javascript/blob/b2109071975af8bf0316d3b5b38f519bdaf5dc15/packages/utils/src/object.ts\nexport function patch(\n  // tslint:disable-next-line:no-any\n  source: { [key: string]: any },\n  name: string,\n  // tslint:disable-next-line:no-any\n  replacement: (...args: any[]) => any,\n): () => void {\n  try {\n    if (!(name in source)) {\n      return () => { };\n    }\n\n    const original = source[name] as () => unknown;\n    const wrapped = replacement(original);\n\n    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n    // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    }\n\n    source[name] = wrapped;\n\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => { };\n    // This can throw if multiple fill happens on a global object like XMLHttpRequest\n    // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n  }\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nexport function isBlocked(node: Node | null, blockClass: blockClass): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    let needBlock = false;\n    if (typeof blockClass === 'string') {\n      needBlock = (node as HTMLElement).classList.contains(blockClass);\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (blockClass.test(className)) {\n          needBlock = true;\n        }\n      });\n    }\n    return needBlock || isBlocked(node.parentNode, blockClass);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return isBlocked(node.parentNode, blockClass);\n  }\n  return isBlocked(node.parentNode, blockClass);\n}\n\nexport function isIgnored(n: Node | INode): boolean {\n  if ('__sn' in n) {\n    return (n as INode).__sn.id === IGNORED_NODE;\n  }\n  // The main part of the slimDOM check happens in\n  // rrweb-snapshot::serializeNodeWithId\n  return false;\n}\n\nexport function isAncestorRemoved(target: INode, mirror: Mirror): boolean {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode, mirror);\n}\n\nexport function isTouchEvent(\n  event: MouseEvent | TouchEvent,\n): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches);\n}\n\nexport function polyfill(win = window) {\n  if ('NodeList' in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as NodeList['forEach'];\n  }\n\n  if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as DOMTokenList['forEach'];\n  }\n\n  // https://github.com/Financial-Times/polyfill-service/pull/183\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = function contains(node) {\n      if (!(0 in arguments)) {\n        throw new TypeError('1 argument is required');\n      }\n\n      do {\n        if (this === node) {\n          return true;\n        }\n        // tslint:disable-next-line: no-conditional-assignment\n      } while ((node = node && node.parentNode));\n\n      return false;\n    };\n  }\n}\n\nexport function needCastInSyncMode(event: eventWithTime): boolean {\n  switch (event.type) {\n    case EventType.DomContentLoaded:\n    case EventType.Load:\n    case EventType.Custom:\n      return false;\n    case EventType.FullSnapshot:\n    case EventType.Meta:\n      return true;\n    default:\n      break;\n  }\n\n  switch (event.data.source) {\n    case IncrementalSource.MouseMove:\n    case IncrementalSource.MouseInteraction:\n    case IncrementalSource.TouchMove:\n    case IncrementalSource.MediaInteraction:\n      return false;\n    case IncrementalSource.ViewportResize:\n    case IncrementalSource.StyleSheetRule:\n    case IncrementalSource.Scroll:\n    case IncrementalSource.Input:\n      return true;\n    default:\n      break;\n  }\n\n  return true;\n}\n\nexport type TreeNode = {\n  id: number;\n  mutation: addedNodeMutation;\n  parent?: TreeNode;\n  children: Record<number, TreeNode>;\n  texts: textMutation[];\n  attributes: attributeMutation[];\n};\nexport class TreeIndex {\n  public tree!: Record<number, TreeNode>;\n\n  private removeNodeMutations!: removedNodeMutation[];\n  private textMutations!: textMutation[];\n  private attributeMutations!: attributeMutation[];\n  private indexes!: Map<number, TreeNode>;\n  private removeIdSet!: Set<number>;\n  private scrollMap!: Map<number, scrollData>;\n  private inputMap!: Map<number, inputData>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public add(mutation: addedNodeMutation) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode: TreeNode = {\n      id: mutation.node.id,\n      mutation,\n      children: [],\n      texts: [],\n      attributes: [],\n    };\n    if (!parentTreeNode) {\n      this.tree[treeNode.id] = treeNode;\n    } else {\n      treeNode.parent = parentTreeNode;\n      parentTreeNode.children[treeNode.id] = treeNode;\n    }\n    this.indexes.set(treeNode.id, treeNode);\n  }\n\n  public remove(mutation: removedNodeMutation, mirror: Mirror) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode = this.indexes.get(mutation.id);\n\n    const deepRemoveFromMirror = (id: number) => {\n      this.removeIdSet.add(id);\n      const node = mirror.getNode(id);\n      node?.childNodes.forEach((childNode) => {\n        if ('__sn' in childNode) {\n          deepRemoveFromMirror(((childNode as unknown) as INode).__sn.id);\n        }\n      });\n    };\n    const deepRemoveFromTreeIndex = (node: TreeNode) => {\n      this.removeIdSet.add(node.id);\n      Object.values(node.children).forEach((n) => deepRemoveFromTreeIndex(n));\n      const _treeNode = this.indexes.get(node.id);\n      if (_treeNode) {\n        const _parentTreeNode = _treeNode.parent;\n        if (_parentTreeNode) {\n          delete _treeNode.parent;\n          delete _parentTreeNode.children[_treeNode.id];\n          this.indexes.delete(mutation.id);\n        }\n      }\n    };\n\n    if (!treeNode) {\n      this.removeNodeMutations.push(mutation);\n      deepRemoveFromMirror(mutation.id);\n    } else if (!parentTreeNode) {\n      delete this.tree[treeNode.id];\n      this.indexes.delete(treeNode.id);\n      deepRemoveFromTreeIndex(treeNode);\n    } else {\n      delete treeNode.parent;\n      delete parentTreeNode.children[treeNode.id];\n      this.indexes.delete(mutation.id);\n      deepRemoveFromTreeIndex(treeNode);\n    }\n  }\n\n  public text(mutation: textMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.texts.push(mutation);\n    } else {\n      this.textMutations.push(mutation);\n    }\n  }\n\n  public attribute(mutation: attributeMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.attributes.push(mutation);\n    } else {\n      this.attributeMutations.push(mutation);\n    }\n  }\n\n  public scroll(d: scrollData) {\n    this.scrollMap.set(d.id, d);\n  }\n\n  public input(d: inputData) {\n    this.inputMap.set(d.id, d);\n  }\n\n  public flush(): {\n    mutationData: mutationData;\n    scrollMap: TreeIndex['scrollMap'];\n    inputMap: TreeIndex['inputMap'];\n  } {\n    const {\n      tree,\n      removeNodeMutations,\n      textMutations,\n      attributeMutations,\n    } = this;\n\n    const batchMutationData: mutationData = {\n      source: IncrementalSource.Mutation,\n      removes: removeNodeMutations,\n      texts: textMutations,\n      attributes: attributeMutations,\n      adds: [],\n    };\n\n    const walk = (treeNode: TreeNode, removed: boolean) => {\n      if (removed) {\n        this.removeIdSet.add(treeNode.id);\n      }\n      batchMutationData.texts = batchMutationData.texts\n        .concat(removed ? [] : treeNode.texts)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      batchMutationData.attributes = batchMutationData.attributes\n        .concat(removed ? [] : treeNode.attributes)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      if (\n        !this.removeIdSet.has(treeNode.id) &&\n        !this.removeIdSet.has(treeNode.mutation.parentId) &&\n        !removed\n      ) {\n        batchMutationData.adds.push(treeNode.mutation);\n        if (treeNode.children) {\n          Object.values(treeNode.children).forEach((n) => walk(n, false));\n        }\n      } else {\n        Object.values(treeNode.children).forEach((n) => walk(n, true));\n      }\n    };\n\n    Object.values(tree).forEach((n) => walk(n, false));\n\n    for (const id of this.scrollMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.scrollMap.delete(id);\n      }\n    }\n    for (const id of this.inputMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.inputMap.delete(id);\n      }\n    }\n\n    const scrollMap = new Map(this.scrollMap);\n    const inputMap = new Map(this.inputMap);\n\n    this.reset();\n\n    return {\n      mutationData: batchMutationData,\n      scrollMap,\n      inputMap,\n    };\n  }\n\n  private reset() {\n    this.tree = [];\n    this.indexes = new Map();\n    this.removeNodeMutations = [];\n    this.textMutations = [];\n    this.attributeMutations = [];\n    this.removeIdSet = new Set();\n    this.scrollMap = new Map();\n    this.inputMap = new Map();\n  }\n}\n\ntype ResolveTree = {\n  value: addedNodeMutation;\n  children: ResolveTree[];\n  parent: ResolveTree | null;\n};\n\nexport function queueToResolveTrees(queue: addedNodeMutation[]): ResolveTree[] {\n  const queueNodeMap: Record<number, ResolveTree> = {};\n  const putIntoMap = (\n    m: addedNodeMutation,\n    parent: ResolveTree | null,\n  ): ResolveTree => {\n    const nodeInTree: ResolveTree = {\n      value: m,\n      parent,\n      children: [],\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n\n  const queueNodeTrees: ResolveTree[] = [];\n  for (const mutation of queue) {\n    const { nextId, parentId } = mutation;\n    if (nextId && nextId in queueNodeMap) {\n      const nextInTree = queueNodeMap[nextId];\n      if (nextInTree.parent) {\n        const idx = nextInTree.parent.children.indexOf(nextInTree);\n        nextInTree.parent.children.splice(\n          idx,\n          0,\n          putIntoMap(mutation, nextInTree.parent),\n        );\n      } else {\n        const idx = queueNodeTrees.indexOf(nextInTree);\n        queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n      }\n      continue;\n    }\n    if (parentId in queueNodeMap) {\n      const parentInTree = queueNodeMap[parentId];\n      parentInTree.children.push(putIntoMap(mutation, parentInTree));\n      continue;\n    }\n    queueNodeTrees.push(putIntoMap(mutation, null));\n  }\n\n  return queueNodeTrees;\n}\n\nexport function iterateResolveTree(\n  tree: ResolveTree,\n  cb: (mutation: addedNodeMutation) => unknown,\n) {\n  cb(tree.value);\n  /**\n   * The resolve tree was designed to reflect the DOM layout,\n   * but we need append next sibling first, so we do a reverse\n   * loop here.\n   */\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    iterateResolveTree(tree.children[i], cb);\n  }\n}\n\ntype HTMLIFrameINode = HTMLIFrameElement & {\n  __sn: serializedNodeWithId;\n};\nexport type AppendedIframe = {\n  mutationInQueue: addedNodeMutation;\n  builtNode: HTMLIFrameINode;\n};\n\nexport function isIframeINode(\n  node: INode | ShadowRoot,\n): node is HTMLIFrameINode {\n  if ('__sn' in node) {\n    return (\n      node.__sn.type === NodeType.Element && node.__sn.tagName === 'iframe'\n    );\n  }\n  // node can be document fragment when using the virtual parent feature\n  return false;\n}\n\nexport function getBaseDimension(\n  node: Node,\n  rootIframe: Node,\n): DocumentDimension {\n  const frameElement = node.ownerDocument?.defaultView?.frameElement;\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1,\n    };\n  }\n\n  const frameDimension = frameElement.getBoundingClientRect();\n  const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  // the iframe element may have a scale transform\n  const relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x:\n      frameDimension.x * frameBaseDimension.relativeScale +\n      frameBaseDimension.x,\n    y:\n      frameDimension.y * frameBaseDimension.relativeScale +\n      frameBaseDimension.y,\n    relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale,\n  };\n}\n\nexport function hasShadowRoot<T extends Node>(\n  n: T,\n): n is T & { shadowRoot: ShadowRoot } {\n  return Boolean(((n as unknown) as Element)?.shadowRoot);\n}\n","// @ts-nocheck\nimport {\n  INode,\n  serializeNodeWithId,\n  transformAttribute,\n  MaskInputOptions,\n  SlimDOMOptions,\n  IGNORED_NODE,\n  isShadowRoot,\n  needMaskingText,\n} from '../snapshot';\nimport {\n  mutationRecord,\n  blockClass,\n  maskTextClass,\n  mutationCallBack,\n  textCursor,\n  attributeCursor,\n  removedNodeMutation,\n  addedNodeMutation,\n  MaskTextFn,\n  Mirror,\n} from '../types';\nimport {\n  isBlocked,\n  isAncestorRemoved,\n  isIgnored,\n  isIframeINode,\n  hasShadowRoot,\n} from '../utils';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\n\ntype DoubleLinkedListNode = {\n  previous: DoubleLinkedListNode | null;\n  next: DoubleLinkedListNode | null;\n  value: NodeInLinkedList;\n};\ntype NodeInLinkedList = Node & {\n  __ln: DoubleLinkedListNode;\n};\n\nfunction isNodeInLinkedList(n: Node | NodeInLinkedList): n is NodeInLinkedList {\n  return '__ln' in n;\n}\nclass DoubleLinkedList {\n  public length = 0;\n  public head: DoubleLinkedListNode | null = null;\n\n  public get(position: number) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n\n  public addNode(n: Node) {\n    const node: DoubleLinkedListNode = {\n      value: n as NodeInLinkedList,\n      previous: null,\n      next: null,\n    };\n    (n as NodeInLinkedList).__ln = node;\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      const current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (\n      n.nextSibling &&\n      isNodeInLinkedList(n.nextSibling) &&\n      n.nextSibling.__ln.previous\n    ) {\n      const current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    this.length++;\n  }\n\n  public removeNode(n: NodeInLinkedList) {\n    const current = n.__ln;\n    if (!this.head) {\n      return;\n    }\n\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      }\n    }\n    if (n.__ln) {\n      delete n.__ln;\n    }\n    this.length--;\n  }\n}\n\nconst moveKey = (id: number, parentId: number) => `${id}@${parentId}`;\nfunction isINode(n: Node | INode): n is INode {\n  return '__sn' in n;\n}\n\n/**\n * controls behaviour of a MutationObserver\n */\nexport default class MutationBuffer {\n  private frozen: boolean = false;\n  private locked: boolean = false;\n\n  private texts: textCursor[] = [];\n  private attributes: attributeCursor[] = [];\n  private removes: removedNodeMutation[] = [];\n  private mapRemoves: Node[] = [];\n\n  private movedMap: Record<string, true> = {};\n\n  /**\n   * the browser MutationObserver emits multiple mutations after\n   * a delay for performance reasons, making tracing added nodes hard\n   * in our `processMutations` callback function.\n   * For example, if we append an element el_1 into body, and then append\n   * another element el_2 into el_1, these two mutations may be passed to the\n   * callback function together when the two operations were done.\n   * Generally we need to trace child nodes of newly added nodes, but in this\n   * case if we count el_2 as el_1's child node in the first mutation record,\n   * then we will count el_2 again in the second mutation record which was\n   * duplicated.\n   * To avoid of duplicate counting added nodes, we use a Set to store\n   * added nodes and its child nodes during iterate mutation records. Then\n   * collect added nodes from the Set which have no duplicate copy. But\n   * this also causes newly added nodes will not be serialized with id ASAP,\n   * which means all the id related calculation should be lazy too.\n   */\n  private addedSet = new Set<Node>();\n  private movedSet = new Set<Node>();\n  private droppedSet = new Set<Node>();\n\n  private emissionCallback: mutationCallBack;\n  private blockClass: blockClass;\n  private blockSelector: string | null;\n  private maskTextClass: maskTextClass;\n  private maskTextSelector: string | null;\n  private inlineStylesheet: boolean;\n  private maskInputOptions: MaskInputOptions;\n  private maskTextFn: MaskTextFn | undefined;\n  private recordCanvas: boolean;\n  private slimDOMOptions: SlimDOMOptions;\n  private doc: Document;\n\n  private mirror: Mirror;\n  private iframeManager: IframeManager;\n  private shadowDomManager: ShadowDomManager;\n\n  public init(\n    cb: mutationCallBack,\n    blockClass: blockClass,\n    blockSelector: string | null,\n    maskTextClass: maskTextClass,\n    maskTextSelector: string | null,\n    inlineStylesheet: boolean,\n    maskInputOptions: MaskInputOptions,\n    maskTextFn: MaskTextFn | undefined,\n    recordCanvas: boolean,\n    slimDOMOptions: SlimDOMOptions,\n    doc: Document,\n    mirror: Mirror,\n    iframeManager: IframeManager,\n    shadowDomManager: ShadowDomManager,\n  ) {\n    this.blockClass = blockClass;\n    this.blockSelector = blockSelector;\n    this.maskTextClass = maskTextClass;\n    this.maskTextSelector = maskTextSelector;\n    this.inlineStylesheet = inlineStylesheet;\n    this.maskInputOptions = maskInputOptions;\n    this.maskTextFn = maskTextFn;\n    this.recordCanvas = recordCanvas;\n    this.slimDOMOptions = slimDOMOptions;\n    this.emissionCallback = cb;\n    this.doc = doc;\n    this.mirror = mirror;\n    this.iframeManager = iframeManager;\n    this.shadowDomManager = shadowDomManager;\n  }\n\n  public freeze() {\n    this.frozen = true;\n  }\n\n  public unfreeze() {\n    this.frozen = false;\n    this.emit();\n  }\n\n  public isFrozen() {\n    return this.frozen;\n  }\n\n  public lock() {\n    this.locked = true;\n  }\n\n  public unlock() {\n    this.locked = false;\n    this.emit();\n  }\n\n  public processMutations = (mutations: mutationRecord[]) => {\n    mutations.forEach(this.processMutation);\n    this.emit();\n  };\n\n  public emit = () => {\n    if (this.frozen || this.locked) {\n      return;\n    }\n\n    // delay any modification of the mirror until this function\n    // so that the mirror for takeFullSnapshot doesn't get mutated while it's event is being processed\n\n    const adds: addedNodeMutation[] = [];\n\n    /**\n     * Sometimes child node may be pushed before its newly added\n     * parent, so we init a queue to store these nodes.\n     */\n    const addList = new DoubleLinkedList();\n    const getNextId = (n: Node): number | null => {\n      let ns: Node | null = n;\n      let nextId: number | null = IGNORED_NODE; // slimDOM: ignored\n      while (nextId === IGNORED_NODE) {\n        ns = ns && ns.nextSibling;\n        nextId = ns && this.mirror.getId((ns as unknown) as INode);\n      }\n      if (nextId === -1 && isBlocked(n.nextSibling, this.blockClass)) {\n        nextId = null;\n      }\n      return nextId;\n    };\n    const pushAdd = (n: Node) => {\n      const shadowHost: Element | null = n.getRootNode\n        ? (n.getRootNode() as ShadowRoot)?.host\n        : null;\n      const notInDoc = !this.doc.contains(n) && !this.doc.contains(shadowHost);\n      if (!n.parentNode || notInDoc) {\n        return;\n      }\n      const parentId = isShadowRoot(n.parentNode)\n        ? this.mirror.getId((shadowHost as unknown) as INode)\n        : this.mirror.getId((n.parentNode as Node) as INode);\n      const nextId = getNextId(n);\n      if (parentId === -1 || nextId === -1) {\n        return addList.addNode(n);\n      }\n      let sn = serializeNodeWithId(n, {\n        doc: this.doc,\n        map: this.mirror.map,\n        blockClass: this.blockClass,\n        blockSelector: this.blockSelector,\n        maskTextClass: this.maskTextClass,\n        maskTextSelector: this.maskTextSelector,\n        skipChild: true,\n        inlineStylesheet: this.inlineStylesheet,\n        maskInputOptions: this.maskInputOptions,\n        maskTextFn: this.maskTextFn,\n        slimDOMOptions: this.slimDOMOptions,\n        recordCanvas: this.recordCanvas,\n        onSerialize: (currentN) => {\n          if (isIframeINode(currentN)) {\n            this.iframeManager.addIframe(currentN);\n          }\n          if (hasShadowRoot(n)) {\n            this.shadowDomManager.addShadowRoot(n.shadowRoot, document);\n          }\n        },\n        onIframeLoad: (iframe, childSn) => {\n          this.iframeManager.attachIframe(iframe, childSn);\n        },\n      });\n      if (sn) {\n        adds.push({\n          parentId,\n          nextId,\n          node: sn,\n        });\n      }\n    };\n\n    while (this.mapRemoves.length) {\n      this.mirror.removeNodeFromMap(this.mapRemoves.shift() as INode);\n    }\n\n    for (const n of this.movedSet) {\n      if (\n        isParentRemoved(this.removes, n, this.mirror) &&\n        !this.movedSet.has(n.parentNode!)\n      ) {\n        continue;\n      }\n      pushAdd(n);\n    }\n\n    for (const n of this.addedSet) {\n      if (\n        !isAncestorInSet(this.droppedSet, n) &&\n        !isParentRemoved(this.removes, n, this.mirror)\n      ) {\n        pushAdd(n);\n      } else if (isAncestorInSet(this.movedSet, n)) {\n        pushAdd(n);\n      } else {\n        this.droppedSet.add(n);\n      }\n    }\n\n    let candidate: DoubleLinkedListNode | null = null;\n    while (addList.length) {\n      let node: DoubleLinkedListNode | null = null;\n      if (candidate) {\n        const parentId = this.mirror.getId(\n          (candidate.value.parentNode as Node) as INode,\n        );\n        const nextId = getNextId(candidate.value);\n        if (parentId !== -1 && nextId !== -1) {\n          node = candidate;\n        }\n      }\n      if (!node) {\n        for (let index = addList.length - 1; index >= 0; index--) {\n          const _node = addList.get(index)!;\n          const parentId = this.mirror.getId(\n            (_node.value.parentNode as Node) as INode,\n          );\n          const nextId = getNextId(_node.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = _node;\n            break;\n          }\n        }\n      }\n      if (!node) {\n        /**\n         * If all nodes in queue could not find a serialized parent,\n         * it may be a bug or corner case. We need to escape the\n         * dead while loop at once.\n         */\n        while (addList.head) {\n          addList.removeNode(addList.head.value);\n        }\n        break;\n      }\n      candidate = node.previous;\n      addList.removeNode(node.value);\n      pushAdd(node.value);\n    }\n\n    const payload = {\n      texts: this.texts\n        .map((text) => ({\n          id: this.mirror.getId(text.node as INode),\n          value: text.value,\n        }))\n        // text mutation's id was not in the mirror map means the target node has been removed\n        .filter((text) => this.mirror.has(text.id)),\n      attributes: this.attributes\n        .map((attribute) => ({\n          id: this.mirror.getId(attribute.node as INode),\n          attributes: attribute.attributes,\n        }))\n        // attribute mutation's id was not in the mirror map means the target node has been removed\n        .filter((attribute) => this.mirror.has(attribute.id)),\n      removes: this.removes,\n      adds,\n    };\n    // payload may be empty if the mutations happened in some blocked elements\n    if (\n      !payload.texts.length &&\n      !payload.attributes.length &&\n      !payload.removes.length &&\n      !payload.adds.length\n    ) {\n      return;\n    }\n\n    // reset\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.addedSet = new Set<Node>();\n    this.movedSet = new Set<Node>();\n    this.droppedSet = new Set<Node>();\n    this.movedMap = {};\n\n    this.emissionCallback(payload);\n  };\n\n  private processMutation = (m: mutationRecord) => {\n    // console.log({ m });\n    if (isIgnored(m.target)) {\n      return;\n    }\n    switch (m.type) {\n      case 'characterData': {\n        const value = m.target.textContent;\n        if (!isBlocked(m.target, this.blockClass) && value !== m.oldValue) {\n          this.texts.push({\n            value:\n              needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n              ) && value\n                ? this.maskTextFn\n                  ? this.maskTextFn(value)\n                  : value.replace(/[\\S]/g, '*')\n                : value,\n            node: m.target,\n          });\n        }\n        break;\n      }\n      case 'attributes': {\n        const value = (m.target as HTMLElement).getAttribute(m.attributeName!);\n        if (isBlocked(m.target, this.blockClass) || value === m.oldValue) {\n          return;\n        }\n        let item: attributeCursor | undefined = this.attributes.find(\n          (a) => a.node === m.target,\n        );\n        if (!item) {\n          item = {\n            node: m.target,\n            attributes: {},\n          };\n          this.attributes.push(item);\n        }\n        // overwrite attribute if the mutations was triggered in same time\n        item.attributes[m.attributeName!] = transformAttribute(\n          this.doc,\n          (m.target as HTMLElement).tagName,\n          m.attributeName!,\n          value!,\n        );\n        break;\n      }\n      case 'childList': {\n        m.addedNodes.forEach((n) => this.genAdds(n, m.target));\n        m.removedNodes.forEach((n) => {\n          const nodeId = this.mirror.getId(n as INode);\n          const parentId = isShadowRoot(m.target)\n            ? this.mirror.getId((m.target.host as unknown) as INode)\n            : this.mirror.getId(m.target as INode);\n          if (\n            isBlocked(n, this.blockClass) ||\n            isBlocked(m.target, this.blockClass) ||\n            isIgnored(n)\n          ) {\n            return;\n          }\n          // removed node has not been serialized yet, just remove it from the Set\n          if (this.addedSet.has(n)) {\n            deepDelete(this.addedSet, n);\n            this.droppedSet.add(n);\n          } else if (this.addedSet.has(m.target) && nodeId === -1) {\n            /**\n             * If target was newly added and removed child node was\n             * not serialized, it means the child node has been removed\n             * before callback fired, so we can ignore it because\n             * newly added node will be serialized without child nodes.\n             * TODO: verify this\n             */\n          } else if (isAncestorRemoved(m.target as INode, this.mirror)) {\n            /**\n             * If parent id was not in the mirror map any more, it\n             * means the parent node has already been removed. So\n             * the node is also removed which we do not need to track\n             * and replay.\n             */\n          } else if (\n            this.movedSet.has(n) &&\n            this.movedMap[moveKey(nodeId, parentId)]\n          ) {\n            deepDelete(this.movedSet, n);\n          } else {\n            this.removes.push({\n              parentId,\n              id: nodeId,\n              isShadow: isShadowRoot(m.target) ? true : undefined,\n            });\n          }\n          this.mapRemoves.push(n);\n        });\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  private genAdds = (n: Node | INode, target?: Node | INode) => {\n    if (isBlocked(n, this.blockClass)) {\n      return;\n    }\n    if (target && isBlocked(target, this.blockClass)) {\n      return;\n    }\n    if (isINode(n)) {\n      if (isIgnored(n)) {\n        return;\n      }\n      this.movedSet.add(n);\n      let targetId: number | null = null;\n      if (target && isINode(target)) {\n        targetId = target.__sn.id;\n      }\n      if (targetId) {\n        this.movedMap[moveKey(n.__sn.id, targetId)] = true;\n      }\n    } else {\n      this.addedSet.add(n);\n      this.droppedSet.delete(n);\n    }\n    n.childNodes.forEach((childN) => this.genAdds(childN));\n  };\n}\n\n/**\n * Some utils to handle the mutation observer DOM records.\n * It should be more clear to extend the native data structure\n * like Set and Map, but currently Typescript does not support\n * that.\n */\nfunction deepDelete(addsSet: Set<Node>, n: Node) {\n  addsSet.delete(n);\n  n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\n\nfunction isParentRemoved(\n  removes: removedNodeMutation[],\n  n: Node,\n  mirror: Mirror,\n): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId((parentNode as Node) as INode);\n  if (removes.some((r) => r.id === parentId)) {\n    return true;\n  }\n  return isParentRemoved(removes, parentNode, mirror);\n}\n\nfunction isAncestorInSet(set: Set<Node>, n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return isAncestorInSet(set, parentNode);\n}\n","// tslint:disable:no-any no-bitwise forin\n/**\n * this file is used to serialize log message to string\n *\n */\n\nimport { StringifyOptions } from '../types';\n\n/**\n * transfer the node path in Event to string\n * @param node the first node in a node path array\n */\nfunction pathToSelector(node: HTMLElement): string | '' {\n  if (!node || !node.outerHTML) {\n    return '';\n  }\n\n  let path = '';\n  while (node.parentElement) {\n    let name = node.localName;\n    if (!name) {\n      break;\n    }\n    name = name.toLowerCase();\n    let parent = node.parentElement;\n\n    let domSiblings = [];\n\n    if (parent.children && parent.children.length > 0) {\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < parent.children.length; i++) {\n        let sibling = parent.children[i];\n        if (sibling.localName && sibling.localName.toLowerCase) {\n          if (sibling.localName.toLowerCase() === name) {\n            domSiblings.push(sibling);\n          }\n        }\n      }\n    }\n\n    if (domSiblings.length > 1) {\n      name += ':eq(' + domSiblings.indexOf(node) + ')';\n    }\n    path = name + (path ? '>' + path : '');\n    node = parent;\n  }\n\n  return path;\n}\n\n/**\n * stringify any js object\n * @param obj the object to stringify\n */\nexport function stringify(\n  obj: any,\n  stringifyOptions?: StringifyOptions,\n): string {\n  const options: StringifyOptions = {\n    numOfKeysLimit: 50,\n  };\n  Object.assign(options, stringifyOptions);\n  const stack: any[] = [];\n  const keys: any[] = [];\n  return JSON.stringify(obj, function (key, value) {\n    /**\n     * forked from https://github.com/moll/json-stringify-safe/blob/master/stringify.js\n     * to deCycle the object\n     */\n    if (stack.length > 0) {\n      const thisPos = stack.indexOf(this);\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n      if (~stack.indexOf(value)) {\n        if (stack[0] === value) {\n          value = '[Circular ~]';\n        } else {\n          value =\n            '[Circular ~.' +\n            keys.slice(0, stack.indexOf(value)).join('.') +\n            ']';\n        }\n      }\n    } else {\n      stack.push(value);\n    }\n    /* END of the FORK */\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n    if (shouldToString(value)) {\n      return toString(value);\n    }\n    if (value instanceof Event) {\n      const eventResult: any = {};\n      for (const eventKey in value) {\n        const eventValue = (value as any)[eventKey];\n        if (Array.isArray(eventValue)) {\n          eventResult[eventKey] = pathToSelector(\n            eventValue.length ? eventValue[0] : null,\n          );\n        } else {\n          eventResult[eventKey] = eventValue;\n        }\n      }\n      return eventResult;\n    } else if (value instanceof Node) {\n      if (value instanceof HTMLElement) {\n        return value ? value.outerHTML : '';\n      }\n      return value.nodeName;\n    }\n    return value;\n  });\n\n  /**\n   * whether we should call toString function of this object\n   */\n  function shouldToString(_obj: object): boolean {\n    if (\n      typeof _obj === 'object' &&\n      Object.keys(_obj).length > options.numOfKeysLimit\n    ) {\n      return true;\n    }\n    if (typeof _obj === 'function') {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * limit the toString() result according to option\n   */\n  function toString(_obj: object): string {\n    let str = _obj.toString();\n    if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n      str = `${str.slice(0, options.stringLengthLimit)}...`;\n    }\n    return str;\n  }\n}\n","/**\n * Class StackFrame is a fork of https://github.com/stacktracejs/stackframe/blob/master/stackframe.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n * 3. StackFrame contains some functions we don't need.\n */\nexport class StackFrame {\n  private fileName: string;\n  private functionName: string;\n  private lineNumber?: number;\n  private columnNumber?: number;\n\n  constructor(obj: {\n    fileName?: string;\n    functionName?: string;\n    lineNumber?: number;\n    columnNumber?: number;\n  }) {\n    this.fileName = obj.fileName || '';\n    this.functionName = obj.functionName || '';\n    this.lineNumber = obj.lineNumber;\n    this.columnNumber = obj.columnNumber;\n  }\n\n  toString() {\n    const lineNumber = this.lineNumber || '';\n    const columnNumber = this.columnNumber || '';\n    if (this.functionName) {\n      return (\n        this.functionName +\n        ' (' +\n        this.fileName +\n        ':' +\n        lineNumber +\n        ':' +\n        columnNumber +\n        ')'\n      );\n    }\n    return this.fileName + ':' + lineNumber + ':' + columnNumber;\n  }\n}\n\n/**\n * ErrorStackParser is a fork of https://github.com/stacktracejs/error-stack-parser/blob/master/error-stack-parser.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n */\nconst FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nexport const ErrorStackParser = {\n  /**\n   * Given an Error object, extract the most information from it.\n   *\n   * @param {Error} error object\n   * @return {Array} of StackFrames\n   */\n  parse: function (error: Error): StackFrame[] {\n    if (\n      // @ts-ignore\n      typeof error.stacktrace !== 'undefined' ||\n      // @ts-ignore\n      typeof error['opera#sourceloc'] !== 'undefined'\n    ) {\n      return this.parseOpera(\n        error as {\n          stacktrace?: string;\n          message: string;\n          stack?: string;\n        },\n      );\n    } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n      return this.parseV8OrIE(error as { stack: string });\n    } else if (error.stack) {\n      return this.parseFFOrSafari(error as { stack: string });\n    } else {\n      throw new Error('Cannot parse given Error object');\n    }\n  },\n  // Separate line and column numbers from a string of the form: (URI:Line:Column)\n  extractLocation: function (urlLike: string) {\n    // Fail-fast but return locations like \"(native)\"\n    if (urlLike.indexOf(':') === -1) {\n      return [urlLike];\n    }\n\n    const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n    const parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n    if (!parts) throw new Error(`Cannot parse given url: ${urlLike}`);\n    return [parts[1], parts[2] || undefined, parts[3] || undefined];\n  },\n  parseV8OrIE: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !!line.match(CHROME_IE_STACK_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      if (line.indexOf('(eval ') > -1) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        line = line\n          .replace(/eval code/g, 'eval')\n          .replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n      }\n      let sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n      // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n      // case it has spaces in it, as the string is split on \\s+ later on\n      const location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n      // remove the parenthesized location from the line, if it was matched\n      sanitizedLine = location\n        ? sanitizedLine.replace(location[0], '')\n        : sanitizedLine;\n\n      const tokens = sanitizedLine.split(/\\s+/).slice(1);\n      // if a location was matched, pass it to extractLocation() otherwise pop the last token\n      const locationParts = this.extractLocation(\n        location ? location[1] : tokens.pop(),\n      );\n      const functionName = tokens.join(' ') || undefined;\n      const fileName =\n        ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1\n          ? undefined\n          : locationParts[0];\n\n      return new StackFrame({\n        functionName,\n        fileName,\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n  parseFFOrSafari: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      // Throw away eval information until we implement stacktrace.js/stackframe#8\n      if (line.indexOf(' > eval') > -1) {\n        line = line.replace(\n          / line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,\n          ':$1',\n        );\n      }\n\n      if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n        // Safari eval frames only have function names and nothing else\n        return new StackFrame({\n          functionName: line,\n        });\n      } else {\n        const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n        const matches = line.match(functionNameRegex);\n        const functionName = matches && matches[1] ? matches[1] : undefined;\n        const locationParts = this.extractLocation(\n          line.replace(functionNameRegex, ''),\n        );\n\n        return new StackFrame({\n          functionName,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n        });\n      }\n    }, this);\n  },\n  parseOpera: function (e: {\n    stacktrace?: string;\n    message: string;\n    stack?: string;\n  }): StackFrame[] {\n    if (\n      !e.stacktrace ||\n      (e.message.indexOf('\\n') > -1 &&\n        e.message.split('\\n').length > e.stacktrace.split('\\n').length)\n    ) {\n      return this.parseOpera9(e as { message: string });\n    } else if (!e.stack) {\n      return this.parseOpera10(e as { stacktrace: string });\n    } else {\n      return this.parseOpera11(e as { stack: string });\n    }\n  },\n  parseOpera9: function (e: { message: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n    const lines = e.message.split('\\n');\n    const result = [];\n\n    for (let i = 2, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  parseOpera10: function (e: { stacktrace: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n    const lines = e.stacktrace.split('\\n');\n    const result = [];\n\n    for (let i = 0, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  // Opera 10.65+ Error.stack very similar to FF/Safari\n  parseOpera11: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return (\n        !!line.match(FIREFOX_SAFARI_STACK_REGEXP) &&\n        !line.match(/^Error created at/)\n      );\n    }, this);\n\n    return filtered.map(function (line: string) {\n      const tokens = line.split('@');\n      const locationParts = this.extractLocation(tokens.pop());\n      const functionCall = tokens.shift() || '';\n      const functionName =\n        functionCall\n          .replace(/<anonymous function(: (\\w+))?>/, '$2')\n          .replace(/\\([^)]*\\)/g, '') || undefined;\n      return new StackFrame({\n        functionName,\n        fileName: locationParts[0],\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n};\n","// @ts-nocheck\nimport { INode, MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { FontFaceDescriptors, FontFaceSet } from 'css-font-loading-module';\nimport {\n  throttle,\n  on,\n  hookSetter,\n  getWindowHeight,\n  getWindowWidth,\n  isBlocked,\n  isTouchEvent,\n  patch,\n} from '../utils';\nimport {\n  mutationCallBack,\n  observerParam,\n  mousemoveCallBack,\n  mousePosition,\n  mouseInteractionCallBack,\n  MouseInteractions,\n  listenerHandler,\n  scrollCallback,\n  styleSheetRuleCallback,\n  viewportResizeCallback,\n  inputValue,\n  inputCallback,\n  hookResetter,\n  blockClass,\n  maskTextClass,\n  IncrementalSource,\n  hooksParam,\n  Arguments,\n  mediaInteractionCallback,\n  MediaInteractions,\n  SamplingStrategy,\n  canvasMutationCallback,\n  fontCallback,\n  fontParam,\n  MaskInputFn,\n  MaskTextFn,\n  logCallback,\n  LogRecordOptions,\n  Logger,\n  LogLevel,\n  Mirror,\n} from '../types';\nimport MutationBuffer from './mutation';\nimport { stringify } from './stringify';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\nimport { StackFrame, ErrorStackParser } from './error-stack-parser';\n\ntype WindowWithStoredMutationObserver = Window & {\n  __rrMutationObserver?: MutationObserver;\n};\ntype WindowWithAngularZone = Window & {\n  Zone?: {\n    __symbol__?: (key: string) => string;\n  };\n};\n\nexport const mutationBuffers: MutationBuffer[] = [];\n\nexport function initMutationObserver(\n  cb: mutationCallBack,\n  doc: Document,\n  blockClass: blockClass,\n  blockSelector: string | null,\n  maskTextClass: maskTextClass,\n  maskTextSelector: string | null,\n  inlineStylesheet: boolean,\n  maskInputOptions: MaskInputOptions,\n  maskTextFn: MaskTextFn | undefined,\n  recordCanvas: boolean,\n  slimDOMOptions: SlimDOMOptions,\n  mirror: Mirror,\n  iframeManager: IframeManager,\n  shadowDomManager: ShadowDomManager,\n  rootEl: Node,\n): MutationObserver {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  // see mutation.ts for details\n  mutationBuffer.init(\n    cb,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    recordCanvas,\n    slimDOMOptions,\n    doc,\n    mirror,\n    iframeManager,\n    shadowDomManager,\n  );\n  let mutationObserverCtor =\n    window.MutationObserver ||\n    /**\n     * Some websites may disable MutationObserver by removing it from the window object.\n     * If someone is using rrweb to build a browser extention or things like it, they\n     * could not change the website's code but can have an opportunity to inject some\n     * code before the website executing its JS logic.\n     * Then they can do this to store the native MutationObserver:\n     * window.__rrMutationObserver = MutationObserver\n     */\n    (window as WindowWithStoredMutationObserver).__rrMutationObserver;\n  const angularZoneSymbol = (window as WindowWithAngularZone)?.Zone?.__symbol__?.(\n    'MutationObserver',\n  );\n  if (\n    angularZoneSymbol &&\n    ((window as unknown) as Record<string, typeof MutationObserver>)[\n    angularZoneSymbol\n    ]\n  ) {\n    mutationObserverCtor = ((window as unknown) as Record<\n      string,\n      typeof MutationObserver\n    >)[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    mutationBuffer.processMutations.bind(mutationBuffer),\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  return observer;\n}\n\nfunction initMoveObserver(\n  cb: mousemoveCallBack,\n  sampling: SamplingStrategy,\n  doc: Document,\n  mirror: Mirror,\n): listenerHandler {\n  if (sampling.mousemove === false) {\n    return () => { };\n  }\n\n  const threshold =\n    typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\n  const callbackThreshold =\n    typeof sampling.mousemoveCallback === 'number'\n      ? sampling.mousemoveCallback\n      : 500;\n\n  let positions: mousePosition[] = [];\n  let timeBaseline: number | null;\n  const wrappedCb = throttle(\n    (\n      source:\n        | IncrementalSource.MouseMove\n        | IncrementalSource.TouchMove\n        | IncrementalSource.Drag,\n    ) => {\n      const totalOffset = Date.now() - timeBaseline!;\n      cb(\n        positions.map((p) => {\n          p.timeOffset -= totalOffset;\n          return p;\n        }),\n        source,\n      );\n      positions = [];\n      timeBaseline = null;\n    },\n    callbackThreshold,\n  );\n  const updatePosition = throttle<MouseEvent | TouchEvent | DragEvent>(\n    (evt) => {\n      const { target } = evt;\n      const { clientX, clientY } = isTouchEvent(evt)\n        ? evt.changedTouches[0]\n        : evt;\n      if (!timeBaseline) {\n        timeBaseline = Date.now();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror.getId(target as INode),\n        timeOffset: Date.now() - timeBaseline,\n      });\n      wrappedCb(\n        evt instanceof MouseEvent\n          ? IncrementalSource.MouseMove\n          : evt instanceof DragEvent\n            ? IncrementalSource.Drag\n            : IncrementalSource.TouchMove,\n      );\n    },\n    threshold,\n    {\n      trailing: false,\n    },\n  );\n  const handlers = [\n    on('mousemove', updatePosition, doc),\n    on('touchmove', updatePosition, doc),\n    on('drag', updatePosition, doc),\n  ];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initMouseInteractionObserver(\n  cb: mouseInteractionCallBack,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  if (sampling.mouseInteraction === false) {\n    return () => { };\n  }\n  const disableMap: Record<string, boolean | undefined> =\n    sampling.mouseInteraction === true ||\n      sampling.mouseInteraction === undefined\n      ? {}\n      : sampling.mouseInteraction;\n\n  const handlers: listenerHandler[] = [];\n  const getHandler = (eventKey: keyof typeof MouseInteractions) => {\n    return (event: MouseEvent | TouchEvent) => {\n      if (isBlocked(event.target as Node, blockClass)) {\n        return;\n      }\n      const e = isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e) {\n        return;\n      }\n      const id = mirror.getId(event.target as INode);\n      const { clientX, clientY } = e;\n      cb({\n        type: MouseInteractions[eventKey],\n        id,\n        x: clientX,\n        y: clientY,\n      });\n    };\n  };\n  Object.keys(MouseInteractions)\n    .filter(\n      (key) =>\n        Number.isNaN(Number(key)) &&\n        !key.endsWith('_Departed') &&\n        disableMap[key] !== false,\n    )\n    .forEach((eventKey: keyof typeof MouseInteractions) => {\n      const eventName = eventKey.toLowerCase();\n      const handler = getHandler(eventKey);\n      handlers.push(on(eventName, handler, doc));\n    });\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initScrollObserver(\n  cb: scrollCallback,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  const updatePosition = throttle<UIEvent>((evt) => {\n    if (!evt.target || isBlocked(evt.target as Node, blockClass)) {\n      return;\n    }\n    const id = mirror.getId(evt.target as INode);\n    if (evt.target === doc) {\n      const scrollEl = (doc.scrollingElement || doc.documentElement)!;\n      cb({\n        id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n      });\n    } else {\n      cb({\n        id,\n        x: (evt.target as HTMLElement).scrollLeft,\n        y: (evt.target as HTMLElement).scrollTop,\n      });\n    }\n  }, sampling.scroll || 100);\n  return on('scroll', updatePosition);\n}\n\nfunction initViewportResizeObserver(\n  cb: viewportResizeCallback,\n): listenerHandler {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = throttle(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    if (lastH !== height || lastW !== width) {\n      cb({\n        width: Number(width),\n        height: Number(height),\n      });\n      lastH = height;\n      lastW = width;\n    }\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nexport const INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nconst lastInputValueMap: WeakMap<EventTarget, inputValue> = new WeakMap();\nfunction initInputObserver(\n  cb: inputCallback,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  ignoreClass: string,\n  maskInputOptions: MaskInputOptions,\n  maskInputFn: MaskInputFn | undefined,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  function eventHandler(event: Event) {\n    const { target } = event;\n    if (\n      !target ||\n      !(target as Element).tagName ||\n      INPUT_TAGS.indexOf((target as Element).tagName) < 0 ||\n      isBlocked(target as Node, blockClass)\n    ) {\n      return;\n    }\n    const type: string | undefined = (target as HTMLInputElement).type;\n    if (\n      type === 'password' ||\n      (target as HTMLElement).classList.contains(ignoreClass)\n    ) {\n      return;\n    }\n    let text = (target as HTMLInputElement).value;\n    let isChecked = false;\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = (target as HTMLInputElement).checked;\n    } else if (\n      maskInputOptions[\n      (target as Element).tagName.toLowerCase() as keyof MaskInputOptions\n      ] ||\n      maskInputOptions[type as keyof MaskInputOptions]\n    ) {\n      if (maskInputFn) {\n        text = maskInputFn(text);\n      } else {\n        text = '*'.repeat(text.length);\n      }\n    }\n    cbWithDedup(target, { text, isChecked });\n    // if a radio was checked\n    // the other radios with the same name attribute will be unchecked.\n    const name: string | undefined = (target as HTMLInputElement).name;\n    if (type === 'radio' && name && isChecked) {\n      doc\n        .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\n        .forEach((el) => {\n          if (el !== target) {\n            cbWithDedup(el, {\n              text: (el as HTMLInputElement).value,\n              isChecked: !isChecked,\n            });\n          }\n        });\n    }\n  }\n  function cbWithDedup(target: EventTarget, v: inputValue) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (\n      !lastInputValue ||\n      lastInputValue.text !== v.text ||\n      lastInputValue.isChecked !== v.isChecked\n    ) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target as INode);\n      cb({\n        ...v,\n        id,\n      });\n    }\n  }\n  const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\n  const handlers: Array<\n    listenerHandler | hookResetter\n  > = events.map((eventName) => on(eventName, eventHandler, doc));\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    HTMLInputElement.prototype,\n    'value',\n  );\n  const hookProperties: Array<[HTMLElement, string]> = [\n    [HTMLInputElement.prototype, 'value'],\n    [HTMLInputElement.prototype, 'checked'],\n    [HTMLSelectElement.prototype, 'value'],\n    [HTMLTextAreaElement.prototype, 'value'],\n    // Some UI library use selectedIndex to set select value\n    [HTMLSelectElement.prototype, 'selectedIndex'],\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map((p) =>\n        hookSetter<HTMLElement>(p[0], p[1], {\n          set() {\n            // mock to a normal event\n            eventHandler({ target: this } as Event);\n          },\n        }),\n      ),\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initStyleSheetObserver(\n  cb: styleSheetRuleCallback,\n  mirror: Mirror,\n): listenerHandler {\n  const insertRule = CSSStyleSheet.prototype.insertRule;\n  CSSStyleSheet.prototype.insertRule = function (rule: string, index?: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        adds: [{ rule, index }],\n      });\n    }\n    return insertRule.apply(this, arguments);\n  };\n\n  const deleteRule = CSSStyleSheet.prototype.deleteRule;\n  CSSStyleSheet.prototype.deleteRule = function (index: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        removes: [{ index }],\n      });\n    }\n    return deleteRule.apply(this, arguments);\n  };\n\n  return () => {\n    CSSStyleSheet.prototype.insertRule = insertRule;\n    CSSStyleSheet.prototype.deleteRule = deleteRule;\n  };\n}\n\nfunction initMediaInteractionObserver(\n  mediaInteractionCb: mediaInteractionCallback,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const handler = (type: 'play' | 'pause') => (event: Event) => {\n    const { target } = event;\n    if (!target || isBlocked(target as Node, blockClass)) {\n      return;\n    }\n    mediaInteractionCb({\n      type: type === 'play' ? MediaInteractions.Play : MediaInteractions.Pause,\n      id: mirror.getId(target as INode),\n    });\n  };\n  const handlers = [on('play', handler('play')), on('pause', handler('pause'))];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initCanvasMutationObserver(\n  cb: canvasMutationCallback,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const props = Object.getOwnPropertyNames(CanvasRenderingContext2D.prototype);\n  const handlers: listenerHandler[] = [];\n  for (const prop of props) {\n    try {\n      if (\n        typeof CanvasRenderingContext2D.prototype[\n        prop as keyof CanvasRenderingContext2D\n        ] !== 'function'\n      ) {\n        continue;\n      }\n      const restoreHandler = patch(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        function (original) {\n          return function (\n            this: CanvasRenderingContext2D,\n            ...args: Array<unknown>\n          ) {\n            if (!isBlocked(this.canvas, blockClass)) {\n              setTimeout(() => {\n                const recordArgs = [...args];\n                if (prop === 'drawImage') {\n                  if (\n                    recordArgs[0] &&\n                    recordArgs[0] instanceof HTMLCanvasElement\n                  ) {\n                    recordArgs[0] = recordArgs[0].toDataURL();\n                  }\n                }\n                cb({\n                  id: mirror.getId((this.canvas as unknown) as INode),\n                  property: prop,\n                  args: recordArgs,\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        },\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter<CanvasRenderingContext2D>(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v) {\n            cb({\n              id: mirror.getId((this.canvas as unknown) as INode),\n              property: prop,\n              args: [v],\n              setter: true,\n            });\n          },\n        },\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initFontObserver(cb: fontCallback): listenerHandler {\n  const handlers: listenerHandler[] = [];\n\n  const fontMap = new WeakMap<FontFace, fontParam>();\n\n  const originalFontFace = FontFace;\n  // tslint:disable-next-line: no-any\n  (window as any).FontFace = function FontFace(\n    family: string,\n    source: string | ArrayBufferView,\n    descriptors?: FontFaceDescriptors,\n  ) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== 'string',\n      descriptors,\n      fontSource:\n        typeof source === 'string'\n          ? source\n          : // tslint:disable-next-line: no-any\n          JSON.stringify(Array.from(new Uint8Array(source as any))),\n    });\n    return fontFace;\n  };\n\n  const restoreHandler = patch(document.fonts, 'add', function (original) {\n    return function (this: FontFaceSet, fontFace: FontFace) {\n      setTimeout(() => {\n        const p = fontMap.get(fontFace);\n        if (p) {\n          cb(p);\n          fontMap.delete(fontFace);\n        }\n      }, 0);\n      return original.apply(this, [fontFace]);\n    };\n  });\n\n  handlers.push(() => {\n    // tslint:disable-next-line: no-any\n    (window as any).FonFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initLogObserver(\n  cb: logCallback,\n  logOptions: LogRecordOptions,\n): listenerHandler {\n  const logger = logOptions.logger;\n  if (!logger) {\n    return () => { };\n  }\n  let logCount = 0;\n  const cancelHandlers: listenerHandler[] = [];\n  // add listener to thrown errors\n  if (logOptions.level!.includes('error')) {\n    if (window) {\n      const originalOnError = window.onerror;\n      window.onerror = (\n        msg: Event | string,\n        file: string,\n        line: number,\n        col: number,\n        error: Error,\n      ) => {\n        if (originalOnError) {\n          originalOnError.apply(this, [msg, file, line, col, error]);\n        }\n        const trace: string[] = ErrorStackParser.parse(\n          error,\n        ).map((stackFrame: StackFrame) => stackFrame.toString());\n        const payload = [stringify(msg, logOptions.stringifyOptions)];\n        cb({\n          level: 'error',\n          trace,\n          payload,\n        });\n      };\n      cancelHandlers.push(() => {\n        window.onerror = originalOnError;\n      });\n    }\n  }\n  for (const levelType of logOptions.level!) {\n    cancelHandlers.push(replace(logger, levelType));\n  }\n  return () => {\n    cancelHandlers.forEach((h) => h());\n  };\n\n  /**\n   * replace the original console function and record logs\n   * @param logger the logger object such as Console\n   * @param level the name of log function to be replaced\n   */\n  function replace(_logger: Logger, level: LogLevel) {\n    if (!_logger[level]) {\n      return () => { };\n    }\n    // replace the logger.{level}. return a restore function\n    return patch(_logger, level, (original) => {\n      return (...args: unknown[]) => {\n        original.apply(this, args);\n        try {\n          const trace = ErrorStackParser.parse(new Error())\n            .map((stackFrame: StackFrame) => stackFrame.toString())\n            .splice(1); // splice(1) to omit the hijacked log function\n          const payload = args.map((s) =>\n            stringify(s, logOptions.stringifyOptions),\n          );\n          logCount++;\n          if (logCount < logOptions.lengthThreshold!) {\n            cb({\n              level,\n              trace,\n              payload,\n            });\n          } else if (logCount === logOptions.lengthThreshold) {\n            // notify the user\n            cb({\n              level: 'warn',\n              trace: [],\n              payload: [\n                stringify('The number of log records reached the threshold.'),\n              ],\n            });\n          }\n        } catch (error) {\n          original('rrweb logger error:', error, ...args);\n        }\n      };\n    });\n  }\n}\n\nfunction mergeHooks(o: observerParam, hooks: hooksParam) {\n  const {\n    mutationCb,\n    mousemoveCb,\n    mouseInteractionCb,\n    scrollCb,\n    viewportResizeCb,\n    inputCb,\n    mediaInteractionCb,\n    styleSheetRuleCb,\n    canvasMutationCb,\n    fontCb,\n    logCb,\n  } = o;\n  o.mutationCb = (...p: Arguments<mutationCallBack>) => {\n    if (hooks.mutation) {\n      hooks.mutation(...p);\n    }\n    mutationCb(...p);\n  };\n  o.mousemoveCb = (...p: Arguments<mousemoveCallBack>) => {\n    if (hooks.mousemove) {\n      hooks.mousemove(...p);\n    }\n    mousemoveCb(...p);\n  };\n  o.mouseInteractionCb = (...p: Arguments<mouseInteractionCallBack>) => {\n    if (hooks.mouseInteraction) {\n      hooks.mouseInteraction(...p);\n    }\n    mouseInteractionCb(...p);\n  };\n  o.scrollCb = (...p: Arguments<scrollCallback>) => {\n    if (hooks.scroll) {\n      hooks.scroll(...p);\n    }\n    scrollCb(...p);\n  };\n  o.viewportResizeCb = (...p: Arguments<viewportResizeCallback>) => {\n    if (hooks.viewportResize) {\n      hooks.viewportResize(...p);\n    }\n    viewportResizeCb(...p);\n  };\n  o.inputCb = (...p: Arguments<inputCallback>) => {\n    if (hooks.input) {\n      hooks.input(...p);\n    }\n    inputCb(...p);\n  };\n  o.mediaInteractionCb = (...p: Arguments<mediaInteractionCallback>) => {\n    if (hooks.mediaInteaction) {\n      hooks.mediaInteaction(...p);\n    }\n    mediaInteractionCb(...p);\n  };\n  o.styleSheetRuleCb = (...p: Arguments<styleSheetRuleCallback>) => {\n    if (hooks.styleSheetRule) {\n      hooks.styleSheetRule(...p);\n    }\n    styleSheetRuleCb(...p);\n  };\n  o.canvasMutationCb = (...p: Arguments<canvasMutationCallback>) => {\n    if (hooks.canvasMutation) {\n      hooks.canvasMutation(...p);\n    }\n    canvasMutationCb(...p);\n  };\n  o.fontCb = (...p: Arguments<fontCallback>) => {\n    if (hooks.font) {\n      hooks.font(...p);\n    }\n    fontCb(...p);\n  };\n  o.logCb = (...p: Arguments<logCallback>) => {\n    if (hooks.log) {\n      hooks.log(...p);\n    }\n    logCb(...p);\n  };\n}\n\nexport function initObservers(\n  o: observerParam,\n  hooks: hooksParam = {},\n): listenerHandler {\n  mergeHooks(o, hooks);\n  const mutationObserver = initMutationObserver(\n    o.mutationCb,\n    o.doc,\n    o.blockClass,\n    o.blockSelector,\n    o.maskTextClass,\n    o.maskTextSelector,\n    o.inlineStylesheet,\n    o.maskInputOptions,\n    o.maskTextFn,\n    o.recordCanvas,\n    o.slimDOMOptions,\n    o.mirror,\n    o.iframeManager,\n    o.shadowDomManager,\n    o.doc,\n  );\n  const mousemoveHandler = initMoveObserver(\n    o.mousemoveCb,\n    o.sampling,\n    o.doc,\n    o.mirror,\n  );\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.sampling,\n  );\n  const scrollHandler = initScrollObserver(\n    o.scrollCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.sampling,\n  );\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);\n  const inputHandler = initInputObserver(\n    o.inputCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.ignoreClass,\n    o.maskInputOptions,\n    o.maskInputFn,\n    o.sampling,\n  );\n  const mediaInteractionHandler = initMediaInteractionObserver(\n    o.mediaInteractionCb,\n    o.blockClass,\n    o.mirror,\n  );\n  const styleSheetObserver = initStyleSheetObserver(\n    o.styleSheetRuleCb,\n    o.mirror,\n  );\n  const canvasMutationObserver = o.recordCanvas\n    ? initCanvasMutationObserver(o.canvasMutationCb, o.blockClass, o.mirror)\n    : () => { };\n  const fontObserver = o.collectFonts ? initFontObserver(o.fontCb) : () => { };\n  const logObserver = o.logOptions\n    ? initLogObserver(o.logCb, o.logOptions)\n    : () => { };\n\n  return () => {\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    canvasMutationObserver();\n    fontObserver();\n    logObserver();\n  };\n}\n","import { snapshot, MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { initObservers, mutationBuffers } from './observer';\nimport {\n  on,\n  getWindowWidth,\n  getWindowHeight,\n  polyfill,\n  isIframeINode,\n  hasShadowRoot,\n  createMirror,\n} from '../utils';\nimport {\n  EventType,\n  event,\n  eventWithTime,\n  recordOptions,\n  IncrementalSource,\n  listenerHandler,\n  LogRecordOptions,\n  mutationCallbackParam,\n} from '../types';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\n\nfunction wrapEvent(e: event): eventWithTime {\n  return {\n    ...e,\n    timestamp: Date.now(),\n  };\n}\n\nlet wrappedEmit!: (e: eventWithTime, isCheckout?: boolean) => void;\n\nlet takeFullSnapshot!: (isCheckout?: boolean) => void;\n\nconst mirror = createMirror();\nfunction record<T = eventWithTime>(\n  options: recordOptions<T> = {},\n): listenerHandler | undefined {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = 'rr-block',\n    blockSelector = null,\n    ignoreClass = 'rr-ignore',\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskInputFn,\n    maskTextFn,\n    hooks,\n    packFn,\n    sampling = {},\n    mousemoveWait,\n    recordCanvas = false,\n    collectFonts = false,\n    recordLog = false,\n  } = options;\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n  // move departed options to new options\n  if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n    sampling.mousemove = mousemoveWait;\n  }\n\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n        }\n      : _maskInputOptions !== undefined\n      ? _maskInputOptions\n      : {};\n\n  const slimDOMOptions: SlimDOMOptions =\n    _slimDOMOptions === true || _slimDOMOptions === 'all'\n      ? {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaVerification: true,\n          // the following are off for slimDOMOptions === true,\n          // as they destroy some (hidden) info:\n          headMetaAuthorship: _slimDOMOptions === 'all',\n          headMetaDescKeywords: _slimDOMOptions === 'all',\n        }\n      : _slimDOMOptions\n      ? _slimDOMOptions\n      : {};\n  const defaultLogOptions: LogRecordOptions = {\n    level: [\n      'assert',\n      'clear',\n      'count',\n      'countReset',\n      'debug',\n      'dir',\n      'dirxml',\n      // 'error',\n      'group',\n      'groupCollapsed',\n      'groupEnd',\n      'info',\n      'log',\n      'table',\n      'time',\n      'timeEnd',\n      'timeLog',\n      'trace',\n      'warn',\n    ],\n    lengthThreshold: 1000,\n    logger: console,\n  };\n\n  const logOptions: LogRecordOptions = recordLog\n    ? recordLog === true\n      ? defaultLogOptions\n      : Object.assign({}, defaultLogOptions, recordLog)\n    : {};\n\n  polyfill();\n\n  let lastFullSnapshotEvent: eventWithTime;\n  let incrementalSnapshotCount = 0;\n  wrappedEmit = (e: eventWithTime, isCheckout?: boolean) => {\n    if (\n      mutationBuffers[0]?.isFrozen() &&\n      e.type !== EventType.FullSnapshot &&\n      !(\n        e.type === EventType.IncrementalSnapshot &&\n        e.data.source === IncrementalSource.Mutation\n      )\n    ) {\n      // we've got a user initiated event so first we need to apply\n      // all DOM changes that have been buffering during paused state\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n\n    emit(((packFn ? packFn(e) : e) as unknown) as T, isCheckout);\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      // attch iframe should be considered as full snapshot\n      if (\n        e.data.source === IncrementalSource.Mutation &&\n        e.data.isAttachIframe\n      ) {\n        return;\n      }\n\n      incrementalSnapshotCount++;\n      const exceedCount =\n        checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime =\n        checkoutEveryNms &&\n        e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  const wrappedMutationEmit = (m: mutationCallbackParam) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.Mutation,\n          ...m,\n        },\n      }),\n    );\n  };\n\n  const iframeManager = new IframeManager({\n    mutationCb: wrappedMutationEmit,\n  });\n\n  const shadowDomManager = new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    bypassOptions: {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      recordCanvas,\n      slimDOMOptions,\n      iframeManager,\n    },\n    mirror,\n  });\n\n  takeFullSnapshot = (isCheckout = false) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight(),\n        },\n      }),\n      isCheckout,\n    );\n\n    mutationBuffers.forEach((buf) => buf.lock()); // don't allow any mirror modifications during snapshotting\n    const [node, idNodeMap] = snapshot(document, {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      recordCanvas,\n      onSerialize: (n) => {\n        if (isIframeINode(n)) {\n          iframeManager.addIframe(n);\n        }\n        if (hasShadowRoot(n)) {\n          shadowDomManager.addShadowRoot(n.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n      },\n    });\n\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n\n    mirror.map = idNodeMap;\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: {\n            left:\n              window.pageXOffset !== undefined\n                ? window.pageXOffset\n                : document?.documentElement.scrollLeft ||\n                  document?.body?.parentElement?.scrollLeft ||\n                  document?.body.scrollLeft ||\n                  0,\n            top:\n              window.pageYOffset !== undefined\n                ? window.pageYOffset\n                : document?.documentElement.scrollTop ||\n                  document?.body?.parentElement?.scrollTop ||\n                  document?.body.scrollTop ||\n                  0,\n          },\n        },\n      }),\n    );\n    mutationBuffers.forEach((buf) => buf.unlock()); // generate & emit any mutations that happened during snapshotting, as can now apply against the newly built mirror\n  };\n\n  try {\n    const handlers: listenerHandler[] = [];\n    handlers.push(\n      on('DOMContentLoaded', () => {\n        wrappedEmit(\n          wrapEvent({\n            type: EventType.DomContentLoaded,\n            data: {},\n          }),\n        );\n      }),\n    );\n\n    const observe = (doc: Document) => {\n      return initObservers(\n        {\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source,\n                  positions,\n                },\n              }),\n            ),\n          mouseInteractionCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MouseInteraction,\n                  ...d,\n                },\n              }),\n            ),\n          scrollCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Scroll,\n                  ...p,\n                },\n              }),\n            ),\n          viewportResizeCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.ViewportResize,\n                  ...d,\n                },\n              }),\n            ),\n          inputCb: (v) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Input,\n                  ...v,\n                },\n              }),\n            ),\n          mediaInteractionCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MediaInteraction,\n                  ...p,\n                },\n              }),\n            ),\n          styleSheetRuleCb: (r) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.StyleSheetRule,\n                  ...r,\n                },\n              }),\n            ),\n          canvasMutationCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.CanvasMutation,\n                  ...p,\n                },\n              }),\n            ),\n          fontCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Font,\n                  ...p,\n                },\n              }),\n            ),\n          logCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Log,\n                  ...p,\n                },\n              }),\n            ),\n          blockClass,\n          ignoreClass,\n          maskTextClass,\n          maskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordCanvas,\n          collectFonts,\n          doc,\n          maskInputFn,\n          maskTextFn,\n          logOptions,\n          blockSelector,\n          slimDOMOptions,\n          mirror,\n          iframeManager,\n          shadowDomManager,\n        },\n        hooks,\n      );\n    };\n\n    iframeManager.addLoadListener((iframeEl) => {\n      handlers.push(observe(iframeEl.contentDocument!));\n    });\n\n    const init = () => {\n      takeFullSnapshot();\n      handlers.push(observe(document));\n    };\n    if (\n      document.readyState === 'interactive' ||\n      document.readyState === 'complete'\n    ) {\n      init();\n    } else {\n      handlers.push(\n        on(\n          'load',\n          () => {\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.Load,\n                data: {},\n              }),\n            );\n            init();\n          },\n          window,\n        ),\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  } catch (error) {\n    // TODO: handle internal error\n    console.warn(error);\n  }\n}\n\nrecord.addCustomEvent = <T>(tag: string, payload: T) => {\n  if (!wrappedEmit) {\n    throw new Error('please add custom event after start recording');\n  }\n  wrappedEmit(\n    wrapEvent({\n      type: EventType.Custom,\n      data: {\n        tag,\n        payload,\n      },\n    }),\n  );\n};\n\nrecord.freezePage = () => {\n  mutationBuffers.forEach((buf) => buf.freeze());\n};\n\nrecord.takeFullSnapshot = (isCheckout?: boolean) => {\n  if (!takeFullSnapshot) {\n    throw new Error('please take full snapshot after start recording');\n  }\n  takeFullSnapshot(isCheckout);\n};\n\nrecord.mirror = mirror;\n\nexport default record;\n","import { serializedNodeWithId, INode } from '../snapshot';\nimport { mutationCallBack } from '../types';\n\nexport class IframeManager {\n  private iframes: WeakMap<HTMLIFrameElement, true> = new WeakMap();\n  private mutationCb: mutationCallBack;\n  private loadListener?: (iframeEl: HTMLIFrameElement) => unknown;\n\n  constructor(options: { mutationCb: mutationCallBack }) {\n    this.mutationCb = options.mutationCb;\n  }\n\n  public addIframe(iframeEl: HTMLIFrameElement) {\n    this.iframes.set(iframeEl, true);\n  }\n\n  public addLoadListener(cb: (iframeEl: HTMLIFrameElement) => unknown) {\n    this.loadListener = cb;\n  }\n\n  public attachIframe(iframeEl: INode, childSn: serializedNodeWithId) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: iframeEl.__sn.id,\n          nextId: null,\n          node: childSn,\n        },\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true,\n    });\n    this.loadListener?.((iframeEl as unknown) as HTMLIFrameElement);\n  }\n}\n","import {\n  mutationCallBack,\n  blockClass,\n  maskTextClass,\n  MaskTextFn,\n  Mirror,\n} from '../types';\nimport { MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { IframeManager } from './iframe-manager';\nimport { initMutationObserver } from './observer';\n\ntype BypassOptions = {\n  blockClass: blockClass;\n  blockSelector: string | null;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  inlineStylesheet: boolean;\n  maskInputOptions: MaskInputOptions;\n  maskTextFn: MaskTextFn | undefined;\n  recordCanvas: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  iframeManager: IframeManager;\n};\n\nexport class ShadowDomManager {\n  private mutationCb: mutationCallBack;\n  private bypassOptions: BypassOptions;\n  private mirror: Mirror;\n\n  constructor(options: {\n    mutationCb: mutationCallBack;\n    bypassOptions: BypassOptions;\n    mirror: Mirror;\n  }) {\n    this.mutationCb = options.mutationCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n  }\n\n  public addShadowRoot(shadowRoot: ShadowRoot, doc: Document) {\n    initMutationObserver(\n      this.mutationCb,\n      doc,\n      this.bypassOptions.blockClass,\n      this.bypassOptions.blockSelector,\n      this.bypassOptions.maskTextClass,\n      this.bypassOptions.maskTextSelector,\n      this.bypassOptions.inlineStylesheet,\n      this.bypassOptions.maskInputOptions,\n      this.bypassOptions.maskTextFn,\n      this.bypassOptions.recordCanvas,\n      this.bypassOptions.slimDOMOptions,\n      this.mirror,\n      this.bypassOptions.iframeManager,\n      this,\n      shadowRoot,\n    );\n  }\n}\n","// @ts-nocheck\n\nimport { strFromU8, strToU8, zlibSync } from 'fflate';\nimport { PackFn, MARK, eventWithTimeAndPacker } from './base';\n\nexport const pack: PackFn = (event) => {\n  const _e: eventWithTimeAndPacker = {\n    ...event,\n    v: MARK,\n  };\n  return strFromU8(zlibSync(strToU8(JSON.stringify(_e))), true);\n};\n","import { eventWithTime } from '../types';\n\nexport type PackFn = (event: eventWithTime) => string;\nexport type UnpackFn = (raw: string) => eventWithTime;\n\nexport type eventWithTimeAndPacker = eventWithTime & {\n  v: string;\n};\n\nexport const MARK = 'v1';\n","import { AskLevel } from \"../types/types\"\nimport { config } from \"../config/config\"\nimport { W } from \"../constants\"\nimport record from \"../rrweb/record\"\nimport { pack } from \"../rrweb/packer\"\nimport { eventWithTime } from \"../rrweb/types\"\nimport { warn } from \"../utils/console\"\n\n/**\n * Error Trap\n */\n\nexport default class ErrorTrace {\n  private static instance: ErrorTrace | null = null\n  private eventsMatrix: Array<Array<eventWithTime>> = [[]]\n\n  private constructor() {\n    this.globalErrorTrace()\n    this.networkErrorTrace()\n    this.promiseErrorTrace()\n    this.iframeErrorTrace()\n    record({\n      ...config.recordOptions,\n      emit: (event, isCheckout) => {\n        if (isCheckout) {\n          this.eventsMatrix.push([]);\n        }\n        const lastEvents = this.eventsMatrix[this.eventsMatrix.length - 1];\n        lastEvents.push(event);\n      },\n      recordLog: false,\n      checkoutEveryNth: 10,\n      packFn: pack,\n    })\n  }\n\n  public static getInstance(): ErrorTrace {\n    if (!this.instance) {\n      this.instance = new ErrorTrace()\n    }\n    return this.instance\n  }\n\n  /**\n   * Globally catch synchronous or asynchronous errors\n   * 捕获异常的能力比try-catch稍微强点，无论是异步还是非异步，onerror都能捕获到运行时错误，返回true就不回报红\n   * 当时当<img src=\"\" />这种情况是捕获不到的\n   * 使用未使用的变量\n   */\n  private globalErrorTrace(): void {\n    W.onerror = (\n      event: Event | string,\n      source?: string,\n      lineno?: number,\n      colno?: number,\n      error?: Error\n    ) => {\n\n      warn({\n        source,\n        lineno,\n        colno,\n        error,\n      })\n\n      const len = this.eventsMatrix.length;\n\n      if (config.errEventRoute && len >= 2) {\n        const events = this.eventsMatrix[len - 2].concat(this.eventsMatrix[len - 1]);\n        config.reportData?.fetch(\n          AskLevel.IDLE,\n          JSON.stringify({ events }),\n          config.errEventRoute\n        )\n      }\n\n      if (config.errLogRoute) {\n        config.reportData?.fetch(\n          AskLevel.IDLE,\n          JSON.stringify({\n            source,\n            lineno,\n            colno,\n            error: JSON.stringify({\n              message: error?.message,\n              stack: error?.stack,\n              name: error?.name,\n            }),\n          }),\n          config.errLogRoute\n        )\n      }\n      return true\n    }\n  }\n  /**\n   * Catch network errors\n   * 图片加载失败等\n   */\n  private networkErrorTrace(): void {\n    W.addEventListener(\n      \"error\",\n      (e: ErrorEvent) => {\n        if (e.target !== W) {\n          warn(e.target)\n        }\n      },\n      true\n    )\n  }\n\n  /**\n   * Catching Promise errors\n   */\n  private promiseErrorTrace(): void {\n    window.addEventListener(\"unhandledrejection\", (e) => {\n      e.preventDefault()\n      warn(e.reason)\n      return true\n    })\n  }\n\n  private iframeErrorTrace(): void {\n    const frames = W.frames\n    for (let i = 0; i < frames.length; i++) {\n      frames[i].addEventListener(\n        \"error\",\n        (e: ErrorEvent) => {\n          warn(e)\n        },\n        true\n      )\n      frames[i].addEventListener(\n        \"unhandledrejection\",\n        (e) => {\n          warn(e)\n        },\n        true\n      )\n    }\n  }\n}\n","import { AskLevel, ReportDataAchieve } from \"../types/types\"\nimport { W, WN } from \"../constants\"\nimport { config } from \"../config/config\"\n\nexport interface ReportDataOptions {\n  logDomain: string | undefined,\n}\n\n/**\n * Log collection\n * 日志收集\n */\nexport default class ReportData implements ReportDataAchieve {\n  /**\n   * Log report, error report\n   * If the level is urgent, use http request directly, otherwise use navigator.sendBeacon\n   * 日志上报、错误上报\n   * 如果level很紧急，直接使用http请求，否者使用navigator.sendBeacon\n   * @param level\n   * @param body \n   * @param uri \n   */\n  public fetch(level: AskLevel, body: string, uri: string): void {\n    uri = config.fetchDomain + uri\n\n    switch (level) {\n      case AskLevel.URGENT: {\n        if (!!W.fetch) {\n          fetch(uri, { body, method: \"POST\", keepalive: true })\n        } else {\n          let xhr: XMLHttpRequest | null = new XMLHttpRequest()\n          xhr.open(\"post\", uri, true)\n          xhr.setRequestHeader(\"Content-Type\", \"application/json\")\n          xhr.send(body)\n          xhr.onload = () => xhr = null // 防止内存泄漏\n        }\n        return\n      }\n      default:\n        if (!!WN.sendBeacon) {\n          navigator.sendBeacon(uri, body)\n        } else {\n          let image: HTMLImageElement | null = new Image()\n          image.src = `${uri}?body=${body}`\n          image.onload = () => image = null // 防止内存泄漏\n        }\n    }\n  }\n}","import { W, WP } from \"../constants\"\n\n/**\n * Determine whether the browser supports getEntriesByType\n * @returns \n */\nexport const isPerformanceSupported = (): boolean => {\n  return WP && !!WP.getEntriesByType && !!WP.now && !!WP.mark\n}\n\n/**\n * bytes to kb\n * @param {number} bytes\n */\nexport const bytes2kb = (bytes: number) => {\n  return parseFloat((bytes / Math.pow(1024, 2)).toFixed(2))\n}\n\n/**\n * Keep two decimal places\n * @param {number} num\n * @returns \n */\nexport const roundByTwo = (num: number) => {\n  return parseFloat(num.toFixed(2))\n}\n\n/**\n * PushTask to requestIdleCallback\n * Efficient use of each frame for data collection\n * @param {() => void} callback\n */\nexport const pushTask = (callback: () => void) => {\n  if (\"requestIdleCallback\" in W) {\n    (W as any).requestIdleCallback(callback, { timeout: 3000 })\n  } else {\n    callback()\n  }\n}","import { bytes2kb } from \"../utils/helper\"\nimport { WN } from \"../constants\"\nimport type { StorageOpt } from \"../types/types\"\n\n/**\n  * Record local cache information\n*/\n\nexport const recordingStorage = async (): Promise<StorageOpt> => {\n  if (!WN.storage) return { usageDetails: {} }\n\n  const { quota, usage, usageDetails } = await WN.storage.estimate() as StorageOpt\n  let res = {\n    quota: bytes2kb(quota || 0),\n    usage: bytes2kb(usage || 0),\n    usageDetails,\n  }\n  if (res.usageDetails) {\n    Object.keys(res.usageDetails || {}).forEach(key => res.usageDetails[key] = bytes2kb(res.usageDetails[key]))\n  }\n  return res\n}","import { WN } from \"../constants\"\nimport type { EffectiveType, NavigatorOpt } from \"../types/types\"\nimport { pushTask } from \"../utils/helper\"\n\nexport let effectiveType: EffectiveType = \"4g\"\nexport let saveData: boolean = false\n\n/**\n   * Get user's browser information, internet speed and other information\n   * Calculating network speed formula\n   * T1 = DNS + New Connection(TCP) + RTT(One-time transmission)\n   * T2 = New Connection(TCP) + RTT(One-time transmission)\n   * T3 = RTT(One-time transmission)\n   * bandwidth = (100k-50k)/(t5-t4)\n   * @return {NavigatorOpt}\n   */\nexport const recordClientNavigator = async (): Promise<NavigatorOpt> => {\n  return new Promise(resolve => {\n    let res = {} as NavigatorOpt\n    if (\"connection\" in WN) {\n      res.connection = {\n        downlink: WN.connection.downlink,\n        effectiveType: WN.connection.effectiveType,\n        rtt: WN.connection.rtt,\n        saveData: WN.connection.saveData,\n      }\n      saveData = res.connection.saveData || saveData\n      effectiveType = res.connection.effectiveType || effectiveType\n    }\n    // Doppler Velocity\n    if (\"fetch\" in window) {\n      pushTask(async () => {\n        let times = []\n        const sizes = [0, 0, 0, 50, 100]\n\n        times.push(+ new Date())\n\n        for (let size of sizes) {\n          await fetch(`http://performance-monitoring.zhourengui.top/performance-monitoring/doppler-velocity?size=${size}`)\n          times.push(+ new Date())\n        }\n\n        res.connection.bandwidth = `${((sizes[4] - sizes[3]) / ((times[5] - times[4]) / 1000)).toFixed(2)} k/s`\n        resolve(res)\n      })\n    }\n\n    res.userAgent = WN.userAgent\n  })\n}","import { WP } from \"../constants\"\nimport { isPerformanceSupported } from \"../utils/helper\"\nimport type { TimingOpt } from \"../types/types\"\n/**\n  * Navigation Timing API provides performance metrics for HTML documents.\n  * w3c.github.io/navigation-timing/\n  * developers.google.com/web/fundamentals/performance/navigation-and-resource-timing\n  */\nexport const recordTiming = async (): Promise<TimingOpt> => {\n  let res = {} as TimingOpt\n  if (isPerformanceSupported()) {\n    // There is an open issue to type correctly getEntriesByType\n    // github.com/microsoft/TypeScript/issues/33866\n    const n = WP.getEntriesByType(\"navigation\")[0] as any\n    if (n) {\n      const responseEnd = n.responseEnd\n      const responseStart = n.responseStart\n      const requestStart = n.requestStart\n      res = {\n        // fetchStart marks when the browser starts to fetch a resource\n        // responseEnd is when the last byte of the response arrives\n        fetchTime: responseEnd - n.fetchStart,\n        // Service worker time plus response time\n        workerTime: responseEnd - n.workerStart,\n        // Request plus response time (network only)\n        networkTime: responseEnd - requestStart,\n        // Response time only (download)\n        downloadTime: responseEnd - responseStart,\n        // Time to First Byte (TTFB)\n        timeToFirstByte: responseStart - requestStart,\n        // HTTP header size\n        headerSize: n.decodedBodySize - n.transferSize || 0,\n        // DNS Lookup Time\n        dnsLookupTime: n.domainLookupStart - n.domainLookupEnd,\n        // TCP time\n        tcpTime: n.connectStart - n.connectEnd || 0,\n        // First paint\n        firstPaintTime: responseEnd - responseStart || 0,\n        // Dom Parse Time\n        domParseTime: n.domComplete - n.domInteractive,\n        // Dom Render Time\n        domRenderTime: n.domContentLoadedEventEnd - n.domContentLoadedEventStart || 0,\n        // onload time\n        onloadTime: n.loadEventEnd - n.loadEventStart\n      }\n    }\n  }\n\n  return res\n}","import { WN } from \"../constants\"\nimport { effectiveType, saveData } from \"../performance/record-client-navigator\"\nimport { EffectiveType, NavigatorInformation } from \"../types/types\"\n\nexport const isLowEndDevice = (): boolean => {\n  return WN.deviceMemory <= 4 || WN.hardwareConcurrency <= 4\n}\n\nexport const isLowEndExperience = (\n  effectiveType: EffectiveType,\n  saveData: boolean\n): boolean => {\n  if ([\"slow-2g\", \"2g\", \"3g\"].includes(effectiveType)) {\n    return true\n  }\n\n  return isLowEndDevice() || saveData\n}\n\n/**\n * 信息来源于 window.navigator:\n * 1. Device Memory 设备内存\n * 2. Hardware Concurency 并发数\n * 3. Status of the service worker:\n *     - controlled: a service worker is controlling the page\n *     - supported: the browser supports service worker\n *     - unsupported: the user's browser does not support service worker\n */\nexport const getNavigatorInformation = (): NavigatorInformation | undefined => {\n  if (WN) {\n    return {\n      deviceMemory: WN.deviceMemory || 0,\n      hardwareConcurrency: WN.hardwareConcurrency || 0,\n      serviceWorkerStatus:\n        'serviceWorker' in WN\n          ? WN.serviceWorker?.controller\n            ? \"controlled\"\n            : \"supported\"\n          : \"unsupported\",\n      isLowEndDevice: isLowEndDevice(),\n      isLowEndExperience: isLowEndExperience(effectiveType, saveData)\n    }\n  }\n}","import { NavigatorOpt, TimingOpt, VitalsScore } from \"../types/types\";\n\n/**\n * https://web.dev/vitals/\n * https://web.dev/cls/\n */\nconst fcpScore = [1000, 2500];\nconst lcpScore = [2500, 4000];\nconst fidcore = [100, 300];\nconst clsScore = [0.1, 0.25];\nconst tbtScore = [300, 600];\n\nexport const webVitalsScore: Record<string, number[]> = {\n  fp: fcpScore,\n  fcp: fcpScore,\n  lcp: lcpScore,\n  lcpFinal: lcpScore,\n  fid: fidcore,\n  fidVitals: fidcore,\n  cls: clsScore,\n  clsFinal: clsScore,\n  tbt: tbtScore,\n  tbt5S: tbtScore,\n  tbt10S: tbtScore,\n  tbtFinal: tbtScore,\n};\n\nexport const getVitalsScore = (\n  measureName: string,\n  value: number\n): VitalsScore => {\n  if (!webVitalsScore[measureName]) {\n    return null\n  }\n\n  if (value <= webVitalsScore[measureName][0]) {\n    return \"good\"\n  }\n\n  return value <= webVitalsScore[measureName][1] ? \"needsImprovement\" : \"poor\"\n}","import { config } from \"../config/config\"\nimport { D } from \"../constants\"\nimport { NavigatorOpt, TimingOpt } from \"../types/types\"\nimport { pushTask } from \"./helper\"\nimport { getNavigatorInformation } from \"./navigator-information\"\nimport { getVitalsScore } from \"./vitals-score\"\n\n/**\n * Sends the User timing measure to analyticsTracker\n * Do not report specific data when the page is hidden\n * @param {string} measureName\n * @param {number} duration\n * @param {object} eventProperties\n */\nexport const reportPerformance = (\n  data: TimingOpt | number | NavigatorOpt | any,\n  measureName: string,\n  eventProperties?: object\n): void => {\n  pushTask(() => {\n    if (D.visibilityState === \"hidden\" && !measureName.includes(\"Final\") || !config.analyticsTracker) return\n    config.analyticsTracker({\n      metricName: measureName,\n      data,\n      eventProperties,\n      navigatorInformation: getNavigatorInformation(),\n      vitalsScore: getVitalsScore(measureName, data as number)\n    })\n  })\n}","import { config } from \"../config/config\"\nimport { roundByTwo } from \"./helper\"\nimport { reportPerformance } from \"./report-performance\"\n\n/**\n * Sends the metric to an external tracking service\n * 将指标发送到外部跟踪服务\n * @param {string} measureName \n * @param {{[key: string]: any}} metric \n * @param {object} customProperties \n */\nexport const logData = (\n  measureName: string,\n  metric: { [key: string]: any },\n  customProperties?: object\n): void => {\n  Object.keys(metric).forEach((key) => {\n    if (typeof metric[key] === 'number') {\n      metric[key] = roundByTwo(metric[key]);\n    }\n  });\n  reportPerformance(metric, measureName, customProperties);\n};\n\n/**\n * Dispatches the metric duration into internal logs\n * and the external time tracking service.\n * @param {string} measureName\n * @param {number} duration\n * @param {object} customProperties\n */\nexport const logMetric = (\n  measureName: string,\n  duration: number,\n  customProperties?: object\n) => {\n  const duration2decimal = roundByTwo(duration)\n  if (duration2decimal <= (config.maxTime as number)) {\n    reportPerformance(duration, measureName, customProperties)\n  }\n}","import { ResourceTime } from \"../types/types\";\n\n// first-pait\nexport const fp = {\n  value: 0\n}\n\n// first-contentful-paint\nexport const fcp = {\n  value: 0\n}\n\n// block-time\nexport const tbt = {\n  value: 0\n}\n\n// largest-contentful-paint\nexport const lcp = {\n  value: 0\n}\n\n// resource-time\nexport const rt: { value: ResourceTime } = {\n  value: {\n    beacon: 0,\n    css: 0,\n    fetch: 0,\n    img: 0,\n    other: 0,\n    script: 0,\n    total: 0,\n    xmlhttprequest: 0,\n  },\n};\n\n// cumulative-layout-shift\nexport const cls = {\n  value: 0\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logMetric } from \"../utils/log\"\nimport { fcp, fp, lcp } from \"../utils/metrics\"\nimport { disconnectPO } from \"./performance-observer\"\n\n/**\n * FirstPaintObserverCallback\n * @returns \n */\nexport const initFirstPaint = (\n  callback: () => void\n) => (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (entry.name === \"first-paint\") {\n      fp.value = entry.startTime\n      logMetric(\"fp\", entry.startTime)\n    } else if (entry.name === \"first-contentful-paint\") {\n      fcp.value = entry.startTime\n      logMetric(\"fcp\", entry.startTime)\n      callback()\n      disconnectPO(\"paint\")\n    }\n  }\n}\n\n/**\n * LargestContentfulPaintObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries \n */\nexport const initLargestContentfulPaint = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry) {\n    lcp.value = lastEntry.renderTime || lastEntry.startTime\n  }\n}\n\n/**\n * ElementTimingObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries\n */\nexport const initElementTiming = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (entry.identifier) {\n      logMetric(entry.identifier, entry.startTime, {\n        performanceEntry: entry\n      })\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logMetric } from \"../utils/log\"\nimport { tbt, fcp } from \"../utils/metrics\"\n\n/**\n * LongtaskObserverCallback\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Long_Tasks_API\n * The definition of a long task is a task longer than 50ms\n * 长任务的定义是超过50ms的任务\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns \n */\nexport const initLongtask = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    const blockingTime = entry.startTime - 50\n    if (entry.name !== \"self\" && entry.startTime < fcp.value) return\n    if (blockingTime > 0) {\n      tbt.value += entry.startTime\n      logMetric(\"longtask\", entry.startTime)\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logData, logMetric } from \"../utils/log\"\nimport { tbt, cls, lcp, rt } from \"../utils/metrics\"\nimport { disconnectPO, performanceObserverInstance } from \"./performance-observer\"\n\n/**\n * FirstInputObserverCallback\n * Take the last entry\n * @param {Array<PerformanceEntryEncapsulation>} entries\n */\nexport const initFirstInput = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry) {\n    // Core Web Vitals FID logic\n    // Delayed operation of measurement input events\n    // 测量输入事件的延迟操作\n    logMetric(\n      \"fidVitals\",\n      lastEntry.processingStart - lastEntry.startTime,\n      {\n        performanceEntry: lastEntry\n      }\n    )\n\n    // Measure the duration of processing the first input event\n    // 测量处理第一个输入事件的持续时间\n    logMetric(\n      \"fid\",\n      lastEntry.duration,\n      {\n        performanceEntry: lastEntry\n      }\n    )\n  }\n\n  // Destroy the registered callback for FID to avoid memory leaks caused by too many observers\n  // 销毁对FID的注册回调 避免过多的观察者造成内存泄露\n  disconnectPO(\"first-input\")\n\n  // lcp log\n  logMetric(\"lcp\", lcp.value)\n\n  // Force any pending records to be dispatched\n  // 强制分派所有待处理的记录\n  if (\n    performanceObserverInstance[\"layout-shift\"] &&\n    typeof performanceObserverInstance[\"layout-shift\"].takeRecords === \"function\"\n  ) {\n    performanceObserverInstance[\"layout-shift\"].takeRecords()\n  }\n\n  // cls log\n  logMetric(\"cls\", cls.value)\n\n  // bt log\n  logMetric(\"bt\", tbt.value)\n\n  // TBT with 5 second delay after FID\n  setTimeout(() => {\n    logMetric(\"bt5S\", tbt.value)\n  }, 5000)\n\n  // TBT with 10 second delay after FID\n  // 10S overall data consumption after FID is activated\n  setTimeout(() => {\n    logMetric(\"bt10S\", tbt.value)\n    logData(\"dataConsumption\", rt.value)\n  }, 10000)\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logData } from \"../utils/log\"\nimport { rt } from \"../utils/metrics\"\n\n/**\n * ResouceTimingObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns \n */\nexport const initResouceTiming = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n\n    logData(\"resourceTiming\", entry)\n\n    if (entry.decodedBodySize && entry.initiatorType) {\n      const bodySize = entry.decodedBodySize / 1000\n      rt.value[entry.initiatorType] += bodySize\n      rt.value.total += bodySize\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\";\nimport { cls } from \"../utils/metrics\";\n\n/**\n * https://web.dev/cls/\n * https://requestmetrics.com/web-performance/cumulative-layout-shift\n * \n * Cumulative Layout Shift (CLS), \n * sometimes known as jank, \n * is a measurement of how much elements move due to late-rendered content.\n * You can think of it as a measurement of layout instability. \n * It has become a common problem for many websites due to third-party scripts and tag management and its one of the new Core Web Vital metrics.\n * \n * LayoutShiftObserverCallback\n * Detects new layout shift occurrences and updates the\n * Only count layout shifts without recent user input.\n * 检测新的布局偏移情况并更新\n * 仅在没有最近用户输入的情况下计算布局转移。\n * \n * What is a good CLS score?\n * To provide a good user experience, sites should strive to have a CLS score of 0.1 or less. To ensure you're hitting this target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices.\n * 为了提供良好的用户体验，网站应努力使CLS得分不超过0.1。为确保您达到大多数用户的这一目标，衡量移动设备和台式机设备的页面加载量的第75个百分位数是一个很好的衡量标准。\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns\n */\nexport const initLayoutShift = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry && !lastEntry.hadRecentInput && lastEntry.value) {\n    cls.value += lastEntry.value\n  }\n}","import { PerformanceEntryEncapsulation, PerformanceObserverEventType, PerformanceObservers } from \"../types/types\"\nimport { name } from \"../../package.json\"\nimport { C } from \"../constants\"\nimport { initElementTiming, initFirstPaint, initLargestContentfulPaint } from \"./paint\"\nimport { initLongtask } from \"./longtask\"\nimport { initFirstInput } from \"./first-input\"\nimport { config } from \"../config/config\"\nimport { initResouceTiming } from \"./resource\"\nimport { initLayoutShift } from \"./layout-shift\"\nimport { logMetric } from \"../utils/log\"\nimport { tbt, cls, lcp } from \"../utils/metrics\"\n\nexport const performanceObserverInstance: PerformanceObservers = {}\n\n/**\n * PerformanceObserver asynchronous subscription\n * PerformanceObserver异步订阅\n * @param {PerformanceObserverEventType} eventType 监听的事件类型 Types of events monitored\n * @param {(entries: Array<PerformanceEntryEncapsulation>) => void} callback 监听的回调 Listened callback\n */\nconst asyncSubscripePO = (\n  eventType: PerformanceObserverEventType,\n  callback: (entries: Array<PerformanceEntryEncapsulation>) => void\n): PerformanceObserver | null => {\n  try {\n    const Observer = new PerformanceObserver(\n      (entries) =>\n        callback(\n          entries.getEntries() as Array<PerformanceEntryEncapsulation>\n        )\n    )\n    Observer.observe({ type: eventType, buffered: true })\n    return Observer\n  } catch (error) {\n    C.warn(\"PerformanceMonitoring obsever🌲:\", `${name}: ${error}`);\n  }\n  return null\n}\n\n/**\n * Cancel the monitoring of PerformanceObserver\n * 取消PerformanceObserver的监听\n * @param {string} eventType 监听的事件类型 Types of events monitored\n */\nexport const disconnectPO = (eventType: string) => {\n  if (performanceObserverInstance[eventType]) {\n    performanceObserverInstance[eventType]?.disconnect()\n  }\n  delete performanceObserverInstance[eventType]\n}\n\n/**\n * PerformanceObserver initialization\n * PerformanceObserver初始化\n * paint: fp、fcp、largest-contentful-paint\n * longtask\n * first-input\n */\nexport const initPerformanceObserver = (): void => {\n  performanceObserverInstance[\"paint\"] = asyncSubscripePO(\n    \"paint\",\n    initFirstPaint(\n      () => performanceObserverInstance[\"longtask\"] = asyncSubscripePO(\"longtask\", initLongtask)\n    )\n  )\n\n  performanceObserverInstance[\"first-input\"] = asyncSubscripePO(\n    \"first-input\",\n    initFirstInput\n  )\n\n  performanceObserverInstance[\"largest-contentful-paint\"] = asyncSubscripePO(\n    \"largest-contentful-paint\",\n    initLargestContentfulPaint\n  )\n\n  // Collect page performance data\n  // 收集页面性能数据\n  if (config.isObserverResourceTiming) {\n    asyncSubscripePO(\"resource\", initResouceTiming)\n  }\n\n  performanceObserverInstance[\"layout-shift\"] = asyncSubscripePO(\n    \"layout-shift\",\n    initLayoutShift\n  )\n\n  if (config.isObserverElementTiming) {\n    asyncSubscripePO(\"element\", initElementTiming)\n  }\n}\n\n\nexport const disconnectPerformanceObserver = (): void => {\n  if (performanceObserverInstance[\"largest-contentful-paint\"]) {\n    logMetric(\"lcpFinal\", lcp.value)\n    disconnectPO(\"largest-contentful-paint\")\n  }\n\n  if (performanceObserverInstance[\"layout-shift\"]) {\n    // Force any pending records to be dispatched\n    // 强制分派所有待处理的记录\n    if (typeof performanceObserverInstance[\"layout-shift\"].takeRecords === \"function\") {\n      performanceObserverInstance[\"layout-shift\"].takeRecords()\n    }\n    logMetric(\"clsFinal\", cls.value)\n    disconnectPO(\"layout-shift\")\n  }\n\n  if (performanceObserverInstance[\"longtask\"]) {\n    logMetric(\"btFinal\", tbt.value)\n    disconnectPO(\"longtask\")\n  }\n}","import ErrorTrace from \"./error-trace\"\nimport ReportData from \"./utils/ReportData\"\nimport { recordingStorage } from \"./performance/record-storage\"\nimport { version } from \"../package.json\"\nimport { config } from \"./config/config\"\nimport { recordClientNavigator } from \"./performance/record-client-navigator\"\nimport { recordTiming } from \"./performance/record-timing\"\nimport { isPerformanceSupported } from \"./utils/helper\"\nimport { AskLevel, PerformanceMonitoringOptions } from \"./types/types\"\nimport { disconnectPerformanceObserver, initPerformanceObserver } from \"./performance/performance-observer\"\nimport { D } from \"./constants\"\nimport { log } from \"./utils/console\"\n\n/**\n * A performance monitoring platform SDK\n * Features include error capture, error recording, performance monitoring\n * 功能包括错误捕获、错误录制、性能监控\n * 一款性能监控平台SDK\n * @packageDocumentation\n */\nexport default class PerformanceMonitoring {\n  constructor(options: PerformanceMonitoringOptions) {\n    const {\n      isObserverElementTiming,\n      isObserverResourceTiming,\n      maxTime,\n      captureError,\n      fetchDomain,\n      errLogRoute,\n      errEventRoute,\n      logRoute,\n      analyticsTracker,\n      recordOptions,\n    } = options || {}\n\n    config.isObserverElementTiming = !!isObserverElementTiming\n    config.isObserverResourceTiming = !!isObserverResourceTiming\n    config.maxTime = maxTime || config.maxTime\n    config.captureError = captureError || config.captureError\n    config.fetchDomain = fetchDomain\n    config.errLogRoute = errLogRoute\n    config.errEventRoute = errEventRoute\n    config.logRoute = logRoute\n    config.reportData = new ReportData()\n    config.analyticsTracker = analyticsTracker || config.analyticsTracker\n    config.recordOptions = recordOptions || config.recordOptions\n\n    log(version)\n\n    if (captureError && fetchDomain) {\n      ErrorTrace.getInstance()\n    }\n\n    if (isPerformanceSupported()) {\n\n      if (D.visibilityState === \"hidden\") {\n        D.addEventListener(\n          \"visibilitychange\",\n          disconnectPerformanceObserver\n        )\n      }\n\n      if (fetchDomain && logRoute) {\n        Promise.all([\n          recordTiming(),\n          recordClientNavigator(),\n          recordingStorage()\n        ]).then(res => {\n          config.reportData?.fetch(\n            AskLevel.IDLE,\n            JSON.stringify(res),\n            logRoute\n          )\n        })\n      }\n\n      initPerformanceObserver()\n    }\n  }\n}"],"names":["AskLevel","NodeType","W","window","WP","performance","WN","navigator","C","console","D","document","prefix","log","message","warn","config","isObserverResourceTiming","isObserverElementTiming","maxTime","captureError","reportData","undefined","analyticsTracker","options","recordOptions","fetchDomain","errLogRoute","errEventRoute","logRoute","isShadowRoot","n","host","Boolean","shadowRoot","_id","tagNameRegex","RegExp","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","isCSSImportRule","styleSheet","cssText","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","url","filePath","maybeQuote","test","indexOf","split","slice","stack","parts","pop","part","push","EventType","IncrementalSource","MouseInteractions","ReplayerEvents","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","transformAttribute","tagName","name","value","pos","collectCharacters","regEx","chars","match","exec","substring","length","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","nodeType","ELEMENT_NODE","classList","contains","forEach","className","matches","parentNode","lowerIfExists","maybeAttr","toLowerCase","serializeNodeWithId","id","blockClass","blockSelector","skipChild","inlineStylesheet","maskInputOptions","maskTextFn","slimDOMOptions","recordCanvas","onSerialize","onIframeLoad","iframeLoadTimeout","preserveWhiteSpace","_serializedNode","rootId","el","__sn","docId","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","eIndex","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","textContent","repeat","checked","parentElement","selected","rr_dataURL","toDataURL","rr_mediaState","paused","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","getBoundingClientRect","class","rr_width","width","rr_height","height","src","Element","isSVG","SVGElement","TEXT_NODE","parentTagName","isStyle","isScript","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNode","sn","comment","script","as","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","Object","assign","recordChild","headWhitespace","bypassOptions","serializedChildNode","isElement","isShadowHost","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","blankUrl","location","addEventListener","timer","setTimeout","clearTimeout","onceIframeLoaded","iframeDoc","contentDocument","serializedIframeNode","on","fn","target","capture","passive","removeEventListener","DEPARTED_MIRROR_ACCESS_WARNING","_mirror","getId","getNode","removeNodeFromMap","has","reset","throttle","func","wait","timeout","previous","arg","now","Date","leading","remaining","context","this","args","arguments","apply","trailing","hookSetter","key","d","isRevoked","original","getOwnPropertyDescriptor","defineProperty","set","call","_this2","patch","source","replacement","wrapped","prototype","defineProperties","__rrweb_original__","enumerable","getWindowHeight","innerHeight","documentElement","clientHeight","body","getWindowWidth","innerWidth","clientWidth","isBlocked","isIgnored","isAncestorRemoved","mirror","isTouchEvent","event","changedTouches","isIframeINode","hasShadowRoot","isNodeInLinkedList","Proxy","Reflect","get","prop","receiver","DoubleLinkedList","position","Error","current","head","index","next","addNode","__ln","previousSibling","nextSibling","removeNode","moveKey","parentId","isINode","MutationBuffer","Set","mutations","_this","processMutation","emit","frozen","locked","adds","addList","getNextId","ns","nextId","pushAdd","shadowHost","getRootNode","_n$getRootNode","notInDoc","currentN","iframeManager","addIframe","shadowDomManager","addShadowRoot","iframe","childSn","attachIframe","mapRemoves","shift","movedSet","isParentRemoved","removes","addedSet","isAncestorInSet","droppedSet","add","candidate","_node","payload","texts","text","filter","attribute","movedMap","emissionCallback","m","oldValue","getAttribute","attributeName","item","addedNodes","genAdds","removedNodes","nodeId","deepDelete","targetId","childN","init","cb","freeze","unfreeze","isFrozen","lock","unlock","addsSet","some","r","pathToSelector","outerHTML","path","localName","parent","domSiblings","children","i","sibling","stringify","obj","stringifyOptions","numOfKeysLimit","keys","JSON","thisPos","splice","Infinity","_obj","str","toString","stringLengthLimit","Event","eventResult","eventKey","eventValue","isArray","Node","HTMLElement","nodeName","StackFrame","fileName","functionName","lineNumber","columnNumber","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","ErrorStackParser","parse","stacktrace","parseOpera","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","line","sanitizedLine","tokens","locationParts","functionNameRegex","e","parseOpera9","parseOpera11","parseOpera10","lineRE","lines","result","len","parseFloat","mutationBuffers","initMutationObserver","rootEl","mutationBuffer","mutationObserverCtor","MutationObserver","__rrMutationObserver","angularZoneSymbol","_window","Zone","_window$Zone","__symbol__","observer","processMutations","bind","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","wrappedEmit","takeFullSnapshot","INPUT_TAGS","lastInputValueMap","WeakMap","IframeManager","mutationCb","iframes","addLoadListener","loadListener","isAttachIframe","ShadowDomManager","wrapEvent","timestamp","child","hasOwnProperty","record","checkoutEveryNms","checkoutEveryNth","ignoreClass","maskAllInputs","_maskInputOptions","_slimDOMOptions","maskInputFn","hooks","packFn","sampling","mousemoveWait","collectFonts","recordLog","mousemove","lastFullSnapshotEvent","color","date","datetime-local","email","month","number","range","search","tel","time","week","textarea","select","defaultLogOptions","level","lengthThreshold","logger","logOptions","NodeList","DOMTokenList","TypeError","incrementalSnapshotCount","isCheckout","FullSnapshot","IncrementalSnapshot","data","Mutation","buf","wrappedMutationEmit","Meta","slimDOM","idNodeMap","password","snapshot","initialOffset","left","pageXOffset","_document2","_document2$body","_document2$body$paren","_document3","top","pageYOffset","_document5","_document5$body","_document5$body$paren","_document6","handlers","DomContentLoaded","o","mousemoveCb","mouseInteractionCb","scrollCb","viewportResizeCb","inputCb","mediaInteractionCb","styleSheetRuleCb","canvasMutationCb","fontCb","logCb","p","mutation","mouseInteraction","scroll","viewportResize","input","mediaInteaction","styleSheetRule","canvasMutation","font","mergeHooks","lastH","lastW","mutationObserver","mousemoveHandler","timeBaseline","threshold","positions","wrappedCb","totalOffset","timeOffset","mousemoveCallback","updatePosition","evt","clientX","clientY","x","y","MouseEvent","MouseMove","DragEvent","Drag","TouchMove","h","initMoveObserver","mouseInteractionHandler","disableMap","Number","isNaN","endsWith","eventName","handler","getHandler","initMouseInteractionObserver","scrollHandler","scrollEl","scrollingElement","initScrollObserver","viewportResizeHandler","inputHandler","eventHandler","isChecked","cbWithDedup","querySelectorAll","v","lastInputValue","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","initInputObserver","mediaInteractionHandler","initMediaInteractionObserver","styleSheetObserver","insertRule","CSSStyleSheet","ownerNode","deleteRule","initStyleSheetObserver","canvasMutationObserver","props","getOwnPropertyNames","CanvasRenderingContext2D","restoreHandler","canvas","recordArgs","HTMLCanvasElement","hookHandler","setter","initCanvasMutationObserver","fontObserver","fontMap","originalFontFace","FontFace","family","descriptors","fontFace","buffer","fontSource","Uint8Array","fonts","FonFace","initFontObserver","logObserver","logCount","cancelHandlers","includes","originalOnError","onerror","msg","file","col","_this3","trace","stackFrame","_logger","initLogObserver","disconnect","initObservers","MouseInteraction","Scroll","ViewportResize","Input","MediaInteraction","StyleSheetRule","CanvasMutation","Font","Log","Load","addCustomEvent","tag","Custom","freezePage","pack","_e","strFromU8","zlibSync","strToU8","ErrorTrace","globalErrorTrace","networkErrorTrace","promiseErrorTrace","iframeErrorTrace","eventsMatrix","getInstance","instance","lineno","colno","events","concat","fetch","IDLE","preventDefault","reason","frames","ReportData","uri","URGENT","method","keepalive","xhr","XMLHttpRequest","open","setRequestHeader","send","onload","sendBeacon","image","Image","isPerformanceSupported","getEntriesByType","mark","bytes2kb","bytes","Math","pow","toFixed","roundByTwo","num","pushTask","callback","requestIdleCallback","recordingStorage","storage","estimate","usage","usageDetails","res","quota","_settle","onFulfilled","effectiveType","saveData","recordClientNavigator","Promise","resolve","connection","downlink","rtt","bandwidth","sizes","times","size","userAgent","recordTiming","responseEnd","responseStart","requestStart","fetchTime","fetchStart","workerTime","workerStart","networkTime","downloadTime","timeToFirstByte","headerSize","decodedBodySize","transferSize","dnsLookupTime","domainLookupStart","domainLookupEnd","tcpTime","connectStart","connectEnd","firstPaintTime","domParseTime","domComplete","domInteractive","domRenderTime","domContentLoadedEventEnd","domContentLoadedEventStart","onloadTime","loadEventEnd","loadEventStart","isLowEndDevice","deviceMemory","hardwareConcurrency","isLowEndExperience","getNavigatorInformation","serviceWorkerStatus","serviceWorker","controller","fcpScore","lcpScore","fidcore","clsScore","tbtScore","webVitalsScore","fp","fcp","lcp","lcpFinal","fid","fidVitals","cls","clsFinal","tbt","tbt5S","tbt10S","tbtFinal","getVitalsScore","measureName","reportPerformance","eventProperties","visibilityState","metricName","navigatorInformation","vitalsScore","logData","metric","customProperties","logMetric","duration","rt","beacon","css","img","other","total","xmlhttprequest","initLargestContentfulPaint","entries","lastEntry","renderTime","startTime","initElementTiming","entry","identifier","performanceEntry","initLongtask","initFirstInput","processingStart","disconnectPO","performanceObserverInstance","takeRecords","initResouceTiming","initiatorType","bodySize","initLayoutShift","hadRecentInput","asyncSubscripePO","eventType","Observer","PerformanceObserver","getEntries","buffered","disconnectPerformanceObserver","all","then"],"mappings":"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"}