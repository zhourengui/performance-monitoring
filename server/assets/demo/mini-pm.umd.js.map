{"version":3,"file":"mini-pm.umd.js","sources":["../src/types/types.ts","../src/rrweb/snapshot/types.ts","../src/constants.ts","../src/utils/console.ts","../src/config/config.ts","../src/rrweb/snapshot/utils.ts","../src/rrweb/snapshot/snapshot.ts","../src/rrweb/types.ts","../src/rrweb/utils.ts","../src/rrweb/record/mutation.ts","../src/rrweb/record/stringify.ts","../src/rrweb/record/error-stack-parser.ts","../src/rrweb/record/observer.ts","../src/rrweb/record/index.ts","../src/rrweb/record/iframe-manager.ts","../src/rrweb/record/shadow-dom-manager.ts","../src/rrweb/fflate/node-worker.ts","../src/rrweb/fflate/index.ts","../src/rrweb/packer/pack.ts","../src/rrweb/packer/base.ts","../src/error-trace/index.ts","../src/utils/ReportData.ts","../src/utils/helper.ts","../src/performance/record-storage.ts","../src/performance/record-client-navigator.ts","../src/performance/record-timing.ts","../src/utils/navigator-information.ts","../src/utils/vitals-score.ts","../src/utils/report-performance.ts","../src/utils/log.ts","../src/utils/metrics.ts","../src/performance/paint.ts","../src/performance/longtask.ts","../src/performance/first-input.ts","../src/performance/resource.ts","../src/performance/layout-shift.ts","../src/performance/performance-observer.ts","../src/index.ts"],"sourcesContent":["import { recordOptions } from \"../rrweb/types\";\n\nexport interface PerformanceMonitoringOptions {\n  isObserverResourceTiming?: boolean,\n  isObserverElementTiming?: boolean,\n  maxTime?: number,\n  captureError?: boolean,\n  reportData?: ReportDataAchieve | null,\n  fetchDomain?: string,\n  errLogRoute?: string,\n  errEventRoute?: string,\n  logRoute?: string,\n  analyticsTracker?: (options: AnalyticsTrackerOptions) => void,\n  recordOptions?: recordOptions<any>\n}\n\nexport interface StorageOpt {\n  quota?: number | undefined,\n  usage?: number | undefined,\n  usageDetails: { [key: string]: any }\n}\n\nexport interface TimingOpt {\n  // The time to initiate the network is from AppCache to ResponseEnd\n  // 发起网络的时间是从AppCache到ResponseEnd\n  fetchTime: number,\n  // Response time\n  // 响应时间\n  workerTime: number,\n  // Network request time\n  // 网络请求时间\n  networkTime: number,\n  // Server response time\n  // 服务器响应时间\n  downloadTime: number,\n  // The time when the browser received the first byte of the server\n  // 浏览器接收服务端的第一个字节的时间\n  timeToFirstByte: number,\n  // Request header size\n  // 请求头大小\n  headerSize: number,\n  // dns resolution time\n  // dns解析时间\n  dnsLookupTime: number,\n  // tcp connection time\n  // tcp连接时间\n  tcpTime: number,\n  // Blank screen time\n  // 白屏时间\n  firstPaintTime: number,\n  // dom rendering time\n  // dom渲染时间\n  domRenderTime: number,\n  // onload time\n  // onload时间\n  onloadTime: number,\n  // dom parsing time\n  // dom解析时间\n  domParseTime: number,\n}\n\nexport interface NavigatorOpt {\n  // 浏览器信息\n  // Browser information\n  userAgent: string,\n  // User's internet speed\n  // 用户的网速\n  connection: {\n    downlink?: number,\n    effectiveType?: EffectiveType,\n    rtt?: number,\n    saveData?: boolean,\n    [key: string]: unknown,\n    bandwidth?: string\n  }\n}\n\nexport interface ReportDataAchieve {\n  fetch: (label: AskLevel, body: string, uri: string) => void\n}\n\nexport interface PerformanceObservers {\n  [eventType: string]: PerformanceObserver | null;\n}\n\nexport enum AskLevel {\n  URGENT = 1,\n  IDLE = 2,\n}\n\nexport type PerformanceObserverEventType =\n  | \"paint\"\n  | \"longtask\"\n  | \"first-input\"\n  | \"largest-contentful-paint\"\n  | \"resource\"\n  | \"layout-shift\"\n  | \"element\"\n\nexport type VitalsScore = 'good' | 'needsImprovement' | 'poor' | null;\n\nexport interface AnalyticsTrackerOptions {\n  metricName: string;\n  data: TimingOpt | number | NavigatorOpt;\n  eventProperties: object | undefined;\n  navigatorInformation: unknown;\n  vitalsScore: VitalsScore;\n}\n\nexport interface NavigatorInformation {\n  deviceMemory?: number;\n  hardwareConcurrency?: number;\n  isLowEndDevice?: boolean;\n  isLowEndExperience?: boolean;\n  serviceWorkerStatus?: 'controlled' | 'supported' | 'unsupported';\n}\n\nexport type EffectiveType =\n  | '2g'\n  | '3g'\n  | '4g'\n  | '5g'\n  | 'slow-2g'\n  | 'lte';\n\nexport interface PerformanceEntryEncapsulation extends PerformanceEntry {\n  identifier: any;\n  value?: number | undefined;\n  hadRecentInput?: PerformanceEntryEncapsulation | undefined;\n  initiatorType?: string;\n  decodedBodySize?: number;\n  processingStart: DOMHighResTimeStamp;\n  target?: Node;\n  renderTime?: number\n}\n\nexport interface ResourceTime {\n  beacon: number;\n  css: number;\n  fetch: number;\n  img: number;\n  other: number;\n  script: number;\n  total: number;\n  xmlhttprequest: number;\n  [key: string]: number\n}","export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n\nexport type MaskTextFn = (text: string) => string;\n","interface Navigator {\n  sendBeacon: any\n  connection?: any\n  storage: any\n  userAgent: string\n  deviceMemory: number;\n  hardwareConcurrency: number;\n  serviceWorker?: {\n    controller?: string;\n  };\n}\n\nexport const W = window\nexport const WP = W.performance\nexport const WN = W.navigator as any as Navigator\nexport const C = W.console\nexport const D = document","import { C } from \"../constants\"\n\nconst prefix = \"mini-pm🐢：\"\n\nexport const log = (message: any, ...options: any[]): void => C.log(prefix, message, ...options)\n\nexport const warn = (message: any, ...options: any[]) => C.warn(prefix, message, ...options)\n\nexport const error = (message: any, ...options: any[]) => C.error(prefix, message, ...options)","import type { AnalyticsTrackerOptions, PerformanceMonitoringOptions } from \"../types/types\";\nimport { log } from \"../utils/console\";\n\nexport const config: PerformanceMonitoringOptions = {\n  isObserverResourceTiming: false,\n  isObserverElementTiming: false,\n  maxTime: 15000,\n  captureError: true,\n  reportData: null,\n  analyticsTracker: (options: AnalyticsTrackerOptions) => {\n    log(options)\n  },\n  recordOptions: {}\n}","import { INode } from './types';\n\nexport function isElement(n: Node | INode): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n  MaskTextFn,\n} from './types';\nimport { isElement, isShadowRoot } from './utils';\n\nlet _id = 1;\nconst tagNameRegex = RegExp('[^a-z0-9-_]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule)\n    ? getCssRulesString(rule.styleSheet) || ''\n    : rule.cssText;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin;\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    var chars,\n      match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  let output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        let c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n\nfunction getHref() {\n  // return a href without hash\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: string,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || ((name === 'href' || name === 'xlink:href') && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    value &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    // tslint:disable-next-line: prefer-for-of\n    for (let eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      const className = element.classList[eIndex];\n      if (blockClass.test(className)) {\n        return true;\n      }\n    }\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nexport function needMaskingText(\n  node: Node | null,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (typeof maskTextClass === 'string') {\n      if ((node as HTMLElement).classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (maskTextClass.test(className)) {\n          return true;\n        }\n      });\n    }\n    if (maskTextSelector) {\n      if ((node as HTMLElement).matches(maskTextSelector)) {\n        return true;\n      }\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    listener();\n    return;\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    recordCanvas: boolean;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    recordCanvas,\n  } = options;\n  // Only record root id when document object is not the base document\n  let rootId: number | undefined;\n  if (((doc as unknown) as INode).__sn) {\n    const docId = ((doc as unknown) as INode).__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      return {\n        type: NodeType.Document,\n        childNodes: [],\n        rootId,\n      };\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, tagName, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        const cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value =\n            maskInputOptions[attributes.type as keyof MaskInputOptions] ||\n            maskInputOptions[tagName as keyof MaskInputOptions]\n              ? '*'.repeat(value.length)\n              : value;\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        const selectValue = (n as HTMLOptionElement).parentElement;\n        if (attributes.value === (selectValue as HTMLSelectElement).value) {\n          attributes.selected = (n as HTMLOptionElement).selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL();\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      // block element\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      // iframe\n      if (tagName === 'iframe') {\n        delete attributes.src;\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n        rootId,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n      if (isStyle && textContent) {\n        textContent = absoluteToStylesheet(textContent, getHref());\n      }\n      if (isScript) {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      if (\n        !isStyle &&\n        !isScript &&\n        needMaskingText(n, maskTextClass, maskTextSelector) &&\n        textContent\n      ) {\n        textContent = maskTextFn\n          ? maskTextFn(textContent)\n          : textContent.replace(/[\\S]/g, '*');\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n        rootId,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      (sn.tagName === 'script' ||\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script'))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions?: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskTextFn,\n    slimDOMOptions,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    recordCanvas,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  if (onSerialize) {\n    onSerialize(n as INode);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      map,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      serializedNode.isShadowHost = true;\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            map,\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            slimDOMOptions,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(n as INode, serializedIframeNode);\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    slimDOM?: boolean | SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    blockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskTextFn,\n    slimDOM = false,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","import {\n  serializedNodeWithId,\n  idNodeMap,\n  INode,\n  MaskInputOptions,\n  SlimDOMOptions,\n} from './snapshot';\nimport { PackFn, UnpackFn } from './packer/base';\nimport { FontFaceDescriptors } from 'css-font-loading-module';\nimport { IframeManager } from './record/iframe-manager';\nimport { ShadowDomManager } from './record/shadow-dom-manager';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n  Custom,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport type logEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type customEvent<T = unknown> = {\n  type: EventType.Custom;\n  data: {\n    tag: string;\n    payload: T;\n  };\n};\n\nexport type styleSheetEvent = {};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n  TouchMove,\n  MediaInteraction,\n  StyleSheetRule,\n  CanvasMutation,\n  Font,\n  Log,\n  Drag,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source:\n  | IncrementalSource.MouseMove\n  | IncrementalSource.TouchMove\n  | IncrementalSource.Drag;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimension;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type mediaInteractionData = {\n  source: IncrementalSource.MediaInteraction;\n} & mediaInteractionParam;\n\nexport type styleSheetRuleData = {\n  source: IncrementalSource.StyleSheetRule;\n} & styleSheetRuleParam;\n\nexport type canvasMutationData = {\n  source: IncrementalSource.CanvasMutation;\n} & canvasMutationParam;\n\nexport type fontData = {\n  source: IncrementalSource.Font;\n} & fontParam;\n\nexport type logData = {\n  source: IncrementalSource.Log;\n} & LogParam;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData\n  | mediaInteractionData\n  | styleSheetRuleData\n  | canvasMutationData\n  | fontData\n  | logData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent\n  | logEvent\n  | customEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type blockClass = string | RegExp;\n\nexport type maskTextClass = string | RegExp;\n\nexport type SamplingStrategy = Partial<{\n  /**\n   * false means not to record mouse/touch move events\n   * number is the throttle threshold of recording mouse/touch move\n   */\n  mousemove: boolean | number;\n  /**\n   * number is the throttle threshold of mouse/touch move callback\n   */\n  mousemoveCallback: number;\n  /**\n   * false means not to record mouse interaction events\n   * can also specify record some kinds of mouse interactions\n   */\n  mouseInteraction: boolean | Record<string, boolean | undefined>;\n  /**\n   * number is the throttle threshold of recording scroll\n   */\n  scroll: number;\n  /**\n   * 'all' will record all the input events\n   * 'last' will only record the last input value while input a sequence of chars\n   */\n  input: 'all' | 'last';\n}>;\n\nexport type recordOptions<T> = {\n  emit?: (e: T, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n  blockClass?: blockClass;\n  blockSelector?: string;\n  ignoreClass?: string;\n  maskTextClass?: maskTextClass;\n  maskTextSelector?: string;\n  maskAllInputs?: boolean;\n  maskInputOptions?: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  slimDOMOptions?: SlimDOMOptions | 'all' | true;\n  inlineStylesheet?: boolean;\n  hooks?: hooksParam;\n  packFn?: PackFn;\n  sampling?: SamplingStrategy;\n  recordCanvas?: boolean;\n  collectFonts?: boolean;\n  // departed, please use sampling options\n  mousemoveWait?: number;\n  recordLog?: boolean | LogRecordOptions;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n  mediaInteractionCb: mediaInteractionCallback;\n  blockClass: blockClass;\n  blockSelector: string | null;\n  ignoreClass: string;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  maskInputOptions: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  inlineStylesheet: boolean;\n  styleSheetRuleCb: styleSheetRuleCallback;\n  canvasMutationCb: canvasMutationCallback;\n  fontCb: fontCallback;\n  logCb: logCallback;\n  logOptions: LogRecordOptions;\n  sampling: SamplingStrategy;\n  recordCanvas: boolean;\n  collectFonts: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  doc: Document;\n  mirror: Mirror;\n  iframeManager: IframeManager;\n  shadowDomManager: ShadowDomManager;\n};\n\nexport type hooksParam = {\n  mutation?: mutationCallBack;\n  mousemove?: mousemoveCallBack;\n  mouseInteraction?: mouseInteractionCallBack;\n  scroll?: scrollCallback;\n  viewportResize?: viewportResizeCallback;\n  input?: inputCallback;\n  mediaInteaction?: mediaInteractionCallback;\n  styleSheetRule?: styleSheetRuleCallback;\n  canvasMutation?: canvasMutationCallback;\n  font?: fontCallback;\n  log?: logCallback;\n};\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\nexport type mutationRecord = {\n  type: string;\n  target: Node;\n  oldValue: string | null;\n  addedNodes: NodeList;\n  removedNodes: NodeList;\n  attributeName: string | null;\n};\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n  isShadow?: boolean;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  // Newly recorded mutations will not have previousId any more, just for compatibility\n  previousId?: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\nexport type mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n  isAttachIframe?: true;\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (\n  p: mousePosition[],\n  source:\n    | IncrementalSource.MouseMove\n    | IncrementalSource.TouchMove\n    | IncrementalSource.Drag,\n) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove_Departed, // we will start a separate observer for touch move event\n  TouchEnd,\n}\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type styleSheetAddRule = {\n  rule: string;\n  index?: number;\n};\n\nexport type styleSheetDeleteRule = {\n  index: number;\n};\n\nexport type styleSheetRuleParam = {\n  id: number;\n  removes?: styleSheetDeleteRule[];\n  adds?: styleSheetAddRule[];\n};\n\nexport type styleSheetRuleCallback = (s: styleSheetRuleParam) => void;\n\nexport type canvasMutationCallback = (p: canvasMutationParam) => void;\n\nexport type canvasMutationParam = {\n  id: number;\n  property: string;\n  args: Array<unknown>;\n  setter?: true;\n};\n\nexport type fontParam = {\n  family: string;\n  fontSource: string;\n  buffer: boolean;\n  descriptors?: FontFaceDescriptors;\n};\n\nexport type LogLevel =\n  | 'assert'\n  | 'clear'\n  | 'count'\n  | 'countReset'\n  | 'debug'\n  | 'dir'\n  | 'dirxml'\n  | 'error'\n  | 'group'\n  | 'groupCollapsed'\n  | 'groupEnd'\n  | 'info'\n  | 'log'\n  | 'table'\n  | 'time'\n  | 'timeEnd'\n  | 'timeLog'\n  | 'trace'\n  | 'warn';\n\n/* fork from interface Console */\n// all kinds of console functions\nexport type Logger = {\n  assert?: typeof console.assert;\n  clear?: typeof console.clear;\n  count?: typeof console.count;\n  countReset?: typeof console.countReset;\n  debug?: typeof console.debug;\n  dir?: typeof console.dir;\n  dirxml?: typeof console.dirxml;\n  error?: typeof console.error;\n  group?: typeof console.group;\n  groupCollapsed?: typeof console.groupCollapsed;\n  groupEnd?: () => void;\n  info?: typeof console.info;\n  log?: typeof console.log;\n  table?: typeof console.table;\n  time?: typeof console.time;\n  timeEnd?: typeof console.timeEnd;\n  timeLog?: typeof console.timeLog;\n  trace?: typeof console.trace;\n  warn?: typeof console.warn;\n};\n\n/**\n * define an interface to replay log records\n * (data: logData) => void> function to display the log data\n */\nexport type ReplayLogger = Partial<Record<LogLevel, (data: logData) => void>>;\n\nexport type LogParam = {\n  level: LogLevel;\n  trace: string[];\n  payload: string[];\n};\n\nexport type fontCallback = (p: fontParam) => void;\n\nexport type logCallback = (p: LogParam) => void;\n\nexport type viewportResizeDimension = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimension) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport const enum MediaInteractions {\n  Play,\n  Pause,\n}\n\nexport type mediaInteractionParam = {\n  type: MediaInteractions;\n  id: number;\n};\n\nexport type mediaInteractionCallback = (p: mediaInteractionParam) => void;\n\nexport type DocumentDimension = {\n  x: number;\n  y: number;\n  // scale value relative to its parent iframe\n  relativeScale: number;\n  // scale value relative to the root iframe\n  absoluteScale: number;\n};\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n  reset: () => void;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type playerConfig = {\n  speed: number;\n  maxSpeed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: boolean;\n  showWarning: boolean;\n  showDebug: boolean;\n  blockClass: string;\n  liveMode: boolean;\n  insertStyleRules: string[];\n  triggerFocus: boolean;\n  UNSAFE_replayCanvas: boolean;\n  pauseAnimation?: boolean;\n  mouseTail:\n  | boolean\n  | {\n    duration?: number;\n    lineCap?: string;\n    lineWidth?: number;\n    strokeStyle?: string;\n  };\n  unpackFn?: UnpackFn;\n  logConfig: LogReplayConfig;\n};\n\nexport type LogReplayConfig = {\n  level?: LogLevel[] | undefined;\n  replayLogger: ReplayLogger | undefined;\n};\n\nexport type playerMetaData = {\n  startTime: number;\n  endTime: number;\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport type Handler = (event?: unknown) => void;\n\nexport type Emitter = {\n  on(type: string, handler: Handler): void;\n  emit(type: string, event?: unknown): void;\n  off(type: string, handler: Handler): void;\n};\n\nexport type Arguments<T> = T extends (...payload: infer U) => unknown\n  ? U\n  : unknown;\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n  MouseInteraction = 'mouse-interaction',\n  EventCast = 'event-cast',\n  CustomEvent = 'custom-event',\n  Flush = 'flush',\n  StateChange = 'state-change',\n  PlayBack = 'play-back',\n}\n\nexport type MaskInputFn = (text: string) => string;\n\nexport type MaskTextFn = (text: string) => string;\n\n// store the state that would be changed during the process(unmount from dom and mount again)\nexport type ElementState = {\n  // [scrollLeft,scrollTop]\n  scroll?: [number, number];\n};\n\nexport type StringifyOptions = {\n  // limit of string length\n  stringLengthLimit?: number;\n  /**\n   * limit of number of keys in an object\n   * if an object contains more keys than this limit, we would call its toString function directly\n   */\n  numOfKeysLimit: number;\n};\n\nexport type LogRecordOptions = {\n  level?: LogLevel[] | undefined;\n  lengthThreshold?: number;\n  stringifyOptions?: StringifyOptions;\n  logger?: Logger;\n};\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n  blockClass,\n  eventWithTime,\n  EventType,\n  IncrementalSource,\n  addedNodeMutation,\n  removedNodeMutation,\n  textMutation,\n  attributeMutation,\n  mutationData,\n  scrollData,\n  inputData,\n  DocumentDimension,\n} from './types';\nimport {\n  INode,\n  IGNORED_NODE,\n  serializedNodeWithId,\n  NodeType,\n  isShadowRoot,\n} from './snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | Window = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport function createMirror(): Mirror {\n  return {\n    map: {},\n    getId(n) {\n      // if n is not a serialized INode, use -1 as its id.\n      if (!n.__sn) {\n        return -1;\n      }\n      return n.__sn.id;\n    },\n    getNode(id) {\n      return this.map[id] || null;\n    },\n    // TODO: use a weakmap to get rid of manually memory management\n    removeNodeFromMap(n) {\n      const id = n.__sn && n.__sn.id;\n      delete this.map[id];\n      if (n.childNodes) {\n        n.childNodes.forEach((child) =>\n          this.removeNodeFromMap((child as Node) as INode),\n        );\n      }\n    },\n    has(id) {\n      return this.map.hasOwnProperty(id);\n    },\n    reset() {\n      this.map = {};\n    },\n  };\n}\n\n// https://github.com/rrweb-io/rrweb/pull/407\nconst DEPARTED_MIRROR_ACCESS_WARNING =\n  'Please stop import mirror directly. Instead of that,' +\n  '\\r\\n' +\n  'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\n  '\\r\\n' +\n  'or you can use record.mirror to access the mirror instance during recording.';\nexport let _mirror: Mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n};\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === 'map') {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: number | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function (arg: T) {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait - (now - previous);\n    let context = this;\n    let args = arguments as any;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        window.clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = window.setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n  isRevoked?: boolean,\n  win = window,\n): hookResetter {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked\n      ? d\n      : {\n        set(value) {\n          // put hooked setter into event loop to avoid of set latency\n          setTimeout(() => {\n            d.set!.call(this, value);\n          }, 0);\n          if (original && original.set) {\n            original.set.call(this, value);\n          }\n        },\n      },\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\n\n// copy from https://github.com/getsentry/sentry-javascript/blob/b2109071975af8bf0316d3b5b38f519bdaf5dc15/packages/utils/src/object.ts\nexport function patch(\n  // tslint:disable-next-line:no-any\n  source: { [key: string]: any },\n  name: string,\n  // tslint:disable-next-line:no-any\n  replacement: (...args: any[]) => any,\n): () => void {\n  try {\n    if (!(name in source)) {\n      return () => { };\n    }\n\n    const original = source[name] as () => unknown;\n    const wrapped = replacement(original);\n\n    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n    // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    }\n\n    source[name] = wrapped;\n\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => { };\n    // This can throw if multiple fill happens on a global object like XMLHttpRequest\n    // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n  }\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nexport function isBlocked(node: Node | null, blockClass: blockClass): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    let needBlock = false;\n    if (typeof blockClass === 'string') {\n      needBlock = (node as HTMLElement).classList.contains(blockClass);\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (blockClass.test(className)) {\n          needBlock = true;\n        }\n      });\n    }\n    return needBlock || isBlocked(node.parentNode, blockClass);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return isBlocked(node.parentNode, blockClass);\n  }\n  return isBlocked(node.parentNode, blockClass);\n}\n\nexport function isIgnored(n: Node | INode): boolean {\n  if ('__sn' in n) {\n    return (n as INode).__sn.id === IGNORED_NODE;\n  }\n  // The main part of the slimDOM check happens in\n  // rrweb-snapshot::serializeNodeWithId\n  return false;\n}\n\nexport function isAncestorRemoved(target: INode, mirror: Mirror): boolean {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode, mirror);\n}\n\nexport function isTouchEvent(\n  event: MouseEvent | TouchEvent,\n): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches);\n}\n\nexport function polyfill(win = window) {\n  if ('NodeList' in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as NodeList['forEach'];\n  }\n\n  if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as DOMTokenList['forEach'];\n  }\n\n  // https://github.com/Financial-Times/polyfill-service/pull/183\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = function contains(node) {\n      if (!(0 in arguments)) {\n        throw new TypeError('1 argument is required');\n      }\n\n      do {\n        if (this === node) {\n          return true;\n        }\n        // tslint:disable-next-line: no-conditional-assignment\n      } while ((node = node && node.parentNode));\n\n      return false;\n    };\n  }\n}\n\nexport function needCastInSyncMode(event: eventWithTime): boolean {\n  switch (event.type) {\n    case EventType.DomContentLoaded:\n    case EventType.Load:\n    case EventType.Custom:\n      return false;\n    case EventType.FullSnapshot:\n    case EventType.Meta:\n      return true;\n    default:\n      break;\n  }\n\n  switch (event.data.source) {\n    case IncrementalSource.MouseMove:\n    case IncrementalSource.MouseInteraction:\n    case IncrementalSource.TouchMove:\n    case IncrementalSource.MediaInteraction:\n      return false;\n    case IncrementalSource.ViewportResize:\n    case IncrementalSource.StyleSheetRule:\n    case IncrementalSource.Scroll:\n    case IncrementalSource.Input:\n      return true;\n    default:\n      break;\n  }\n\n  return true;\n}\n\nexport type TreeNode = {\n  id: number;\n  mutation: addedNodeMutation;\n  parent?: TreeNode;\n  children: Record<number, TreeNode>;\n  texts: textMutation[];\n  attributes: attributeMutation[];\n};\nexport class TreeIndex {\n  public tree!: Record<number, TreeNode>;\n\n  private removeNodeMutations!: removedNodeMutation[];\n  private textMutations!: textMutation[];\n  private attributeMutations!: attributeMutation[];\n  private indexes!: Map<number, TreeNode>;\n  private removeIdSet!: Set<number>;\n  private scrollMap!: Map<number, scrollData>;\n  private inputMap!: Map<number, inputData>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public add(mutation: addedNodeMutation) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode: TreeNode = {\n      id: mutation.node.id,\n      mutation,\n      children: [],\n      texts: [],\n      attributes: [],\n    };\n    if (!parentTreeNode) {\n      this.tree[treeNode.id] = treeNode;\n    } else {\n      treeNode.parent = parentTreeNode;\n      parentTreeNode.children[treeNode.id] = treeNode;\n    }\n    this.indexes.set(treeNode.id, treeNode);\n  }\n\n  public remove(mutation: removedNodeMutation, mirror: Mirror) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode = this.indexes.get(mutation.id);\n\n    const deepRemoveFromMirror = (id: number) => {\n      this.removeIdSet.add(id);\n      const node = mirror.getNode(id);\n      node?.childNodes.forEach((childNode) => {\n        if ('__sn' in childNode) {\n          deepRemoveFromMirror(((childNode as unknown) as INode).__sn.id);\n        }\n      });\n    };\n    const deepRemoveFromTreeIndex = (node: TreeNode) => {\n      this.removeIdSet.add(node.id);\n      Object.values(node.children).forEach((n) => deepRemoveFromTreeIndex(n));\n      const _treeNode = this.indexes.get(node.id);\n      if (_treeNode) {\n        const _parentTreeNode = _treeNode.parent;\n        if (_parentTreeNode) {\n          delete _treeNode.parent;\n          delete _parentTreeNode.children[_treeNode.id];\n          this.indexes.delete(mutation.id);\n        }\n      }\n    };\n\n    if (!treeNode) {\n      this.removeNodeMutations.push(mutation);\n      deepRemoveFromMirror(mutation.id);\n    } else if (!parentTreeNode) {\n      delete this.tree[treeNode.id];\n      this.indexes.delete(treeNode.id);\n      deepRemoveFromTreeIndex(treeNode);\n    } else {\n      delete treeNode.parent;\n      delete parentTreeNode.children[treeNode.id];\n      this.indexes.delete(mutation.id);\n      deepRemoveFromTreeIndex(treeNode);\n    }\n  }\n\n  public text(mutation: textMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.texts.push(mutation);\n    } else {\n      this.textMutations.push(mutation);\n    }\n  }\n\n  public attribute(mutation: attributeMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.attributes.push(mutation);\n    } else {\n      this.attributeMutations.push(mutation);\n    }\n  }\n\n  public scroll(d: scrollData) {\n    this.scrollMap.set(d.id, d);\n  }\n\n  public input(d: inputData) {\n    this.inputMap.set(d.id, d);\n  }\n\n  public flush(): {\n    mutationData: mutationData;\n    scrollMap: TreeIndex['scrollMap'];\n    inputMap: TreeIndex['inputMap'];\n  } {\n    const {\n      tree,\n      removeNodeMutations,\n      textMutations,\n      attributeMutations,\n    } = this;\n\n    const batchMutationData: mutationData = {\n      source: IncrementalSource.Mutation,\n      removes: removeNodeMutations,\n      texts: textMutations,\n      attributes: attributeMutations,\n      adds: [],\n    };\n\n    const walk = (treeNode: TreeNode, removed: boolean) => {\n      if (removed) {\n        this.removeIdSet.add(treeNode.id);\n      }\n      batchMutationData.texts = batchMutationData.texts\n        .concat(removed ? [] : treeNode.texts)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      batchMutationData.attributes = batchMutationData.attributes\n        .concat(removed ? [] : treeNode.attributes)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      if (\n        !this.removeIdSet.has(treeNode.id) &&\n        !this.removeIdSet.has(treeNode.mutation.parentId) &&\n        !removed\n      ) {\n        batchMutationData.adds.push(treeNode.mutation);\n        if (treeNode.children) {\n          Object.values(treeNode.children).forEach((n) => walk(n, false));\n        }\n      } else {\n        Object.values(treeNode.children).forEach((n) => walk(n, true));\n      }\n    };\n\n    Object.values(tree).forEach((n) => walk(n, false));\n\n    for (const id of this.scrollMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.scrollMap.delete(id);\n      }\n    }\n    for (const id of this.inputMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.inputMap.delete(id);\n      }\n    }\n\n    const scrollMap = new Map(this.scrollMap);\n    const inputMap = new Map(this.inputMap);\n\n    this.reset();\n\n    return {\n      mutationData: batchMutationData,\n      scrollMap,\n      inputMap,\n    };\n  }\n\n  private reset() {\n    this.tree = [];\n    this.indexes = new Map();\n    this.removeNodeMutations = [];\n    this.textMutations = [];\n    this.attributeMutations = [];\n    this.removeIdSet = new Set();\n    this.scrollMap = new Map();\n    this.inputMap = new Map();\n  }\n}\n\ntype ResolveTree = {\n  value: addedNodeMutation;\n  children: ResolveTree[];\n  parent: ResolveTree | null;\n};\n\nexport function queueToResolveTrees(queue: addedNodeMutation[]): ResolveTree[] {\n  const queueNodeMap: Record<number, ResolveTree> = {};\n  const putIntoMap = (\n    m: addedNodeMutation,\n    parent: ResolveTree | null,\n  ): ResolveTree => {\n    const nodeInTree: ResolveTree = {\n      value: m,\n      parent,\n      children: [],\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n\n  const queueNodeTrees: ResolveTree[] = [];\n  for (const mutation of queue) {\n    const { nextId, parentId } = mutation;\n    if (nextId && nextId in queueNodeMap) {\n      const nextInTree = queueNodeMap[nextId];\n      if (nextInTree.parent) {\n        const idx = nextInTree.parent.children.indexOf(nextInTree);\n        nextInTree.parent.children.splice(\n          idx,\n          0,\n          putIntoMap(mutation, nextInTree.parent),\n        );\n      } else {\n        const idx = queueNodeTrees.indexOf(nextInTree);\n        queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n      }\n      continue;\n    }\n    if (parentId in queueNodeMap) {\n      const parentInTree = queueNodeMap[parentId];\n      parentInTree.children.push(putIntoMap(mutation, parentInTree));\n      continue;\n    }\n    queueNodeTrees.push(putIntoMap(mutation, null));\n  }\n\n  return queueNodeTrees;\n}\n\nexport function iterateResolveTree(\n  tree: ResolveTree,\n  cb: (mutation: addedNodeMutation) => unknown,\n) {\n  cb(tree.value);\n  /**\n   * The resolve tree was designed to reflect the DOM layout,\n   * but we need append next sibling first, so we do a reverse\n   * loop here.\n   */\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    iterateResolveTree(tree.children[i], cb);\n  }\n}\n\ntype HTMLIFrameINode = HTMLIFrameElement & {\n  __sn: serializedNodeWithId;\n};\nexport type AppendedIframe = {\n  mutationInQueue: addedNodeMutation;\n  builtNode: HTMLIFrameINode;\n};\n\nexport function isIframeINode(\n  node: INode | ShadowRoot,\n): node is HTMLIFrameINode {\n  if ('__sn' in node) {\n    return (\n      node.__sn.type === NodeType.Element && node.__sn.tagName === 'iframe'\n    );\n  }\n  // node can be document fragment when using the virtual parent feature\n  return false;\n}\n\nexport function getBaseDimension(\n  node: Node,\n  rootIframe: Node,\n): DocumentDimension {\n  const frameElement = node.ownerDocument?.defaultView?.frameElement;\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1,\n    };\n  }\n\n  const frameDimension = frameElement.getBoundingClientRect();\n  const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  // the iframe element may have a scale transform\n  const relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x:\n      frameDimension.x * frameBaseDimension.relativeScale +\n      frameBaseDimension.x,\n    y:\n      frameDimension.y * frameBaseDimension.relativeScale +\n      frameBaseDimension.y,\n    relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale,\n  };\n}\n\nexport function hasShadowRoot<T extends Node>(\n  n: T,\n): n is T & { shadowRoot: ShadowRoot } {\n  return Boolean(((n as unknown) as Element)?.shadowRoot);\n}\n","// @ts-nocheck\nimport {\n  INode,\n  serializeNodeWithId,\n  transformAttribute,\n  MaskInputOptions,\n  SlimDOMOptions,\n  IGNORED_NODE,\n  isShadowRoot,\n  needMaskingText,\n} from '../snapshot';\nimport {\n  mutationRecord,\n  blockClass,\n  maskTextClass,\n  mutationCallBack,\n  textCursor,\n  attributeCursor,\n  removedNodeMutation,\n  addedNodeMutation,\n  MaskTextFn,\n  Mirror,\n} from '../types';\nimport {\n  isBlocked,\n  isAncestorRemoved,\n  isIgnored,\n  isIframeINode,\n  hasShadowRoot,\n} from '../utils';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\n\ntype DoubleLinkedListNode = {\n  previous: DoubleLinkedListNode | null;\n  next: DoubleLinkedListNode | null;\n  value: NodeInLinkedList;\n};\ntype NodeInLinkedList = Node & {\n  __ln: DoubleLinkedListNode;\n};\n\nfunction isNodeInLinkedList(n: Node | NodeInLinkedList): n is NodeInLinkedList {\n  return '__ln' in n;\n}\nclass DoubleLinkedList {\n  public length = 0;\n  public head: DoubleLinkedListNode | null = null;\n\n  public get(position: number) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n\n  public addNode(n: Node) {\n    const node: DoubleLinkedListNode = {\n      value: n as NodeInLinkedList,\n      previous: null,\n      next: null,\n    };\n    (n as NodeInLinkedList).__ln = node;\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      const current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (\n      n.nextSibling &&\n      isNodeInLinkedList(n.nextSibling) &&\n      n.nextSibling.__ln.previous\n    ) {\n      const current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    this.length++;\n  }\n\n  public removeNode(n: NodeInLinkedList) {\n    const current = n.__ln;\n    if (!this.head) {\n      return;\n    }\n\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      }\n    }\n    if (n.__ln) {\n      delete n.__ln;\n    }\n    this.length--;\n  }\n}\n\nconst moveKey = (id: number, parentId: number) => `${id}@${parentId}`;\nfunction isINode(n: Node | INode): n is INode {\n  return '__sn' in n;\n}\n\n/**\n * controls behaviour of a MutationObserver\n */\nexport default class MutationBuffer {\n  private frozen: boolean = false;\n  private locked: boolean = false;\n\n  private texts: textCursor[] = [];\n  private attributes: attributeCursor[] = [];\n  private removes: removedNodeMutation[] = [];\n  private mapRemoves: Node[] = [];\n\n  private movedMap: Record<string, true> = {};\n\n  /**\n   * the browser MutationObserver emits multiple mutations after\n   * a delay for performance reasons, making tracing added nodes hard\n   * in our `processMutations` callback function.\n   * For example, if we append an element el_1 into body, and then append\n   * another element el_2 into el_1, these two mutations may be passed to the\n   * callback function together when the two operations were done.\n   * Generally we need to trace child nodes of newly added nodes, but in this\n   * case if we count el_2 as el_1's child node in the first mutation record,\n   * then we will count el_2 again in the second mutation record which was\n   * duplicated.\n   * To avoid of duplicate counting added nodes, we use a Set to store\n   * added nodes and its child nodes during iterate mutation records. Then\n   * collect added nodes from the Set which have no duplicate copy. But\n   * this also causes newly added nodes will not be serialized with id ASAP,\n   * which means all the id related calculation should be lazy too.\n   */\n  private addedSet = new Set<Node>();\n  private movedSet = new Set<Node>();\n  private droppedSet = new Set<Node>();\n\n  private emissionCallback: mutationCallBack;\n  private blockClass: blockClass;\n  private blockSelector: string | null;\n  private maskTextClass: maskTextClass;\n  private maskTextSelector: string | null;\n  private inlineStylesheet: boolean;\n  private maskInputOptions: MaskInputOptions;\n  private maskTextFn: MaskTextFn | undefined;\n  private recordCanvas: boolean;\n  private slimDOMOptions: SlimDOMOptions;\n  private doc: Document;\n\n  private mirror: Mirror;\n  private iframeManager: IframeManager;\n  private shadowDomManager: ShadowDomManager;\n\n  public init(\n    cb: mutationCallBack,\n    blockClass: blockClass,\n    blockSelector: string | null,\n    maskTextClass: maskTextClass,\n    maskTextSelector: string | null,\n    inlineStylesheet: boolean,\n    maskInputOptions: MaskInputOptions,\n    maskTextFn: MaskTextFn | undefined,\n    recordCanvas: boolean,\n    slimDOMOptions: SlimDOMOptions,\n    doc: Document,\n    mirror: Mirror,\n    iframeManager: IframeManager,\n    shadowDomManager: ShadowDomManager,\n  ) {\n    this.blockClass = blockClass;\n    this.blockSelector = blockSelector;\n    this.maskTextClass = maskTextClass;\n    this.maskTextSelector = maskTextSelector;\n    this.inlineStylesheet = inlineStylesheet;\n    this.maskInputOptions = maskInputOptions;\n    this.maskTextFn = maskTextFn;\n    this.recordCanvas = recordCanvas;\n    this.slimDOMOptions = slimDOMOptions;\n    this.emissionCallback = cb;\n    this.doc = doc;\n    this.mirror = mirror;\n    this.iframeManager = iframeManager;\n    this.shadowDomManager = shadowDomManager;\n  }\n\n  public freeze() {\n    this.frozen = true;\n  }\n\n  public unfreeze() {\n    this.frozen = false;\n    this.emit();\n  }\n\n  public isFrozen() {\n    return this.frozen;\n  }\n\n  public lock() {\n    this.locked = true;\n  }\n\n  public unlock() {\n    this.locked = false;\n    this.emit();\n  }\n\n  public processMutations = (mutations: mutationRecord[]) => {\n    mutations.forEach(this.processMutation);\n    this.emit();\n  };\n\n  public emit = () => {\n    if (this.frozen || this.locked) {\n      return;\n    }\n\n    // delay any modification of the mirror until this function\n    // so that the mirror for takeFullSnapshot doesn't get mutated while it's event is being processed\n\n    const adds: addedNodeMutation[] = [];\n\n    /**\n     * Sometimes child node may be pushed before its newly added\n     * parent, so we init a queue to store these nodes.\n     */\n    const addList = new DoubleLinkedList();\n    const getNextId = (n: Node): number | null => {\n      let ns: Node | null = n;\n      let nextId: number | null = IGNORED_NODE; // slimDOM: ignored\n      while (nextId === IGNORED_NODE) {\n        ns = ns && ns.nextSibling;\n        nextId = ns && this.mirror.getId((ns as unknown) as INode);\n      }\n      if (nextId === -1 && isBlocked(n.nextSibling, this.blockClass)) {\n        nextId = null;\n      }\n      return nextId;\n    };\n    const pushAdd = (n: Node) => {\n      const shadowHost: Element | null = n.getRootNode\n        ? (n.getRootNode() as ShadowRoot)?.host\n        : null;\n      const notInDoc = !this.doc.contains(n) && !this.doc.contains(shadowHost);\n      if (!n.parentNode || notInDoc) {\n        return;\n      }\n      const parentId = isShadowRoot(n.parentNode)\n        ? this.mirror.getId((shadowHost as unknown) as INode)\n        : this.mirror.getId((n.parentNode as Node) as INode);\n      const nextId = getNextId(n);\n      if (parentId === -1 || nextId === -1) {\n        return addList.addNode(n);\n      }\n      let sn = serializeNodeWithId(n, {\n        doc: this.doc,\n        map: this.mirror.map,\n        blockClass: this.blockClass,\n        blockSelector: this.blockSelector,\n        maskTextClass: this.maskTextClass,\n        maskTextSelector: this.maskTextSelector,\n        skipChild: true,\n        inlineStylesheet: this.inlineStylesheet,\n        maskInputOptions: this.maskInputOptions,\n        maskTextFn: this.maskTextFn,\n        slimDOMOptions: this.slimDOMOptions,\n        recordCanvas: this.recordCanvas,\n        onSerialize: (currentN) => {\n          if (isIframeINode(currentN)) {\n            this.iframeManager.addIframe(currentN);\n          }\n          if (hasShadowRoot(n)) {\n            this.shadowDomManager.addShadowRoot(n.shadowRoot, document);\n          }\n        },\n        onIframeLoad: (iframe, childSn) => {\n          this.iframeManager.attachIframe(iframe, childSn);\n        },\n      });\n      if (sn) {\n        adds.push({\n          parentId,\n          nextId,\n          node: sn,\n        });\n      }\n    };\n\n    while (this.mapRemoves.length) {\n      this.mirror.removeNodeFromMap(this.mapRemoves.shift() as INode);\n    }\n\n    for (const n of this.movedSet) {\n      if (\n        isParentRemoved(this.removes, n, this.mirror) &&\n        !this.movedSet.has(n.parentNode!)\n      ) {\n        continue;\n      }\n      pushAdd(n);\n    }\n\n    for (const n of this.addedSet) {\n      if (\n        !isAncestorInSet(this.droppedSet, n) &&\n        !isParentRemoved(this.removes, n, this.mirror)\n      ) {\n        pushAdd(n);\n      } else if (isAncestorInSet(this.movedSet, n)) {\n        pushAdd(n);\n      } else {\n        this.droppedSet.add(n);\n      }\n    }\n\n    let candidate: DoubleLinkedListNode | null = null;\n    while (addList.length) {\n      let node: DoubleLinkedListNode | null = null;\n      if (candidate) {\n        const parentId = this.mirror.getId(\n          (candidate.value.parentNode as Node) as INode,\n        );\n        const nextId = getNextId(candidate.value);\n        if (parentId !== -1 && nextId !== -1) {\n          node = candidate;\n        }\n      }\n      if (!node) {\n        for (let index = addList.length - 1; index >= 0; index--) {\n          const _node = addList.get(index)!;\n          const parentId = this.mirror.getId(\n            (_node.value.parentNode as Node) as INode,\n          );\n          const nextId = getNextId(_node.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = _node;\n            break;\n          }\n        }\n      }\n      if (!node) {\n        /**\n         * If all nodes in queue could not find a serialized parent,\n         * it may be a bug or corner case. We need to escape the\n         * dead while loop at once.\n         */\n        while (addList.head) {\n          addList.removeNode(addList.head.value);\n        }\n        break;\n      }\n      candidate = node.previous;\n      addList.removeNode(node.value);\n      pushAdd(node.value);\n    }\n\n    const payload = {\n      texts: this.texts\n        .map((text) => ({\n          id: this.mirror.getId(text.node as INode),\n          value: text.value,\n        }))\n        // text mutation's id was not in the mirror map means the target node has been removed\n        .filter((text) => this.mirror.has(text.id)),\n      attributes: this.attributes\n        .map((attribute) => ({\n          id: this.mirror.getId(attribute.node as INode),\n          attributes: attribute.attributes,\n        }))\n        // attribute mutation's id was not in the mirror map means the target node has been removed\n        .filter((attribute) => this.mirror.has(attribute.id)),\n      removes: this.removes,\n      adds,\n    };\n    // payload may be empty if the mutations happened in some blocked elements\n    if (\n      !payload.texts.length &&\n      !payload.attributes.length &&\n      !payload.removes.length &&\n      !payload.adds.length\n    ) {\n      return;\n    }\n\n    // reset\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.addedSet = new Set<Node>();\n    this.movedSet = new Set<Node>();\n    this.droppedSet = new Set<Node>();\n    this.movedMap = {};\n\n    this.emissionCallback(payload);\n  };\n\n  private processMutation = (m: mutationRecord) => {\n    // console.log({ m });\n    if (isIgnored(m.target)) {\n      return;\n    }\n    switch (m.type) {\n      case 'characterData': {\n        const value = m.target.textContent;\n        if (!isBlocked(m.target, this.blockClass) && value !== m.oldValue) {\n          this.texts.push({\n            value:\n              needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n              ) && value\n                ? this.maskTextFn\n                  ? this.maskTextFn(value)\n                  : value.replace(/[\\S]/g, '*')\n                : value,\n            node: m.target,\n          });\n        }\n        break;\n      }\n      case 'attributes': {\n        const value = (m.target as HTMLElement).getAttribute(m.attributeName!);\n        if (isBlocked(m.target, this.blockClass) || value === m.oldValue) {\n          return;\n        }\n        let item: attributeCursor | undefined = this.attributes.find(\n          (a) => a.node === m.target,\n        );\n        if (!item) {\n          item = {\n            node: m.target,\n            attributes: {},\n          };\n          this.attributes.push(item);\n        }\n        // overwrite attribute if the mutations was triggered in same time\n        item.attributes[m.attributeName!] = transformAttribute(\n          this.doc,\n          (m.target as HTMLElement).tagName,\n          m.attributeName!,\n          value!,\n        );\n        break;\n      }\n      case 'childList': {\n        m.addedNodes.forEach((n) => this.genAdds(n, m.target));\n        m.removedNodes.forEach((n) => {\n          const nodeId = this.mirror.getId(n as INode);\n          const parentId = isShadowRoot(m.target)\n            ? this.mirror.getId((m.target.host as unknown) as INode)\n            : this.mirror.getId(m.target as INode);\n          if (\n            isBlocked(n, this.blockClass) ||\n            isBlocked(m.target, this.blockClass) ||\n            isIgnored(n)\n          ) {\n            return;\n          }\n          // removed node has not been serialized yet, just remove it from the Set\n          if (this.addedSet.has(n)) {\n            deepDelete(this.addedSet, n);\n            this.droppedSet.add(n);\n          } else if (this.addedSet.has(m.target) && nodeId === -1) {\n            /**\n             * If target was newly added and removed child node was\n             * not serialized, it means the child node has been removed\n             * before callback fired, so we can ignore it because\n             * newly added node will be serialized without child nodes.\n             * TODO: verify this\n             */\n          } else if (isAncestorRemoved(m.target as INode, this.mirror)) {\n            /**\n             * If parent id was not in the mirror map any more, it\n             * means the parent node has already been removed. So\n             * the node is also removed which we do not need to track\n             * and replay.\n             */\n          } else if (\n            this.movedSet.has(n) &&\n            this.movedMap[moveKey(nodeId, parentId)]\n          ) {\n            deepDelete(this.movedSet, n);\n          } else {\n            this.removes.push({\n              parentId,\n              id: nodeId,\n              isShadow: isShadowRoot(m.target) ? true : undefined,\n            });\n          }\n          this.mapRemoves.push(n);\n        });\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  private genAdds = (n: Node | INode, target?: Node | INode) => {\n    if (isBlocked(n, this.blockClass)) {\n      return;\n    }\n    if (target && isBlocked(target, this.blockClass)) {\n      return;\n    }\n    if (isINode(n)) {\n      if (isIgnored(n)) {\n        return;\n      }\n      this.movedSet.add(n);\n      let targetId: number | null = null;\n      if (target && isINode(target)) {\n        targetId = target.__sn.id;\n      }\n      if (targetId) {\n        this.movedMap[moveKey(n.__sn.id, targetId)] = true;\n      }\n    } else {\n      this.addedSet.add(n);\n      this.droppedSet.delete(n);\n    }\n    n.childNodes.forEach((childN) => this.genAdds(childN));\n  };\n}\n\n/**\n * Some utils to handle the mutation observer DOM records.\n * It should be more clear to extend the native data structure\n * like Set and Map, but currently Typescript does not support\n * that.\n */\nfunction deepDelete(addsSet: Set<Node>, n: Node) {\n  addsSet.delete(n);\n  n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\n\nfunction isParentRemoved(\n  removes: removedNodeMutation[],\n  n: Node,\n  mirror: Mirror,\n): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId((parentNode as Node) as INode);\n  if (removes.some((r) => r.id === parentId)) {\n    return true;\n  }\n  return isParentRemoved(removes, parentNode, mirror);\n}\n\nfunction isAncestorInSet(set: Set<Node>, n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return isAncestorInSet(set, parentNode);\n}\n","// tslint:disable:no-any no-bitwise forin\n/**\n * this file is used to serialize log message to string\n *\n */\n\nimport { StringifyOptions } from '../types';\n\n/**\n * transfer the node path in Event to string\n * @param node the first node in a node path array\n */\nfunction pathToSelector(node: HTMLElement): string | '' {\n  if (!node || !node.outerHTML) {\n    return '';\n  }\n\n  let path = '';\n  while (node.parentElement) {\n    let name = node.localName;\n    if (!name) {\n      break;\n    }\n    name = name.toLowerCase();\n    let parent = node.parentElement;\n\n    let domSiblings = [];\n\n    if (parent.children && parent.children.length > 0) {\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < parent.children.length; i++) {\n        let sibling = parent.children[i];\n        if (sibling.localName && sibling.localName.toLowerCase) {\n          if (sibling.localName.toLowerCase() === name) {\n            domSiblings.push(sibling);\n          }\n        }\n      }\n    }\n\n    if (domSiblings.length > 1) {\n      name += ':eq(' + domSiblings.indexOf(node) + ')';\n    }\n    path = name + (path ? '>' + path : '');\n    node = parent;\n  }\n\n  return path;\n}\n\n/**\n * stringify any js object\n * @param obj the object to stringify\n */\nexport function stringify(\n  obj: any,\n  stringifyOptions?: StringifyOptions,\n): string {\n  const options: StringifyOptions = {\n    numOfKeysLimit: 50,\n  };\n  Object.assign(options, stringifyOptions);\n  const stack: any[] = [];\n  const keys: any[] = [];\n  return JSON.stringify(obj, function (key, value) {\n    /**\n     * forked from https://github.com/moll/json-stringify-safe/blob/master/stringify.js\n     * to deCycle the object\n     */\n    if (stack.length > 0) {\n      const thisPos = stack.indexOf(this);\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n      if (~stack.indexOf(value)) {\n        if (stack[0] === value) {\n          value = '[Circular ~]';\n        } else {\n          value =\n            '[Circular ~.' +\n            keys.slice(0, stack.indexOf(value)).join('.') +\n            ']';\n        }\n      }\n    } else {\n      stack.push(value);\n    }\n    /* END of the FORK */\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n    if (shouldToString(value)) {\n      return toString(value);\n    }\n    if (value instanceof Event) {\n      const eventResult: any = {};\n      for (const eventKey in value) {\n        const eventValue = (value as any)[eventKey];\n        if (Array.isArray(eventValue)) {\n          eventResult[eventKey] = pathToSelector(\n            eventValue.length ? eventValue[0] : null,\n          );\n        } else {\n          eventResult[eventKey] = eventValue;\n        }\n      }\n      return eventResult;\n    } else if (value instanceof Node) {\n      if (value instanceof HTMLElement) {\n        return value ? value.outerHTML : '';\n      }\n      return value.nodeName;\n    }\n    return value;\n  });\n\n  /**\n   * whether we should call toString function of this object\n   */\n  function shouldToString(_obj: object): boolean {\n    if (\n      typeof _obj === 'object' &&\n      Object.keys(_obj).length > options.numOfKeysLimit\n    ) {\n      return true;\n    }\n    if (typeof _obj === 'function') {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * limit the toString() result according to option\n   */\n  function toString(_obj: object): string {\n    let str = _obj.toString();\n    if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n      str = `${str.slice(0, options.stringLengthLimit)}...`;\n    }\n    return str;\n  }\n}\n","/**\n * Class StackFrame is a fork of https://github.com/stacktracejs/stackframe/blob/master/stackframe.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n * 3. StackFrame contains some functions we don't need.\n */\nexport class StackFrame {\n  private fileName: string;\n  private functionName: string;\n  private lineNumber?: number;\n  private columnNumber?: number;\n\n  constructor(obj: {\n    fileName?: string;\n    functionName?: string;\n    lineNumber?: number;\n    columnNumber?: number;\n  }) {\n    this.fileName = obj.fileName || '';\n    this.functionName = obj.functionName || '';\n    this.lineNumber = obj.lineNumber;\n    this.columnNumber = obj.columnNumber;\n  }\n\n  toString() {\n    const lineNumber = this.lineNumber || '';\n    const columnNumber = this.columnNumber || '';\n    if (this.functionName) {\n      return (\n        this.functionName +\n        ' (' +\n        this.fileName +\n        ':' +\n        lineNumber +\n        ':' +\n        columnNumber +\n        ')'\n      );\n    }\n    return this.fileName + ':' + lineNumber + ':' + columnNumber;\n  }\n}\n\n/**\n * ErrorStackParser is a fork of https://github.com/stacktracejs/error-stack-parser/blob/master/error-stack-parser.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n */\nconst FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nexport const ErrorStackParser = {\n  /**\n   * Given an Error object, extract the most information from it.\n   *\n   * @param {Error} error object\n   * @return {Array} of StackFrames\n   */\n  parse: function (error: Error): StackFrame[] {\n    if (\n      // @ts-ignore\n      typeof error.stacktrace !== 'undefined' ||\n      // @ts-ignore\n      typeof error['opera#sourceloc'] !== 'undefined'\n    ) {\n      return this.parseOpera(\n        error as {\n          stacktrace?: string;\n          message: string;\n          stack?: string;\n        },\n      );\n    } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n      return this.parseV8OrIE(error as { stack: string });\n    } else if (error.stack) {\n      return this.parseFFOrSafari(error as { stack: string });\n    } else {\n      throw new Error('Cannot parse given Error object');\n    }\n  },\n  // Separate line and column numbers from a string of the form: (URI:Line:Column)\n  extractLocation: function (urlLike: string) {\n    // Fail-fast but return locations like \"(native)\"\n    if (urlLike.indexOf(':') === -1) {\n      return [urlLike];\n    }\n\n    const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n    const parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n    if (!parts) throw new Error(`Cannot parse given url: ${urlLike}`);\n    return [parts[1], parts[2] || undefined, parts[3] || undefined];\n  },\n  parseV8OrIE: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !!line.match(CHROME_IE_STACK_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      if (line.indexOf('(eval ') > -1) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        line = line\n          .replace(/eval code/g, 'eval')\n          .replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n      }\n      let sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n      // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n      // case it has spaces in it, as the string is split on \\s+ later on\n      const location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n      // remove the parenthesized location from the line, if it was matched\n      sanitizedLine = location\n        ? sanitizedLine.replace(location[0], '')\n        : sanitizedLine;\n\n      const tokens = sanitizedLine.split(/\\s+/).slice(1);\n      // if a location was matched, pass it to extractLocation() otherwise pop the last token\n      const locationParts = this.extractLocation(\n        location ? location[1] : tokens.pop(),\n      );\n      const functionName = tokens.join(' ') || undefined;\n      const fileName =\n        ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1\n          ? undefined\n          : locationParts[0];\n\n      return new StackFrame({\n        functionName,\n        fileName,\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n  parseFFOrSafari: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      // Throw away eval information until we implement stacktrace.js/stackframe#8\n      if (line.indexOf(' > eval') > -1) {\n        line = line.replace(\n          / line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,\n          ':$1',\n        );\n      }\n\n      if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n        // Safari eval frames only have function names and nothing else\n        return new StackFrame({\n          functionName: line,\n        });\n      } else {\n        const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n        const matches = line.match(functionNameRegex);\n        const functionName = matches && matches[1] ? matches[1] : undefined;\n        const locationParts = this.extractLocation(\n          line.replace(functionNameRegex, ''),\n        );\n\n        return new StackFrame({\n          functionName,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n        });\n      }\n    }, this);\n  },\n  parseOpera: function (e: {\n    stacktrace?: string;\n    message: string;\n    stack?: string;\n  }): StackFrame[] {\n    if (\n      !e.stacktrace ||\n      (e.message.indexOf('\\n') > -1 &&\n        e.message.split('\\n').length > e.stacktrace.split('\\n').length)\n    ) {\n      return this.parseOpera9(e as { message: string });\n    } else if (!e.stack) {\n      return this.parseOpera10(e as { stacktrace: string });\n    } else {\n      return this.parseOpera11(e as { stack: string });\n    }\n  },\n  parseOpera9: function (e: { message: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n    const lines = e.message.split('\\n');\n    const result = [];\n\n    for (let i = 2, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  parseOpera10: function (e: { stacktrace: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n    const lines = e.stacktrace.split('\\n');\n    const result = [];\n\n    for (let i = 0, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  // Opera 10.65+ Error.stack very similar to FF/Safari\n  parseOpera11: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return (\n        !!line.match(FIREFOX_SAFARI_STACK_REGEXP) &&\n        !line.match(/^Error created at/)\n      );\n    }, this);\n\n    return filtered.map(function (line: string) {\n      const tokens = line.split('@');\n      const locationParts = this.extractLocation(tokens.pop());\n      const functionCall = tokens.shift() || '';\n      const functionName =\n        functionCall\n          .replace(/<anonymous function(: (\\w+))?>/, '$2')\n          .replace(/\\([^)]*\\)/g, '') || undefined;\n      return new StackFrame({\n        functionName,\n        fileName: locationParts[0],\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n};\n","// @ts-nocheck\nimport { INode, MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { FontFaceDescriptors, FontFaceSet } from 'css-font-loading-module';\nimport {\n  throttle,\n  on,\n  hookSetter,\n  getWindowHeight,\n  getWindowWidth,\n  isBlocked,\n  isTouchEvent,\n  patch,\n} from '../utils';\nimport {\n  mutationCallBack,\n  observerParam,\n  mousemoveCallBack,\n  mousePosition,\n  mouseInteractionCallBack,\n  MouseInteractions,\n  listenerHandler,\n  scrollCallback,\n  styleSheetRuleCallback,\n  viewportResizeCallback,\n  inputValue,\n  inputCallback,\n  hookResetter,\n  blockClass,\n  maskTextClass,\n  IncrementalSource,\n  hooksParam,\n  Arguments,\n  mediaInteractionCallback,\n  MediaInteractions,\n  SamplingStrategy,\n  canvasMutationCallback,\n  fontCallback,\n  fontParam,\n  MaskInputFn,\n  MaskTextFn,\n  logCallback,\n  LogRecordOptions,\n  Logger,\n  LogLevel,\n  Mirror,\n} from '../types';\nimport MutationBuffer from './mutation';\nimport { stringify } from './stringify';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\nimport { StackFrame, ErrorStackParser } from './error-stack-parser';\n\ntype WindowWithStoredMutationObserver = Window & {\n  __rrMutationObserver?: MutationObserver;\n};\ntype WindowWithAngularZone = Window & {\n  Zone?: {\n    __symbol__?: (key: string) => string;\n  };\n};\n\nexport const mutationBuffers: MutationBuffer[] = [];\n\nexport function initMutationObserver(\n  cb: mutationCallBack,\n  doc: Document,\n  blockClass: blockClass,\n  blockSelector: string | null,\n  maskTextClass: maskTextClass,\n  maskTextSelector: string | null,\n  inlineStylesheet: boolean,\n  maskInputOptions: MaskInputOptions,\n  maskTextFn: MaskTextFn | undefined,\n  recordCanvas: boolean,\n  slimDOMOptions: SlimDOMOptions,\n  mirror: Mirror,\n  iframeManager: IframeManager,\n  shadowDomManager: ShadowDomManager,\n  rootEl: Node,\n): MutationObserver {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  // see mutation.ts for details\n  mutationBuffer.init(\n    cb,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    recordCanvas,\n    slimDOMOptions,\n    doc,\n    mirror,\n    iframeManager,\n    shadowDomManager,\n  );\n  let mutationObserverCtor =\n    window.MutationObserver ||\n    /**\n     * Some websites may disable MutationObserver by removing it from the window object.\n     * If someone is using rrweb to build a browser extention or things like it, they\n     * could not change the website's code but can have an opportunity to inject some\n     * code before the website executing its JS logic.\n     * Then they can do this to store the native MutationObserver:\n     * window.__rrMutationObserver = MutationObserver\n     */\n    (window as WindowWithStoredMutationObserver).__rrMutationObserver;\n  const angularZoneSymbol = (window as WindowWithAngularZone)?.Zone?.__symbol__?.(\n    'MutationObserver',\n  );\n  if (\n    angularZoneSymbol &&\n    ((window as unknown) as Record<string, typeof MutationObserver>)[\n    angularZoneSymbol\n    ]\n  ) {\n    mutationObserverCtor = ((window as unknown) as Record<\n      string,\n      typeof MutationObserver\n    >)[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    mutationBuffer.processMutations.bind(mutationBuffer),\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  return observer;\n}\n\nfunction initMoveObserver(\n  cb: mousemoveCallBack,\n  sampling: SamplingStrategy,\n  doc: Document,\n  mirror: Mirror,\n): listenerHandler {\n  if (sampling.mousemove === false) {\n    return () => { };\n  }\n\n  const threshold =\n    typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\n  const callbackThreshold =\n    typeof sampling.mousemoveCallback === 'number'\n      ? sampling.mousemoveCallback\n      : 500;\n\n  let positions: mousePosition[] = [];\n  let timeBaseline: number | null;\n  const wrappedCb = throttle(\n    (\n      source:\n        | IncrementalSource.MouseMove\n        | IncrementalSource.TouchMove\n        | IncrementalSource.Drag,\n    ) => {\n      const totalOffset = Date.now() - timeBaseline!;\n      cb(\n        positions.map((p) => {\n          p.timeOffset -= totalOffset;\n          return p;\n        }),\n        source,\n      );\n      positions = [];\n      timeBaseline = null;\n    },\n    callbackThreshold,\n  );\n  const updatePosition = throttle<MouseEvent | TouchEvent | DragEvent>(\n    (evt) => {\n      const { target } = evt;\n      const { clientX, clientY } = isTouchEvent(evt)\n        ? evt.changedTouches[0]\n        : evt;\n      if (!timeBaseline) {\n        timeBaseline = Date.now();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror.getId(target as INode),\n        timeOffset: Date.now() - timeBaseline,\n      });\n      wrappedCb(\n        evt instanceof MouseEvent\n          ? IncrementalSource.MouseMove\n          : evt instanceof DragEvent\n            ? IncrementalSource.Drag\n            : IncrementalSource.TouchMove,\n      );\n    },\n    threshold,\n    {\n      trailing: false,\n    },\n  );\n  const handlers = [\n    on('mousemove', updatePosition, doc),\n    on('touchmove', updatePosition, doc),\n    on('drag', updatePosition, doc),\n  ];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initMouseInteractionObserver(\n  cb: mouseInteractionCallBack,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  if (sampling.mouseInteraction === false) {\n    return () => { };\n  }\n  const disableMap: Record<string, boolean | undefined> =\n    sampling.mouseInteraction === true ||\n      sampling.mouseInteraction === undefined\n      ? {}\n      : sampling.mouseInteraction;\n\n  const handlers: listenerHandler[] = [];\n  const getHandler = (eventKey: keyof typeof MouseInteractions) => {\n    return (event: MouseEvent | TouchEvent) => {\n      if (isBlocked(event.target as Node, blockClass)) {\n        return;\n      }\n      const e = isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e) {\n        return;\n      }\n      const id = mirror.getId(event.target as INode);\n      const { clientX, clientY } = e;\n      cb({\n        type: MouseInteractions[eventKey],\n        id,\n        x: clientX,\n        y: clientY,\n      });\n    };\n  };\n  Object.keys(MouseInteractions)\n    .filter(\n      (key) =>\n        Number.isNaN(Number(key)) &&\n        !key.endsWith('_Departed') &&\n        disableMap[key] !== false,\n    )\n    .forEach((eventKey: keyof typeof MouseInteractions) => {\n      const eventName = eventKey.toLowerCase();\n      const handler = getHandler(eventKey);\n      handlers.push(on(eventName, handler, doc));\n    });\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initScrollObserver(\n  cb: scrollCallback,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  const updatePosition = throttle<UIEvent>((evt) => {\n    if (!evt.target || isBlocked(evt.target as Node, blockClass)) {\n      return;\n    }\n    const id = mirror.getId(evt.target as INode);\n    if (evt.target === doc) {\n      const scrollEl = (doc.scrollingElement || doc.documentElement)!;\n      cb({\n        id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n      });\n    } else {\n      cb({\n        id,\n        x: (evt.target as HTMLElement).scrollLeft,\n        y: (evt.target as HTMLElement).scrollTop,\n      });\n    }\n  }, sampling.scroll || 100);\n  return on('scroll', updatePosition);\n}\n\nfunction initViewportResizeObserver(\n  cb: viewportResizeCallback,\n): listenerHandler {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = throttle(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    if (lastH !== height || lastW !== width) {\n      cb({\n        width: Number(width),\n        height: Number(height),\n      });\n      lastH = height;\n      lastW = width;\n    }\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nexport const INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nconst lastInputValueMap: WeakMap<EventTarget, inputValue> = new WeakMap();\nfunction initInputObserver(\n  cb: inputCallback,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  ignoreClass: string,\n  maskInputOptions: MaskInputOptions,\n  maskInputFn: MaskInputFn | undefined,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  function eventHandler(event: Event) {\n    const { target } = event;\n    if (\n      !target ||\n      !(target as Element).tagName ||\n      INPUT_TAGS.indexOf((target as Element).tagName) < 0 ||\n      isBlocked(target as Node, blockClass)\n    ) {\n      return;\n    }\n    const type: string | undefined = (target as HTMLInputElement).type;\n    if (\n      type === 'password' ||\n      (target as HTMLElement).classList.contains(ignoreClass)\n    ) {\n      return;\n    }\n    let text = (target as HTMLInputElement).value;\n    let isChecked = false;\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = (target as HTMLInputElement).checked;\n    } else if (\n      maskInputOptions[\n      (target as Element).tagName.toLowerCase() as keyof MaskInputOptions\n      ] ||\n      maskInputOptions[type as keyof MaskInputOptions]\n    ) {\n      if (maskInputFn) {\n        text = maskInputFn(text);\n      } else {\n        text = '*'.repeat(text.length);\n      }\n    }\n    cbWithDedup(target, { text, isChecked });\n    // if a radio was checked\n    // the other radios with the same name attribute will be unchecked.\n    const name: string | undefined = (target as HTMLInputElement).name;\n    if (type === 'radio' && name && isChecked) {\n      doc\n        .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\n        .forEach((el) => {\n          if (el !== target) {\n            cbWithDedup(el, {\n              text: (el as HTMLInputElement).value,\n              isChecked: !isChecked,\n            });\n          }\n        });\n    }\n  }\n  function cbWithDedup(target: EventTarget, v: inputValue) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (\n      !lastInputValue ||\n      lastInputValue.text !== v.text ||\n      lastInputValue.isChecked !== v.isChecked\n    ) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target as INode);\n      cb({\n        ...v,\n        id,\n      });\n    }\n  }\n  const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\n  const handlers: Array<\n    listenerHandler | hookResetter\n  > = events.map((eventName) => on(eventName, eventHandler, doc));\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    HTMLInputElement.prototype,\n    'value',\n  );\n  const hookProperties: Array<[HTMLElement, string]> = [\n    [HTMLInputElement.prototype, 'value'],\n    [HTMLInputElement.prototype, 'checked'],\n    [HTMLSelectElement.prototype, 'value'],\n    [HTMLTextAreaElement.prototype, 'value'],\n    // Some UI library use selectedIndex to set select value\n    [HTMLSelectElement.prototype, 'selectedIndex'],\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map((p) =>\n        hookSetter<HTMLElement>(p[0], p[1], {\n          set() {\n            // mock to a normal event\n            eventHandler({ target: this } as Event);\n          },\n        }),\n      ),\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initStyleSheetObserver(\n  cb: styleSheetRuleCallback,\n  mirror: Mirror,\n): listenerHandler {\n  const insertRule = CSSStyleSheet.prototype.insertRule;\n  CSSStyleSheet.prototype.insertRule = function (rule: string, index?: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        adds: [{ rule, index }],\n      });\n    }\n    return insertRule.apply(this, arguments);\n  };\n\n  const deleteRule = CSSStyleSheet.prototype.deleteRule;\n  CSSStyleSheet.prototype.deleteRule = function (index: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        removes: [{ index }],\n      });\n    }\n    return deleteRule.apply(this, arguments);\n  };\n\n  return () => {\n    CSSStyleSheet.prototype.insertRule = insertRule;\n    CSSStyleSheet.prototype.deleteRule = deleteRule;\n  };\n}\n\nfunction initMediaInteractionObserver(\n  mediaInteractionCb: mediaInteractionCallback,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const handler = (type: 'play' | 'pause') => (event: Event) => {\n    const { target } = event;\n    if (!target || isBlocked(target as Node, blockClass)) {\n      return;\n    }\n    mediaInteractionCb({\n      type: type === 'play' ? MediaInteractions.Play : MediaInteractions.Pause,\n      id: mirror.getId(target as INode),\n    });\n  };\n  const handlers = [on('play', handler('play')), on('pause', handler('pause'))];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initCanvasMutationObserver(\n  cb: canvasMutationCallback,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const props = Object.getOwnPropertyNames(CanvasRenderingContext2D.prototype);\n  const handlers: listenerHandler[] = [];\n  for (const prop of props) {\n    try {\n      if (\n        typeof CanvasRenderingContext2D.prototype[\n        prop as keyof CanvasRenderingContext2D\n        ] !== 'function'\n      ) {\n        continue;\n      }\n      const restoreHandler = patch(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        function (original) {\n          return function (\n            this: CanvasRenderingContext2D,\n            ...args: Array<unknown>\n          ) {\n            if (!isBlocked(this.canvas, blockClass)) {\n              setTimeout(() => {\n                const recordArgs = [...args];\n                if (prop === 'drawImage') {\n                  if (\n                    recordArgs[0] &&\n                    recordArgs[0] instanceof HTMLCanvasElement\n                  ) {\n                    recordArgs[0] = recordArgs[0].toDataURL();\n                  }\n                }\n                cb({\n                  id: mirror.getId((this.canvas as unknown) as INode),\n                  property: prop,\n                  args: recordArgs,\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        },\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter<CanvasRenderingContext2D>(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v) {\n            cb({\n              id: mirror.getId((this.canvas as unknown) as INode),\n              property: prop,\n              args: [v],\n              setter: true,\n            });\n          },\n        },\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initFontObserver(cb: fontCallback): listenerHandler {\n  const handlers: listenerHandler[] = [];\n\n  const fontMap = new WeakMap<FontFace, fontParam>();\n\n  const originalFontFace = FontFace;\n  // tslint:disable-next-line: no-any\n  (window as any).FontFace = function FontFace(\n    family: string,\n    source: string | ArrayBufferView,\n    descriptors?: FontFaceDescriptors,\n  ) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== 'string',\n      descriptors,\n      fontSource:\n        typeof source === 'string'\n          ? source\n          : // tslint:disable-next-line: no-any\n          JSON.stringify(Array.from(new Uint8Array(source as any))),\n    });\n    return fontFace;\n  };\n\n  const restoreHandler = patch(document.fonts, 'add', function (original) {\n    return function (this: FontFaceSet, fontFace: FontFace) {\n      setTimeout(() => {\n        const p = fontMap.get(fontFace);\n        if (p) {\n          cb(p);\n          fontMap.delete(fontFace);\n        }\n      }, 0);\n      return original.apply(this, [fontFace]);\n    };\n  });\n\n  handlers.push(() => {\n    // tslint:disable-next-line: no-any\n    (window as any).FonFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initLogObserver(\n  cb: logCallback,\n  logOptions: LogRecordOptions,\n): listenerHandler {\n  const logger = logOptions.logger;\n  if (!logger) {\n    return () => { };\n  }\n  let logCount = 0;\n  const cancelHandlers: listenerHandler[] = [];\n  // add listener to thrown errors\n  if (logOptions.level!.includes('error')) {\n    if (window) {\n      const originalOnError = window.onerror;\n      window.onerror = (\n        msg: Event | string,\n        file: string,\n        line: number,\n        col: number,\n        error: Error,\n      ) => {\n        if (originalOnError) {\n          originalOnError.apply(this, [msg, file, line, col, error]);\n        }\n        const trace: string[] = ErrorStackParser.parse(\n          error,\n        ).map((stackFrame: StackFrame) => stackFrame.toString());\n        const payload = [stringify(msg, logOptions.stringifyOptions)];\n        cb({\n          level: 'error',\n          trace,\n          payload,\n        });\n      };\n      cancelHandlers.push(() => {\n        window.onerror = originalOnError;\n      });\n    }\n  }\n  for (const levelType of logOptions.level!) {\n    cancelHandlers.push(replace(logger, levelType));\n  }\n  return () => {\n    cancelHandlers.forEach((h) => h());\n  };\n\n  /**\n   * replace the original console function and record logs\n   * @param logger the logger object such as Console\n   * @param level the name of log function to be replaced\n   */\n  function replace(_logger: Logger, level: LogLevel) {\n    if (!_logger[level]) {\n      return () => { };\n    }\n    // replace the logger.{level}. return a restore function\n    return patch(_logger, level, (original) => {\n      return (...args: unknown[]) => {\n        original.apply(this, args);\n        try {\n          const trace = ErrorStackParser.parse(new Error())\n            .map((stackFrame: StackFrame) => stackFrame.toString())\n            .splice(1); // splice(1) to omit the hijacked log function\n          const payload = args.map((s) =>\n            stringify(s, logOptions.stringifyOptions),\n          );\n          logCount++;\n          if (logCount < logOptions.lengthThreshold!) {\n            cb({\n              level,\n              trace,\n              payload,\n            });\n          } else if (logCount === logOptions.lengthThreshold) {\n            // notify the user\n            cb({\n              level: 'warn',\n              trace: [],\n              payload: [\n                stringify('The number of log records reached the threshold.'),\n              ],\n            });\n          }\n        } catch (error) {\n          original('rrweb logger error:', error, ...args);\n        }\n      };\n    });\n  }\n}\n\nfunction mergeHooks(o: observerParam, hooks: hooksParam) {\n  const {\n    mutationCb,\n    mousemoveCb,\n    mouseInteractionCb,\n    scrollCb,\n    viewportResizeCb,\n    inputCb,\n    mediaInteractionCb,\n    styleSheetRuleCb,\n    canvasMutationCb,\n    fontCb,\n    logCb,\n  } = o;\n  o.mutationCb = (...p: Arguments<mutationCallBack>) => {\n    if (hooks.mutation) {\n      hooks.mutation(...p);\n    }\n    mutationCb(...p);\n  };\n  o.mousemoveCb = (...p: Arguments<mousemoveCallBack>) => {\n    if (hooks.mousemove) {\n      hooks.mousemove(...p);\n    }\n    mousemoveCb(...p);\n  };\n  o.mouseInteractionCb = (...p: Arguments<mouseInteractionCallBack>) => {\n    if (hooks.mouseInteraction) {\n      hooks.mouseInteraction(...p);\n    }\n    mouseInteractionCb(...p);\n  };\n  o.scrollCb = (...p: Arguments<scrollCallback>) => {\n    if (hooks.scroll) {\n      hooks.scroll(...p);\n    }\n    scrollCb(...p);\n  };\n  o.viewportResizeCb = (...p: Arguments<viewportResizeCallback>) => {\n    if (hooks.viewportResize) {\n      hooks.viewportResize(...p);\n    }\n    viewportResizeCb(...p);\n  };\n  o.inputCb = (...p: Arguments<inputCallback>) => {\n    if (hooks.input) {\n      hooks.input(...p);\n    }\n    inputCb(...p);\n  };\n  o.mediaInteractionCb = (...p: Arguments<mediaInteractionCallback>) => {\n    if (hooks.mediaInteaction) {\n      hooks.mediaInteaction(...p);\n    }\n    mediaInteractionCb(...p);\n  };\n  o.styleSheetRuleCb = (...p: Arguments<styleSheetRuleCallback>) => {\n    if (hooks.styleSheetRule) {\n      hooks.styleSheetRule(...p);\n    }\n    styleSheetRuleCb(...p);\n  };\n  o.canvasMutationCb = (...p: Arguments<canvasMutationCallback>) => {\n    if (hooks.canvasMutation) {\n      hooks.canvasMutation(...p);\n    }\n    canvasMutationCb(...p);\n  };\n  o.fontCb = (...p: Arguments<fontCallback>) => {\n    if (hooks.font) {\n      hooks.font(...p);\n    }\n    fontCb(...p);\n  };\n  o.logCb = (...p: Arguments<logCallback>) => {\n    if (hooks.log) {\n      hooks.log(...p);\n    }\n    logCb(...p);\n  };\n}\n\nexport function initObservers(\n  o: observerParam,\n  hooks: hooksParam = {},\n): listenerHandler {\n  mergeHooks(o, hooks);\n  const mutationObserver = initMutationObserver(\n    o.mutationCb,\n    o.doc,\n    o.blockClass,\n    o.blockSelector,\n    o.maskTextClass,\n    o.maskTextSelector,\n    o.inlineStylesheet,\n    o.maskInputOptions,\n    o.maskTextFn,\n    o.recordCanvas,\n    o.slimDOMOptions,\n    o.mirror,\n    o.iframeManager,\n    o.shadowDomManager,\n    o.doc,\n  );\n  const mousemoveHandler = initMoveObserver(\n    o.mousemoveCb,\n    o.sampling,\n    o.doc,\n    o.mirror,\n  );\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.sampling,\n  );\n  const scrollHandler = initScrollObserver(\n    o.scrollCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.sampling,\n  );\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);\n  const inputHandler = initInputObserver(\n    o.inputCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.ignoreClass,\n    o.maskInputOptions,\n    o.maskInputFn,\n    o.sampling,\n  );\n  const mediaInteractionHandler = initMediaInteractionObserver(\n    o.mediaInteractionCb,\n    o.blockClass,\n    o.mirror,\n  );\n  const styleSheetObserver = initStyleSheetObserver(\n    o.styleSheetRuleCb,\n    o.mirror,\n  );\n  const canvasMutationObserver = o.recordCanvas\n    ? initCanvasMutationObserver(o.canvasMutationCb, o.blockClass, o.mirror)\n    : () => { };\n  const fontObserver = o.collectFonts ? initFontObserver(o.fontCb) : () => { };\n  const logObserver = o.logOptions\n    ? initLogObserver(o.logCb, o.logOptions)\n    : () => { };\n\n  return () => {\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    canvasMutationObserver();\n    fontObserver();\n    logObserver();\n  };\n}\n","import { snapshot, MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { initObservers, mutationBuffers } from './observer';\nimport {\n  on,\n  getWindowWidth,\n  getWindowHeight,\n  polyfill,\n  isIframeINode,\n  hasShadowRoot,\n  createMirror,\n} from '../utils';\nimport {\n  EventType,\n  event,\n  eventWithTime,\n  recordOptions,\n  IncrementalSource,\n  listenerHandler,\n  LogRecordOptions,\n  mutationCallbackParam,\n} from '../types';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\n\nfunction wrapEvent(e: event): eventWithTime {\n  return {\n    ...e,\n    timestamp: Date.now(),\n  };\n}\n\nlet wrappedEmit!: (e: eventWithTime, isCheckout?: boolean) => void;\n\nlet takeFullSnapshot!: (isCheckout?: boolean) => void;\n\nconst mirror = createMirror();\nfunction record<T = eventWithTime>(\n  options: recordOptions<T> = {},\n): listenerHandler | undefined {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = 'rr-block',\n    blockSelector = null,\n    ignoreClass = 'rr-ignore',\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskInputFn,\n    maskTextFn,\n    hooks,\n    packFn,\n    sampling = {},\n    mousemoveWait,\n    recordCanvas = false,\n    collectFonts = false,\n    recordLog = false,\n  } = options;\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n  // move departed options to new options\n  if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n    sampling.mousemove = mousemoveWait;\n  }\n\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n        }\n      : _maskInputOptions !== undefined\n      ? _maskInputOptions\n      : {};\n\n  const slimDOMOptions: SlimDOMOptions =\n    _slimDOMOptions === true || _slimDOMOptions === 'all'\n      ? {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaVerification: true,\n          // the following are off for slimDOMOptions === true,\n          // as they destroy some (hidden) info:\n          headMetaAuthorship: _slimDOMOptions === 'all',\n          headMetaDescKeywords: _slimDOMOptions === 'all',\n        }\n      : _slimDOMOptions\n      ? _slimDOMOptions\n      : {};\n  const defaultLogOptions: LogRecordOptions = {\n    level: [\n      'assert',\n      'clear',\n      'count',\n      'countReset',\n      'debug',\n      'dir',\n      'dirxml',\n      // 'error',\n      'group',\n      'groupCollapsed',\n      'groupEnd',\n      'info',\n      'log',\n      'table',\n      'time',\n      'timeEnd',\n      'timeLog',\n      'trace',\n      'warn',\n    ],\n    lengthThreshold: 1000,\n    logger: console,\n  };\n\n  const logOptions: LogRecordOptions = recordLog\n    ? recordLog === true\n      ? defaultLogOptions\n      : Object.assign({}, defaultLogOptions, recordLog)\n    : {};\n\n  polyfill();\n\n  let lastFullSnapshotEvent: eventWithTime;\n  let incrementalSnapshotCount = 0;\n  wrappedEmit = (e: eventWithTime, isCheckout?: boolean) => {\n    if (\n      mutationBuffers[0]?.isFrozen() &&\n      e.type !== EventType.FullSnapshot &&\n      !(\n        e.type === EventType.IncrementalSnapshot &&\n        e.data.source === IncrementalSource.Mutation\n      )\n    ) {\n      // we've got a user initiated event so first we need to apply\n      // all DOM changes that have been buffering during paused state\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n\n    emit(((packFn ? packFn(e) : e) as unknown) as T, isCheckout);\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      // attch iframe should be considered as full snapshot\n      if (\n        e.data.source === IncrementalSource.Mutation &&\n        e.data.isAttachIframe\n      ) {\n        return;\n      }\n\n      incrementalSnapshotCount++;\n      const exceedCount =\n        checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime =\n        checkoutEveryNms &&\n        e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  const wrappedMutationEmit = (m: mutationCallbackParam) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.Mutation,\n          ...m,\n        },\n      }),\n    );\n  };\n\n  const iframeManager = new IframeManager({\n    mutationCb: wrappedMutationEmit,\n  });\n\n  const shadowDomManager = new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    bypassOptions: {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      recordCanvas,\n      slimDOMOptions,\n      iframeManager,\n    },\n    mirror,\n  });\n\n  takeFullSnapshot = (isCheckout = false) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight(),\n        },\n      }),\n      isCheckout,\n    );\n\n    mutationBuffers.forEach((buf) => buf.lock()); // don't allow any mirror modifications during snapshotting\n    const [node, idNodeMap] = snapshot(document, {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      recordCanvas,\n      onSerialize: (n) => {\n        if (isIframeINode(n)) {\n          iframeManager.addIframe(n);\n        }\n        if (hasShadowRoot(n)) {\n          shadowDomManager.addShadowRoot(n.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n      },\n    });\n\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n\n    mirror.map = idNodeMap;\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: {\n            left:\n              window.pageXOffset !== undefined\n                ? window.pageXOffset\n                : document?.documentElement.scrollLeft ||\n                  document?.body?.parentElement?.scrollLeft ||\n                  document?.body.scrollLeft ||\n                  0,\n            top:\n              window.pageYOffset !== undefined\n                ? window.pageYOffset\n                : document?.documentElement.scrollTop ||\n                  document?.body?.parentElement?.scrollTop ||\n                  document?.body.scrollTop ||\n                  0,\n          },\n        },\n      }),\n    );\n    mutationBuffers.forEach((buf) => buf.unlock()); // generate & emit any mutations that happened during snapshotting, as can now apply against the newly built mirror\n  };\n\n  try {\n    const handlers: listenerHandler[] = [];\n    handlers.push(\n      on('DOMContentLoaded', () => {\n        wrappedEmit(\n          wrapEvent({\n            type: EventType.DomContentLoaded,\n            data: {},\n          }),\n        );\n      }),\n    );\n\n    const observe = (doc: Document) => {\n      return initObservers(\n        {\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source,\n                  positions,\n                },\n              }),\n            ),\n          mouseInteractionCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MouseInteraction,\n                  ...d,\n                },\n              }),\n            ),\n          scrollCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Scroll,\n                  ...p,\n                },\n              }),\n            ),\n          viewportResizeCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.ViewportResize,\n                  ...d,\n                },\n              }),\n            ),\n          inputCb: (v) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Input,\n                  ...v,\n                },\n              }),\n            ),\n          mediaInteractionCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MediaInteraction,\n                  ...p,\n                },\n              }),\n            ),\n          styleSheetRuleCb: (r) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.StyleSheetRule,\n                  ...r,\n                },\n              }),\n            ),\n          canvasMutationCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.CanvasMutation,\n                  ...p,\n                },\n              }),\n            ),\n          fontCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Font,\n                  ...p,\n                },\n              }),\n            ),\n          logCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Log,\n                  ...p,\n                },\n              }),\n            ),\n          blockClass,\n          ignoreClass,\n          maskTextClass,\n          maskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordCanvas,\n          collectFonts,\n          doc,\n          maskInputFn,\n          maskTextFn,\n          logOptions,\n          blockSelector,\n          slimDOMOptions,\n          mirror,\n          iframeManager,\n          shadowDomManager,\n        },\n        hooks,\n      );\n    };\n\n    iframeManager.addLoadListener((iframeEl) => {\n      handlers.push(observe(iframeEl.contentDocument!));\n    });\n\n    const init = () => {\n      takeFullSnapshot();\n      handlers.push(observe(document));\n    };\n    if (\n      document.readyState === 'interactive' ||\n      document.readyState === 'complete'\n    ) {\n      init();\n    } else {\n      handlers.push(\n        on(\n          'load',\n          () => {\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.Load,\n                data: {},\n              }),\n            );\n            init();\n          },\n          window,\n        ),\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  } catch (error) {\n    // TODO: handle internal error\n    console.warn(error);\n  }\n}\n\nrecord.addCustomEvent = <T>(tag: string, payload: T) => {\n  if (!wrappedEmit) {\n    throw new Error('please add custom event after start recording');\n  }\n  wrappedEmit(\n    wrapEvent({\n      type: EventType.Custom,\n      data: {\n        tag,\n        payload,\n      },\n    }),\n  );\n};\n\nrecord.freezePage = () => {\n  mutationBuffers.forEach((buf) => buf.freeze());\n};\n\nrecord.takeFullSnapshot = (isCheckout?: boolean) => {\n  if (!takeFullSnapshot) {\n    throw new Error('please take full snapshot after start recording');\n  }\n  takeFullSnapshot(isCheckout);\n};\n\nrecord.mirror = mirror;\n\nexport default record;\n","import { serializedNodeWithId, INode } from '../snapshot';\nimport { mutationCallBack } from '../types';\n\nexport class IframeManager {\n  private iframes: WeakMap<HTMLIFrameElement, true> = new WeakMap();\n  private mutationCb: mutationCallBack;\n  private loadListener?: (iframeEl: HTMLIFrameElement) => unknown;\n\n  constructor(options: { mutationCb: mutationCallBack }) {\n    this.mutationCb = options.mutationCb;\n  }\n\n  public addIframe(iframeEl: HTMLIFrameElement) {\n    this.iframes.set(iframeEl, true);\n  }\n\n  public addLoadListener(cb: (iframeEl: HTMLIFrameElement) => unknown) {\n    this.loadListener = cb;\n  }\n\n  public attachIframe(iframeEl: INode, childSn: serializedNodeWithId) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: iframeEl.__sn.id,\n          nextId: null,\n          node: childSn,\n        },\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true,\n    });\n    this.loadListener?.((iframeEl as unknown) as HTMLIFrameElement);\n  }\n}\n","import {\n  mutationCallBack,\n  blockClass,\n  maskTextClass,\n  MaskTextFn,\n  Mirror,\n} from '../types';\nimport { MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { IframeManager } from './iframe-manager';\nimport { initMutationObserver } from './observer';\n\ntype BypassOptions = {\n  blockClass: blockClass;\n  blockSelector: string | null;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  inlineStylesheet: boolean;\n  maskInputOptions: MaskInputOptions;\n  maskTextFn: MaskTextFn | undefined;\n  recordCanvas: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  iframeManager: IframeManager;\n};\n\nexport class ShadowDomManager {\n  private mutationCb: mutationCallBack;\n  private bypassOptions: BypassOptions;\n  private mirror: Mirror;\n\n  constructor(options: {\n    mutationCb: mutationCallBack;\n    bypassOptions: BypassOptions;\n    mirror: Mirror;\n  }) {\n    this.mutationCb = options.mutationCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n  }\n\n  public addShadowRoot(shadowRoot: ShadowRoot, doc: Document) {\n    initMutationObserver(\n      this.mutationCb,\n      doc,\n      this.bypassOptions.blockClass,\n      this.bypassOptions.blockSelector,\n      this.bypassOptions.maskTextClass,\n      this.bypassOptions.maskTextSelector,\n      this.bypassOptions.inlineStylesheet,\n      this.bypassOptions.maskInputOptions,\n      this.bypassOptions.maskTextFn,\n      this.bypassOptions.recordCanvas,\n      this.bypassOptions.slimDOMOptions,\n      this.mirror,\n      this.bypassOptions.iframeManager,\n      this,\n      shadowRoot,\n    );\n  }\n}\n","// @ts-nocheck\n// Mediocre shim\nlet Worker: typeof import('worker_threads').Worker;\nconst workerAdd = \";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global\";\n\ntry {\n  Worker = require('worker_threads').Worker;\n} catch(e) {\n}\nexport default Worker ? <T>(c: string, _: number, msg: unknown, transfer: ArrayBuffer[], cb: (err: Error, msg: T) => void) => {\n  let done = false;\n  const w = new Worker(c + workerAdd, { eval: true })\n    .on('error', e => cb(e, null))\n    .on('message', m => cb(null, m))\n    .on('exit', c => {\n      if (c && !done) cb(new Error('exited with code ' + c), null);\n    });\n  w.postMessage(msg, transfer);\n  w.terminate = () => {\n    done = true;\n    return Worker.prototype.terminate.call(w);\n  }\n  return w;\n} : (_: string, __: number, ___: unknown, ____: ArrayBuffer[], cb: (err: Error, msg: null) => void) => {\n  setImmediate(() => cb(new Error('async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)'), null));\n  const NOP = () => {};\n  return {\n    terminate: NOP,\n    postMessage: NOP\n  } as unknown as import('worker_threads').Worker;\n}","// @ts-nocheck\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\n\nimport wk from './node-worker';\n\n// aliases for shorter compressed code (most minifers don't do this)\nconst u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n\n// fixed length extra bits\nconst fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n\n// fixed distance extra bits\n// see fleb note\nconst fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n\n// code length index map\nconst clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n// get base, reverse index map from extra bits\nconst freb = (eb: Uint8Array, start: number) => {\n  const b = new u16(31);\n  for (let i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  }\n  // numbers here are at max 18 bits\n  const r = new u32(b[30]);\n  for (let i = 1; i < 30; ++i) {\n    for (let j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = ((j - b[i]) << 5) | i;\n    }\n  }\n  return [b, r] as const;\n}\n\nconst [fl, revfl] = freb(fleb, 2);\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nconst [fd, revfd] = freb(fdeb, 0);\n\n// map of value to reverse (assuming 16 bits)\nconst rev = new u16(32768);\nfor (let i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  let x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n  x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n  x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n  rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nconst hMap = ((cd: Uint8Array, mb: number, r: 0 | 1) => {\n  const s = cd.length;\n  // index\n  let i = 0;\n  // u16 \"map\": index -> # of codes with bit length = index\n  const l = new u16(mb);\n  // length of cd must be 288 (total # of codes)\n  for (; i < s; ++i) ++l[cd[i] - 1];\n  // u16 \"map\": index -> minimum code for bit length = index\n  const le = new u16(mb);\n  for (i = 0; i < mb; ++i) {\n    le[i] = (le[i - 1] + l[i - 1]) << 1;\n  }\n  let co: Uint16Array;\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb);\n    // bits to remove for reverser\n    const rvb = 15 - mb;\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        const sv = (i << 4) | cd[i];\n        // free bits\n        const r = mb - cd[i];\n        // start value\n        let v = le[cd[i] - 1]++ << r;\n        // m is end value\n        for (const m = v | ((1 << r) - 1); v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n      }\n    }\n  }\n  return co;\n});\n\n// fixed length tree\nconst flt = new u8(288);\nfor (let i = 0; i < 144; ++i) flt[i] = 8;\nfor (let i = 144; i < 256; ++i) flt[i] = 9;\nfor (let i = 256; i < 280; ++i) flt[i] = 7;\nfor (let i = 280; i < 288; ++i) flt[i] = 8;\n// fixed distance tree\nconst fdt = new u8(32);\nfor (let i = 0; i < 32; ++i) fdt[i] = 5;\n// fixed length map\nconst flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nconst fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n\n// find max of array\nconst max = (a: Uint8Array | number[]) => {\n  let m = a[0];\n  for (let i = 1; i < a.length; ++i) {\n    if (a[i] > m) m = a[i];\n  }\n  return m;\n};\n\n// read d, starting at bit p and mask with m\nconst bits = (d: Uint8Array, p: number, m: number) => {\n  const o = (p / 8) | 0;\n  return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n}\n\n// read d, starting at bit p continuing for at least 16 bits\nconst bits16 = (d: Uint8Array, p: number) => {\n  const o = (p / 8) | 0;\n  return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n}\n\n// get end of byte\nconst shft = (p: number) => ((p / 8) | 0) + (p & 7 && 1);\n\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nconst slc = <T extends Uint8Array | Uint16Array | Uint32Array>(v: T, s: number, e?: number): T => {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length;\n  // can't use .constructor in case user-supplied\n  const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s) as T;\n  n.set(v.subarray(s, e));\n  return n;\n}\n\n// inflate state\ntype InflateState = {\n  // lmap\n  l?: Uint16Array;\n  // dmap\n  d?: Uint16Array;\n  // lbits\n  m?: number;\n  // dbits\n  n?: number;\n  // final\n  f?: number;\n  // pos\n  p?: number;\n  // byte\n  b?: number;\n  // lstchk\n  i?: boolean;\n};\n\n/**\n * Codes for errors generated within this library\n */\nexport const FlateErrorCode = {\n  UnexpectedEOF: 0,\n  InvalidBlockType: 1,\n  InvalidLengthLiteral: 2,\n  InvalidDistance: 3,\n  StreamFinished: 4,\n  NoStreamHandler: 5,\n  InvalidHeader: 6,\n  NoCallback: 7,\n  InvalidUTF8: 8,\n  ExtraFieldTooLong: 9,\n  InvalidDate: 10,\n  FilenameTooLong: 11,\n  StreamFinishing: 12,\n  InvalidZipData: 13,\n  UnknownCompressionMethod: 14\n} as const;\n\n// error codes\nconst ec = [\n  'unexpected EOF',\n  'invalid block type',\n  'invalid length/literal',\n  'invalid distance',\n  'stream finished',\n  'no stream handler',\n  , // determined by compression function\n  'no callback',\n  'invalid UTF-8 data',\n  'extra field too long',\n  'date not in range 1980-2099',\n  'filename too long',\n  'stream finishing',\n  'invalid zip data'\n  // determined by unknown compression method\n];\n\n/**\n * An error generated within this library\n */\nexport interface FlateError extends Error {\n  /**\n   * The code associated with this error\n   */\n  code: number;\n};\n\nconst err = (ind: number, msg?: string | 0, nt?: 1) => {\n  const e: Partial<FlateError> = new Error(msg || ec[ind]);\n  e.code = ind;\n  if (Error.captureStackTrace) Error.captureStackTrace(e, err);\n  if (!nt) throw e;\n  return e as FlateError;\n}\n\n// expands raw DEFLATE data\nconst inflt = (dat: Uint8Array, buf?: Uint8Array, st?: InflateState) => {\n  // source length\n  const sl = dat.length;\n  if (!sl || (st && !st.l && sl < 5)) return buf || new u8(0);\n  // have to estimate size\n  const noBuf = !buf || (st as unknown as boolean);\n  // no state\n  const noSt = !st || st.i;\n  if (!st) st = {};\n  // Assumes roughly 33% compression ratio average\n  if (!buf) buf = new u8(sl * 3);\n  // ensure buffer can fit at least l elements\n  const cbuf = (l: number) => {\n    let bl = buf.length;\n    // need to increase size to fit\n    if (l > bl) {\n      // Double or set to necessary, whichever is greater\n      const nbuf = new u8(Math.max(bl * 2, l));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  //  last chunk         bitpos           bytes\n  let final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n  // total bits\n  const tbts = sl * 8;\n  do {\n    if (!lm) {\n      // BFINAL - this is only 1 when last chunk is next\n      st.f = final = bits(dat, pos, 1);\n      // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n      const type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if (!type) {\n        // go to end of byte boundary\n        const s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n        if (t > sl) {\n          if (noSt) err(0);\n          break;\n        }\n        // ensure size\n        if (noBuf) cbuf(bt + l);\n        // Copy over uncompressed data\n        buf.set(dat.subarray(s, t), bt);\n        // Get new bitpos, update byte count\n        st.b = bt += l, st.p = pos = t * 8;\n        continue;\n      }\n      else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        //  literal                            lengths\n        const hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n        const tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        // length+distance tree\n        const ldt = new u8(tl);\n        // code length tree\n        const clt = new u8(19);\n        for (let i = 0; i < hcLen; ++i) {\n          // use index map to get real code\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n        pos += hcLen * 3;\n        // code lengths bits\n        const clb = max(clt), clbmsk = (1 << clb) - 1;\n        // code lengths map\n        const clm = hMap(clt, clb, 1);\n        for (let i = 0; i < tl;) {\n          const r = clm[bits(dat, pos, clbmsk)];\n          // bits read\n          pos += r & 15;\n          // symbol\n          const s = r >>> 4;\n          // code length to copy\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            //  copy   count\n            let c = 0, n = 0;\n            if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n            else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;\n            else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n            while (n--) ldt[i++] = c;\n          }\n        }\n        //    length tree                 distance tree\n        const lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n        // max length bits\n        lbt = max(lt)\n        // max dist bits\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else err(1);\n      if (pos > tbts) {\n        if (noSt) err(0);\n        break;\n      }\n    }\n    // Make sure the buffer can hold this + the largest possible addition\n    // Maximum chunk size (practically, theoretically infinite) is 2^17;\n    if (noBuf) cbuf(bt + 131072);\n    const lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    let lpos = pos;\n    for (;; lpos = pos) {\n      // bits read, code\n      const c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n      pos += c & 15;\n      if (pos > tbts) {\n        if (noSt) err(0);\n        break;\n      }\n      if (!c) err(2);\n      if (sym < 256) buf[bt++] = sym;\n      else if (sym == 256) {\n        lpos = pos, lm = null;\n        break;\n      } else {\n        let add = sym - 254;\n        // no extra bits needed if less\n        if (sym > 264) {\n          // index\n          const i = sym - 257, b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        }\n        // dist\n        const d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n        if (!d) err(3);\n        pos += d & 15;\n        let dt = fd[dsym];\n        if (dsym > 3) {\n          const b = fdeb[dsym];\n          dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n        }\n        if (pos > tbts) {\n          if (noSt) err(0);\n          break;\n        }\n        if (noBuf) cbuf(bt + 131072);\n        const end = bt + add;\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - dt];\n          buf[bt + 1] = buf[bt + 1 - dt];\n          buf[bt + 2] = buf[bt + 2 - dt];\n          buf[bt + 3] = buf[bt + 3 - dt];\n        }\n        bt = end;\n      }\n    }\n    st.l = lm, st.p = lpos, st.b = bt;\n    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final)\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n}\n\n// starting at p, write the minimum number of bits that can hold v to d\nconst wbits = (d: Uint8Array, p: number, v: number) => {\n  v <<= p & 7;\n  const o = (p / 8) | 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n}\n\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nconst wbits16 = (d: Uint8Array, p: number, v: number) => {\n  v <<= p & 7;\n  const o = (p / 8) | 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n  d[o + 2] |= v >>> 16;\n}\n\ntype HuffNode = {\n  // symbol\n  s: number;\n  // frequency\n  f: number;\n  // left child\n  l?: HuffNode;\n  // right child\n  r?: HuffNode;\n};\n\n// creates code lengths from a frequency table\nconst hTree = (d: Uint16Array, mb: number) => {\n  // Need extra info to make a tree\n  const t: HuffNode[] = [];\n  for (let i = 0; i < d.length; ++i) {\n    if (d[i]) t.push({ s: i, f: d[i] });\n  }\n  const s = t.length;\n  const t2 = t.slice();\n  if (!s) return [et, 0] as const;\n  if (s == 1) {\n    const v = new u8(t[0].s + 1);\n    v[t[0].s] = 1;\n    return [v, 1] as const;\n  }\n  t.sort((a, b) => a.f - b.f);\n  // after i2 reaches last ind, will be stopped\n  // freq must be greater than largest possible number of symbols\n  t.push({ s: -1, f: 25001 });\n  let l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n  t[0] = { s: -1, f: l.f + r.f, l, r };\n  // efficient algorithm from UZIP.js\n  // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n  // symbols that combined have high freq, will start processing i2 (high-freq,\n  // non-composite) symbols instead\n  // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n  while (i1 != s - 1) {\n    l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n    t[i1++] = { s: -1, f: l.f + r.f, l, r };\n  }\n  let maxSym = t2[0].s;\n  for (let i = 1; i < s; ++i) {\n    if (t2[i].s > maxSym) maxSym = t2[i].s;\n  }\n  // code lengths\n  const tr = new u16(maxSym + 1);\n  // max bits in tree\n  let mbt = ln(t[i1 - 1], tr, 0);\n  if (mbt > mb) {\n    // more algorithms from UZIP.js\n    // TODO: find out how this code works (debt)\n    //  ind    debt\n    let i = 0, dt = 0;\n    //    left            cost\n    const lft = mbt - mb, cst = 1 << lft;\n    t2.sort((a, b) => tr[b.s] - tr[a.s] || a.f - b.f);\n    for (; i < s; ++i) {\n      const i2 = t2[i].s;\n      if (tr[i2] > mb) {\n        dt += cst - (1 << (mbt - tr[i2]));\n        tr[i2] = mb;\n      } else break;\n    }\n    dt >>>= lft;\n    while (dt > 0) {\n      const i2 = t2[i].s;\n      if (tr[i2] < mb) dt -= 1 << (mb - tr[i2]++ - 1);\n      else ++i;\n    }\n    for (; i >= 0 && dt; --i) {\n      const i2 = t2[i].s;\n      if (tr[i2] == mb) {\n        --tr[i2];\n        ++dt;\n      }\n    }\n    mbt = mb;\n  }\n  return [new u8(tr), mbt] as const;\n}\n// get the max length and assign length codes\nconst ln = (n: HuffNode, l: Uint16Array, d: number): number => {\n  return n.s == -1\n    ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n    : (l[n.s] = d);\n}\n\n// length codes generation\nconst lc = (c: Uint8Array) => {\n  let s = c.length;\n  // Note that the semicolon was intentional\n  while (s && !c[--s]);\n  const cl = new u16(++s);\n  //  ind      num         streak\n  let cli = 0, cln = c[0], cls = 1;\n  const w = (v: number) => { cl[cli++] = v; }\n  for (let i = 1; i <= s; ++i) {\n    if (c[i] == cln && i != s)\n      ++cls;\n    else {\n      if (!cln && cls > 2) {\n        for (; cls > 138; cls -= 138) w(32754);\n        if (cls > 2) {\n          w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n          cls = 0;\n        }\n      } else if (cls > 3) {\n        w(cln), --cls;\n        for (; cls > 6; cls -= 6) w(8304);\n        if (cls > 2) w(((cls - 3) << 5) | 8208), cls = 0;\n      }\n      while (cls--) w(cln);\n      cls = 1;\n      cln = c[i];\n    }\n  }\n  return [cl.subarray(0, cli), s] as const;\n}\n\n// calculate the length of output from tree, code lengths\nconst clen = (cf: Uint16Array, cl: Uint8Array) => {\n  let l = 0;\n  for (let i = 0; i < cl.length; ++i) l += cf[i] * cl[i];\n  return l;\n}\n\n// writes a fixed block\n// returns the new bit pos\nconst wfblk = (out: Uint8Array, pos: number, dat: Uint8Array) => {\n  // no need to write 00 as type: TypedArray defaults to 0\n  const s = dat.length;\n  const o = shft(pos + 2);\n  out[o] = s & 255;\n  out[o + 1] = s >>> 8;\n  out[o + 2] = out[o] ^ 255;\n  out[o + 3] = out[o + 1] ^ 255;\n  for (let i = 0; i < s; ++i) out[o + i + 4] = dat[i];\n  return (o + 4 + s) * 8;\n}\n\n// writes a block\nconst wblk = (dat: Uint8Array, out: Uint8Array, final: number, syms: Uint32Array, lf: Uint16Array, df: Uint16Array, eb: number, li: number, bs: number, bl: number, p: number) => {\n  wbits(out, p++, final);\n  ++lf[256];\n  const [dlt, mlb] = hTree(lf, 15);\n  const [ddt, mdb] = hTree(df, 15);\n  const [lclt, nlc] = lc(dlt);\n  const [lcdt, ndc] = lc(ddt);\n  const lcfreq = new u16(19);\n  for (let i = 0; i < lclt.length; ++i) lcfreq[lclt[i] & 31]++;\n  for (let i = 0; i < lcdt.length; ++i) lcfreq[lcdt[i] & 31]++;\n  const [lct, mlcb] = hTree(lcfreq, 7);\n  let nlcc = 19;\n  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n  const flen = (bl + 5) << 3;\n  const ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n  const dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n  if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n  let lm: Uint16Array, ll: Uint8Array, dm: Uint16Array, dl: Uint8Array;\n  wbits(out, p, 1 + (dtlen < ftlen as unknown as number)), p += 2;\n  if (dtlen < ftlen) {\n    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n    const llm = hMap(lct, mlcb, 0);\n    wbits(out, p, nlc - 257);\n    wbits(out, p + 5, ndc - 1);\n    wbits(out, p + 10, nlcc - 4);\n    p += 14;\n    for (let i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);\n    p += 3 * nlcc;\n    const lcts = [lclt, lcdt];\n    for (let it = 0; it < 2; ++it) {\n      const clct = lcts[it];\n      for (let i = 0; i < clct.length; ++i) {\n        const len = clct[i] & 31;\n        wbits(out, p, llm[len]), p += lct[len];\n        if (len > 15) wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n      }\n    }\n  } else {\n    lm = flm, ll = flt, dm = fdm, dl = fdt;\n  }\n  for (let i = 0; i < li; ++i) {\n    if (syms[i] > 255) {\n      const len = (syms[i] >>> 18) & 31;\n      wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n      if (len > 7) wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n      const dst = syms[i] & 31;\n      wbits16(out, p, dm[dst]), p += dl[dst];\n      if (dst > 3) wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n    } else {\n      wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n    }\n  }\n  wbits16(out, p, lm[256]);\n  return p + ll[256];\n}\n\n// deflate options (nice << 13) | chain\nconst deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n\n// empty\nconst et = /*#__PURE__*/new u8(0);\n\n// compresses data into a raw DEFLATE buffer\nconst dflt = (dat: Uint8Array, lvl: number, plvl: number, pre: number, post: number, lst: 0 | 1) => {\n  const s = dat.length;\n  const o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n  // writing to this writes to the output buffer\n  const w = o.subarray(pre, o.length - post);\n  let pos = 0;\n  if (!lvl || s < 8) {\n    for (let i = 0; i <= s; i += 65535) {\n      // end\n      const e = i + 65535;\n      if (e < s) {\n        // write full block\n        pos = wfblk(w, pos, dat.subarray(i, e));\n      } else {\n        // write final block\n        w[i] = lst;\n        pos = wfblk(w, pos, dat.subarray(i, s));\n      }\n    }\n  } else {\n    const opt = deo[lvl - 1];\n    const n = opt >>> 13, c = opt & 8191;\n    const msk = (1 << plvl) - 1;\n    //    prev 2-byte val map    curr 2-byte val map\n    const prev = new u16(32768), head = new u16(msk + 1);\n    const bs1 = Math.ceil(plvl / 3), bs2 = 2 * bs1;\n    const hsh = (i: number) => (dat[i] ^ (dat[i + 1] << bs1) ^ (dat[i + 2] << bs2)) & msk;\n    // 24576 is an arbitrary number of maximum symbols per block\n    // 424 buffer for last block\n    const syms = new u32(25000);\n    // length/literal freq   distance freq\n    const lf = new u16(288), df = new u16(32);\n    //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n    let lc = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n    for (; i < s; ++i) {\n      // hash value\n      // deopt when i > s - 3 - at end, deopt acceptable\n      const hv = hsh(i);\n      // index mod 32768    previous index mod\n      let imod = i & 32767, pimod = head[hv];\n      prev[imod] = pimod;\n      head[hv] = imod;\n      // We always should modify head and prev, but only add symbols if\n      // this data is not yet processed (\"wait\" for wait index)\n      if (wi <= i) {\n        // bytes remaining\n        const rem = s - i;\n        if ((lc > 7000 || li > 24576) && rem > 423) {\n          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n          li = lc = eb = 0, bs = i;\n          for (let j = 0; j < 286; ++j) lf[j] = 0;\n          for (let j = 0; j < 30; ++j) df[j] = 0;\n        }\n        //  len    dist   chain\n        let l = 2, d = 0, ch = c, dif = (imod - pimod) & 32767;\n        if (rem > 2 && hv == hsh(i - dif)) {\n          const maxn = Math.min(n, rem) - 1;\n          const maxd = Math.min(32767, i);\n          // max possible length\n          // not capped at dif because decompressors implement \"rolling\" index population\n          const ml = Math.min(258, rem);\n          while (dif <= maxd && --ch && imod != pimod) {\n            if (dat[i + l] == dat[i + l - dif]) {\n              let nl = 0;\n              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n              if (nl > l) {\n                l = nl, d = dif;\n                // break out early when we reach \"nice\" (we are satisfied enough)\n                if (nl > maxn) break;\n                // now, find the rarest 2-byte sequence within this\n                // length of literals and search for that instead.\n                // Much faster than just using the start\n                const mmd = Math.min(dif, nl - 2);\n                let md = 0;\n                for (let j = 0; j < mmd; ++j) {\n                  const ti = (i - dif + j + 32768) & 32767;\n                  const pti = prev[ti];\n                  const cd = (ti - pti + 32768) & 32767;\n                  if (cd > md) md = cd, pimod = ti;\n                }\n              }\n            }\n            // check the previous match\n            imod = pimod, pimod = prev[imod];\n            dif += (imod - pimod + 32768) & 32767;\n          }\n        }\n        // d will be nonzero only when a match was found\n        if (d) {\n          // store both dist and len data in one Uint32\n          // Make sure this is recognized as a len/dist with 28th bit (2^28)\n          syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n          const lin = revfl[l] & 31, din = revfd[d] & 31;\n          eb += fleb[lin] + fdeb[din];\n          ++lf[257 + lin];\n          ++df[din];\n          wi = i + l;\n          ++lc;\n        } else {\n          syms[li++] = dat[i];\n          ++lf[dat[i]];\n        }\n      }\n    }\n    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n    // this is the easiest way to avoid needing to maintain state\n    if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);\n  }\n  return slc(o, 0, pre + shft(pos) + post);\n}\n\n// crc check\ntype CRCV = {\n  p(d: Uint8Array): void;\n  d(): number;\n};\n\n// CRC32 table\nconst crct = /*#__PURE__*/ (() => {\n  const t = new Int32Array(256);\n  for (let i = 0; i < 256; ++i) {\n    let c = i, k = 9;\n    while (--k) c = ((c & 1) && -306674912) ^ (c >>> 1);\n    t[i] = c;\n  }\n  return t;\n})();\n\n// CRC32\nconst crc = (): CRCV => {\n  let c = -1;\n  return {\n    p(d) {\n      // closures have awful performance\n      let cr = c;\n      for (let i = 0; i < d.length; ++i) cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n      c = cr;\n    },\n    d() { return ~c; }\n  }\n}\n\n// Alder32\nconst adler = (): CRCV => {\n  let a = 1, b = 0;\n  return {\n    p(d) {\n      // closures have awful performance\n      let n = a, m = b;\n      const l = d.length | 0;\n      for (let i = 0; i != l;) {\n        const e = Math.min(i + 2655, l);\n        for (; i < e; ++i) m += n += d[i];\n        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n      }\n      a = n, b = m;\n    },\n    d() {\n      a %= 65521, b %= 65521;\n      return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n    }\n  }\n}\n\n/**\n * Options for compressing data into a DEFLATE format\n */\nexport interface DeflateOptions {\n  /**\n   * The level of compression to use, ranging from 0-9.\n   * \n   * 0 will store the data without compression.\n   * 1 is fastest but compresses the worst, 9 is slowest but compresses the best.\n   * The default level is 6.\n   * \n   * Typically, binary data benefits much more from higher values than text data.\n   * In both cases, higher values usually take disproportionately longer than the reduction in final size that results.\n   * \n   * For example, a 1 MB text file could:\n   * - become 1.01 MB with level 0 in 1ms\n   * - become 400 kB with level 1 in 10ms\n   * - become 320 kB with level 9 in 100ms\n   */\n  level?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n  /**\n   * The memory level to use, ranging from 0-12. Increasing this increases speed and compression ratio at the cost of memory.\n   * \n   * Note that this is exponential: while level 0 uses 4 kB, level 4 uses 64 kB, level 8 uses 1 MB, and level 12 uses 16 MB.\n   * It is recommended not to lower the value below 4, since that tends to hurt performance.\n   * In addition, values above 8 tend to help very little on most data and can even hurt performance.\n   * \n   * The default value is automatically determined based on the size of the input data.\n   */\n  mem?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n};\n\n/**\n * Options for compressing data into a GZIP format\n */\nexport interface GzipOptions extends DeflateOptions {\n  /**\n   * When the file was last modified. Defaults to the current time.\n   * Set this to 0 to avoid revealing a modification date entirely.\n   */\n  mtime?: Date | string | number;\n  /**\n   * The filename of the data. If the `gunzip` command is used to decompress the data, it will output a file\n   * with this name instead of the name of the compressed file.\n   */\n  filename?: string;\n}\n\n/**\n * Options for compressing data into a Zlib format\n */\nexport interface ZlibOptions extends DeflateOptions {}\n\n/**\n * Handler for data (de)compression streams\n * @param data The data output from the stream processor\n * @param final Whether this is the final block\n */\nexport type FlateStreamHandler = (data: Uint8Array, final: boolean) => void;\n\n/**\n * Handler for asynchronous data (de)compression streams\n * @param err Any error that occurred\n * @param data The data output from the stream processor\n * @param final Whether this is the final block\n */\nexport type AsyncFlateStreamHandler = (err: FlateError, data: Uint8Array, final: boolean) => void;\n\n/**\n * Callback for asynchronous (de)compression methods\n * @param err Any error that occurred\n * @param data The resulting data. Only present if `err` is null\n */\nexport type FlateCallback = (err: FlateError, data: Uint8Array) => void;\n\n// async callback-based compression\ninterface AsyncOptions {\n  /**\n   * Whether or not to \"consume\" the source data. This will make the typed array/buffer you pass in\n   * unusable but will increase performance and reduce memory usage.\n   */\n  consume?: boolean;\n}\n\n/**\n * Options for compressing data asynchronously into a DEFLATE format\n */\nexport interface AsyncDeflateOptions extends DeflateOptions, AsyncOptions {}\n\n/**\n * Options for decompressing DEFLATE data asynchronously\n */\nexport interface AsyncInflateOptions extends AsyncOptions {\n  /**\n   * The original size of the data. Currently, the asynchronous API disallows\n   * writing into a buffer you provide; the best you can do is provide the\n   * size in bytes and be given back a new typed array.\n   */\n  size?: number;\n}\n\n/**\n * Options for compressing data asynchronously into a GZIP format\n */\nexport interface AsyncGzipOptions extends GzipOptions, AsyncOptions {}\n\n/**\n * Options for decompressing GZIP data asynchronously\n */\nexport interface AsyncGunzipOptions extends AsyncOptions {}\n\n/**\n * Options for compressing data asynchronously into a Zlib format\n */\nexport interface AsyncZlibOptions extends ZlibOptions, AsyncOptions {}\n\n/**\n * Options for decompressing Zlib data asynchronously\n */\nexport interface AsyncUnzlibOptions extends AsyncInflateOptions {}\n\n/**\n * A terminable compression/decompression process\n */\nexport interface AsyncTerminable {\n  /**\n   * Terminates the worker thread immediately. The callback will not be called.\n   */\n  (): void;\n}\n\n// deflate with opts\nconst dopt = (dat: Uint8Array, opt: DeflateOptions, pre: number, post: number, st?: boolean) =>\n  dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st as unknown as 0 | 1);\n\n// Walmart object spread\nconst mrg = <A, B>(a: A, b: B) => {\n  const o = {} as Record<string, unknown>;\n  for (const k in a) o[k] = a[k];\n  for (const k in b) o[k] = b[k];\n  return o as A & B;\n}\n\n// worker clone\n\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n\n// This took me three weeks to figure out how to do.\nconst wcln = (fn: () => unknown[], fnStr: string, td: Record<string, unknown>) => {\n  const dt = fn();\n  const st = fn.toString();\n  const ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n  for (let i = 0; i < dt.length; ++i) {\n    let v = dt[i], k = ks[i];\n    if (typeof v == 'function') {\n      fnStr += ';' + k + '=';\n      const st = v.toString();\n      if (v.prototype) {\n        // for global objects\n        if (st.indexOf('[native code]') != -1) {\n          const spInd = st.indexOf(' ', 8) + 1;\n          fnStr += st.slice(spInd, st.indexOf('(', spInd));\n        } else {\n          fnStr += st;\n          for (const t in v.prototype) fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n        }\n      } else fnStr += st;\n    } else td[k] = v;\n  }\n  return [fnStr, td] as const;\n}\n\ntype CachedWorker = readonly [string, Record<string, unknown>];\n\nconst ch: CachedWorker[] = [];\n// clone bufs\nconst cbfs = (v: Record<string, unknown>) => {\n  const tl: ArrayBuffer[] = [];\n  for (const k in v) {\n    if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new (v[k].constructor as typeof u8)(v[k] as Uint8Array)).buffer);\n  }\n  return tl;\n}\n\n// use a worker to execute code\nconst wrkr = <T, R>(fns: (() => unknown[])[], init: (ev: MessageEvent<T>) => void, id: number, cb: (err: FlateError, msg: R) => void) => {\n  if (!ch[id]) {\n    let fnStr = '', td: Record<string, unknown> = {}, m = fns.length - 1;\n    for (let i = 0; i < m; ++i)\n      [fnStr, td] = wcln(fns[i], fnStr, td);\n    ch[id] = wcln(fns[m], fnStr, td);\n  }\n  const td = mrg({}, ch[id][1]);\n  return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n}\n\n// base async inflate fn\nconst bInflt = () => [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8];\nconst bDflt = () => [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]\n\n// gzip extra\nconst gze = () => [gzh, gzhl, wbytes, crc, crct];\n// gunzip extra\nconst guze = () => [gzs, gzl];\n// zlib extra\nconst zle = () => [zlh, wbytes, adler];\n// unzlib extra\nconst zule = () => [zlv];\n\n// post buf\nconst pbf = (msg: Uint8Array) => (postMessage as Worker['postMessage'])(msg, [msg.buffer]);\n\n// get u8\nconst gu8 = (o?: AsyncInflateOptions) => o && o.size && new u8(o.size);\n\n// async helper\nconst cbify = <T extends AsyncOptions>(dat: Uint8Array, opts: T, fns: (() => unknown[])[], init: (ev: MessageEvent<[Uint8Array, T]>) => void, id: number, cb: FlateCallback) => {\n  const w = wrkr<[Uint8Array, T], Uint8Array>(\n    fns,\n    init,\n    id,\n    (err, dat) => {\n      w.terminate();\n      cb(err, dat);\n    }\n  );\n  w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n  return () => { w.terminate(); };\n}\n\ntype CmpDecmpStrm = Inflate | Deflate | Gzip | Gunzip | Zlib | Unzlib;\n\n// auto stream\nconst astrm = (strm: CmpDecmpStrm) => {\n  strm.ondata = (dat, final) => (postMessage as Worker['postMessage'])([dat, final], [dat.buffer]);\n  return (ev: MessageEvent<[Uint8Array, boolean]>) => strm.push(ev.data[0], ev.data[1]);\n}\n\ntype Astrm = { ondata: AsyncFlateStreamHandler; push: (d: Uint8Array, f?: boolean) => void; terminate: AsyncTerminable; };\n\n// async stream attach\nconst astrmify = <T>(fns: (() => unknown[])[], strm: Astrm, opts: T | 0, init: (ev: MessageEvent<T>) => void, id: number) => {\n  let t: boolean;\n  const w = wrkr<T, [Uint8Array, boolean]>(\n    fns,\n    init,\n    id,\n    (err, dat) => {\n      if (err) w.terminate(), strm.ondata.call(strm, err);\n      else {\n        if (dat[1]) w.terminate();\n        strm.ondata.call(strm, err, dat[0], dat[1]);\n      }\n    }\n  )\n  w.postMessage(opts);\n  strm.push = (d, f) => {\n    if (!strm.ondata) err(5);\n    if (t) strm.ondata(err(4, 0, 1), null, !!f);\n    w.postMessage([d, t = f], [d.buffer]);\n  };\n  strm.terminate = () => { w.terminate(); };\n}\n\n// read 2 bytes\nconst b2 = (d: Uint8Array, b: number) => d[b] | (d[b + 1] << 8);\n\n// read 4 bytes\nconst b4 = (d: Uint8Array, b: number) => (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0;\n\nconst b8 = (d: Uint8Array, b: number) => b4(d, b) + (b4(d, b + 4) * 4294967296);\n\n// write bytes\nconst wbytes = (d: Uint8Array, b: number, v: number) => {\n  for (; v; ++b) d[b] = v, v >>>= 8;\n}\n\n// gzip header\nconst gzh = (c: Uint8Array, o: GzipOptions) => {\n  const fn = o.filename;\n  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n  if (o.mtime != 0) wbytes(c, 4, Math.floor((new Date(o.mtime as (string | number) || Date.now()) as unknown as number) / 1000));\n  if (fn) {\n    c[3] = 8;\n    for (let i = 0; i <= fn.length; ++i) c[i + 10] = fn.charCodeAt(i);\n  }\n}\n\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n\n// gzip start\nconst gzs = (d: Uint8Array) => {\n  if (d[0] != 31 || d[1] != 139 || d[2] != 8) err(6, 'invalid gzip data');\n  const flg = d[3];\n  let st = 10;\n  if (flg & 4) st += d[10] | (d[11] << 8) + 2;\n  for (let zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++] as unknown as number);\n  return st + (flg & 2);\n}\n\n// gzip length\nconst gzl = (d: Uint8Array) => {\n  const l = d.length;\n  return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n}\n\n// gzip header length\nconst gzhl = (o: GzipOptions) => 10 + ((o.filename && (o.filename.length + 1)) || 0);\n\n// zlib header\nconst zlh = (c: Uint8Array, o: ZlibOptions) => {\n  const lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n  c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n}\n\n// zlib valid\nconst zlv = (d: Uint8Array) => {\n  if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31)) err(6, 'invalid zlib data');\n  if (d[1] & 32) err(6, 'invalid zlib data: preset dictionaries not supported');\n}\n\n/**\n * Creates an asynchronous compression stream\n * @param opts The compression options\n * @param cb The callback to call whenever data is deflated\n */\nfunction AsyncCmpStrm<T>(opts: T, cb?: AsyncFlateStreamHandler): T;\n/**\n * Creates an asynchronous compression stream\n * @param cb The callback to call whenever data is deflated\n */\nfunction AsyncCmpStrm<T>(cb?: AsyncFlateStreamHandler): T;\nfunction AsyncCmpStrm<T>(opts?: T | AsyncFlateStreamHandler, cb?: AsyncFlateStreamHandler): T {\n  if (!cb && typeof opts == 'function') cb = opts as AsyncFlateStreamHandler, opts = {} as T;\n  this.ondata = cb as AsyncFlateStreamHandler;\n  return opts as T;\n}\n\n// zlib footer: -4 to -0 is Adler32\n\n/**\n * Streaming DEFLATE compression\n */\nexport class Deflate {\n  /**\n   * Creates a DEFLATE stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: DeflateOptions, cb?: FlateStreamHandler);\n  constructor(cb?: FlateStreamHandler);\n  constructor(opts?: DeflateOptions | FlateStreamHandler, cb?: FlateStreamHandler) {\n    if (!cb && typeof opts == 'function') cb = opts as FlateStreamHandler, opts = {};\n    this.ondata = cb;\n    this.o = (opts as DeflateOptions) || {};\n  }\n  private o: DeflateOptions;\n  private d: boolean;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  private p(c: Uint8Array, f: boolean) {\n    this.ondata(dopt(c, this.o, 0, 0, !f), f);\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.ondata) err(5);\n    if (this.d) err(4);\n    this.d = final;\n    this.p(chunk, final || false);\n  }\n}\n\n/**\n * Asynchronous streaming DEFLATE compression\n */\nexport class AsyncDeflate {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous DEFLATE stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: DeflateOptions, cb?: AsyncFlateStreamHandler);\n  /**\n   * Creates an asynchronous DEFLATE stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler);\n  constructor(opts?: DeflateOptions | AsyncFlateStreamHandler, cb?: AsyncFlateStreamHandler) {\n    astrmify([\n      bDflt,\n      () => [astrm, Deflate]\n    ], this as unknown as Astrm, AsyncCmpStrm.call(this, opts, cb), ev => {\n      const strm = new Deflate(ev.data);\n      onmessage = astrm(strm);\n    }, 6);\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n  \n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @param cb The function to be called upon compression completion\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function deflate(data: Uint8Array, opts: AsyncDeflateOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param cb The function to be called upon compression completion\n */\nexport function deflate(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function deflate(data: Uint8Array, opts: AsyncDeflateOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncDeflateOptions, [\n    bDflt,\n  ], ev => pbf(deflateSync(ev.data[0], ev.data[1])), 0, cb);\n}\n\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data: Uint8Array, opts?: DeflateOptions) {\n  return dopt(data, opts || {}, 0, 0);\n}\n\n/**\n * Streaming DEFLATE decompression\n */\nexport class Inflate {\n  /**\n   * Creates an inflation stream\n   * @param cb The callback to call whenever data is inflated\n   */\n  constructor(cb?: FlateStreamHandler) { this.ondata = cb; }\n  private s: InflateState = {};\n  private o: Uint8Array;\n  private p = new u8(0);\n  private d: boolean;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  private e(c: Uint8Array) {\n    if (!this.ondata) err(5);\n    if (this.d) err(4);\n    const l = this.p.length;\n    const n = new u8(l + c.length);\n    n.set(this.p), n.set(c, l), this.p = n;\n  }\n\n  private c(final: boolean) {\n    this.d = this.s.i = final || false;\n    const bts = this.s.b;\n    const dt = inflt(this.p, this.o, this.s);\n    this.ondata(slc(dt, bts, this.s.b), this.d);\n    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n    this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n  }\n\n  /**\n   * Pushes a chunk to be inflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the final chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    this.e(chunk), this.c(final);\n  }\n}\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nexport class AsyncInflate {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous inflation stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler) {\n    this.ondata = cb;\n    astrmify([\n      bInflt,\n      () => [astrm, Inflate]\n    ], this as unknown as Astrm, 0, () => {\n      const strm = new Inflate();\n      onmessage = astrm(strm);\n    }, 7);\n  }\n\n  /**\n   * Pushes a chunk to be inflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function inflate(data: Uint8Array, opts: AsyncInflateOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function inflate(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function inflate(data: Uint8Array, opts: AsyncInflateOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncInflateOptions, [\n    bInflt\n  ], ev => pbf(inflateSync(ev.data[0], gu8(ev.data[1]))), 1, cb);\n}\n\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data: Uint8Array, out?: Uint8Array) {\n  return inflt(data, out);\n}\n\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n\n/**\n * Streaming GZIP compression\n */\nexport class Gzip {\n  private c = crc();\n  private l = 0;\n  private v = 1;\n  private o: GzipOptions;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  /**\n   * Creates a GZIP stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: GzipOptions, cb?: FlateStreamHandler);\n  /**\n   * Creates a GZIP stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: FlateStreamHandler);\n  constructor(opts?: GzipOptions | FlateStreamHandler, cb?: FlateStreamHandler) {\n    Deflate.call(this, opts, cb);\n  }\n\n  /**\n   * Pushes a chunk to be GZIPped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    Deflate.prototype.push.call(this, chunk, final);\n  }\n  \n  private p(c: Uint8Array, f: boolean) {\n    this.c.p(c);\n    this.l += c.length;\n    const raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n    if (this.v) gzh(raw, this.o), this.v = 0;\n    if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n    this.ondata(raw, f);\n  }\n}\n\n/**\n * Asynchronous streaming GZIP compression\n */\nexport class AsyncGzip {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous GZIP stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: GzipOptions, cb?: AsyncFlateStreamHandler);\n  /**\n   * Creates an asynchronous GZIP stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler);\n  constructor(opts?: GzipOptions | AsyncFlateStreamHandler, cb?: AsyncFlateStreamHandler) {\n    astrmify([\n      bDflt,\n      gze,\n      () => [astrm, Deflate, Gzip]\n    ], this as unknown as Astrm, AsyncCmpStrm.call(this, opts, cb), ev => {\n      const strm = new Gzip(ev.data);\n      onmessage = astrm(strm);\n    }, 8);\n  }\n\n  /**\n   * Pushes a chunk to be GZIPped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @param cb The function to be called upon compression completion\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function gzip(data: Uint8Array, opts: AsyncGzipOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously compresses data with GZIP\n * @param data The data to compress\n * @param cb The function to be called upon compression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function gzip(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function gzip(data: Uint8Array, opts: AsyncGzipOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncGzipOptions, [\n    bDflt,\n    gze,\n    () => [gzipSync]\n  ], ev => pbf(gzipSync(ev.data[0], ev.data[1])), 2, cb);\n}\n\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data: Uint8Array, opts?: GzipOptions) {\n  if (!opts) opts = {};\n  const c = crc(), l = data.length;\n  c.p(data);\n  const d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n  return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n\n/**\n * Streaming GZIP decompression\n */\nexport class Gunzip {\n  private v = 1;\n  private p: Uint8Array;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  /**\n   * Creates a GUNZIP stream\n   * @param cb The callback to call whenever data is inflated\n   */\n  constructor(cb?: FlateStreamHandler) { Inflate.call(this, cb); }\n\n  /**\n   * Pushes a chunk to be GUNZIPped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    (Inflate.prototype as unknown as { e: typeof Inflate.prototype['e'] }).e.call(this, chunk);\n    if (this.v) {\n      const s = this.p.length > 3 ? gzs(this.p) : 4;\n      if (s >= this.p.length && !final) return;\n      this.p = this.p.subarray(s), this.v = 0;\n    }\n    if (final) {\n      if (this.p.length < 8) err(6, 'invalid gzip data');\n      this.p = this.p.subarray(0, -8);\n    }\n    // necessary to prevent TS from using the closure value\n    // This allows for workerization to function correctly\n    (Inflate.prototype as unknown as { c: typeof Inflate.prototype['c'] }).c.call(this, final);\n  }\n}\n\n/**\n * Asynchronous streaming GZIP decompression\n */\nexport class AsyncGunzip {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous GUNZIP stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler) {\n    this.ondata = cb;\n    astrmify([\n      bInflt,\n      guze,\n      () => [astrm, Inflate, Gunzip]\n    ], this as unknown as Astrm, 0, () => {\n      const strm = new Gunzip();\n      onmessage = astrm(strm);\n    }, 9);\n  }\n\n  /**\n   * Pushes a chunk to be GUNZIPped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function gunzip(data: Uint8Array, opts: AsyncGunzipOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously expands GZIP data\n * @param data The data to decompress\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function gunzip(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function gunzip(data: Uint8Array, opts: AsyncGunzipOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncGunzipOptions, [\n    bInflt,\n    guze,\n    () => [gunzipSync]\n  ], ev => pbf(gunzipSync(ev.data[0])), 3, cb);\n}\n\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data: Uint8Array, out?: Uint8Array) {\n  return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n\n/**\n * Streaming Zlib compression\n */\nexport class Zlib {\n  private c = adler();\n  private v = 1;\n  private o: GzipOptions;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  /**\n   * Creates a Zlib stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: ZlibOptions, cb?: FlateStreamHandler);\n  /**\n   * Creates a Zlib stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: FlateStreamHandler);\n  constructor(opts?: ZlibOptions | FlateStreamHandler, cb?: FlateStreamHandler) {\n    Deflate.call(this, opts, cb);\n  }\n\n  /**\n   * Pushes a chunk to be zlibbed\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    Deflate.prototype.push.call(this, chunk, final);\n  }\n  \n  private p(c: Uint8Array, f: boolean) {\n    this.c.p(c);\n    const raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n    if (this.v) zlh(raw, this.o), this.v = 0;\n    if (f) wbytes(raw, raw.length - 4, this.c.d());\n    this.ondata(raw, f);\n  }\n}\n\n/**\n * Asynchronous streaming Zlib compression\n */\nexport class AsyncZlib {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous DEFLATE stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: ZlibOptions, cb?: AsyncFlateStreamHandler);\n  /**\n   * Creates an asynchronous DEFLATE stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler);\n  constructor(opts?: ZlibOptions | AsyncFlateStreamHandler, cb?: AsyncFlateStreamHandler) {\n    astrmify([\n      bDflt,\n      zle,\n      () => [astrm, Deflate, Zlib]\n    ], this as unknown as Astrm, AsyncCmpStrm.call(this, opts, cb), ev => {\n      const strm = new Zlib(ev.data);\n      onmessage = astrm(strm);\n    }, 10);\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously compresses data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @param cb The function to be called upon compression completion\n */\nexport function zlib(data: Uint8Array, opts: AsyncZlibOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously compresses data with Zlib\n * @param data The data to compress\n * @param cb The function to be called upon compression completion\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function zlib(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function zlib(data: Uint8Array, opts: AsyncZlibOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncZlibOptions, [\n    bDflt,\n    zle,\n    () => [zlibSync]\n  ], ev => pbf(zlibSync(ev.data[0], ev.data[1])), 4, cb);\n}\n\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data: Uint8Array, opts: ZlibOptions) {\n  if (!opts) opts = {};\n  const a = adler();\n  a.p(data);\n  const d = dopt(data, opts, 2, 4);\n  return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n\n/**\n * Streaming Zlib decompression\n */\nexport class Unzlib {\n  private v = 1;\n  private p: Uint8Array;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n  /**\n   * Creates a Zlib decompression stream\n   * @param cb The callback to call whenever data is inflated\n   */\n  constructor(cb?: FlateStreamHandler) { Inflate.call(this, cb); }\n\n  /**\n   * Pushes a chunk to be unzlibbed\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    (Inflate.prototype as unknown as { e: typeof Inflate.prototype['e'] }).e.call(this, chunk);\n    if (this.v) {\n      if (this.p.length < 2 && !final) return;\n      this.p = this.p.subarray(2), this.v = 0;\n    }\n    if (final) {\n      if (this.p.length < 4) err(6, 'invalid zlib data');\n      this.p = this.p.subarray(0, -4);\n    }\n    // necessary to prevent TS from using the closure value\n    // This allows for workerization to function correctly\n    (Inflate.prototype as unknown as { c: typeof Inflate.prototype['c'] }).c.call(this, final);\n  }\n}\n\n/**\n * Asynchronous streaming Zlib decompression\n */\nexport class AsyncUnzlib {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous Zlib decompression stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler) {\n    this.ondata = cb;\n    astrmify([\n      bInflt,\n      zule,\n      () => [astrm, Inflate, Unzlib]\n    ], this as unknown as Astrm, 0, () => {\n      const strm = new Unzlib();\n      onmessage = astrm(strm);\n    }, 11);\n  }\n\n  /**\n   * Pushes a chunk to be decompressed from Zlib\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function unzlib(data: Uint8Array, opts: AsyncGunzipOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously expands Zlib data\n * @param data The data to decompress\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function unzlib(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function unzlib(data: Uint8Array, opts: AsyncGunzipOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncUnzlibOptions, [\n    bInflt,\n    zule,\n    () => [unzlibSync]\n  ], ev => pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))), 5, cb);\n}\n\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data: Uint8Array, out?: Uint8Array) {\n  return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress }\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress }\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nexport class Decompress {\n  private G = Gunzip;\n  private I = Inflate;\n  private Z = Unzlib;\n  /**\n   * Creates a decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n  constructor(cb?: FlateStreamHandler) { this.ondata = cb; }\n  private s: Inflate | Gunzip | Unzlib;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n  private p: Uint8Array;\n\n  /**\n   * Pushes a chunk to be decompressed\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.ondata) err(5);\n    if (!this.s) {\n      if (this.p && this.p.length) {\n        const n = new u8(this.p.length + chunk.length);\n        n.set(this.p), n.set(chunk, this.p.length);\n      } else this.p = chunk;\n      if (this.p.length > 2) {\n        const _this = this;\n        const cb: FlateStreamHandler = function() { _this.ondata.apply(_this, arguments); }\n        this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n          ? new this.G(cb)\n          : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n            ? new this.I(cb)\n            : new this.Z(cb);\n        this.s.push(this.p, final);\n        this.p = null;\n      }\n    } else this.s.push(chunk, final);\n  }\n}\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nexport class AsyncDecompress {\n  private G = AsyncGunzip;\n  private I = AsyncInflate;\n  private Z = AsyncUnzlib;\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n  constructor(cb?: AsyncFlateStreamHandler) { this.ondata = cb; }\n  \n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Pushes a chunk to be decompressed\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    Decompress.prototype.push.call(this, chunk, final);\n  }\n}\n\n/**\n * Asynchrononously expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function decompress(data: Uint8Array, opts: AsyncInflateOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchrononously expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function decompress(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function decompress(data: Uint8Array, opts: AsyncInflateOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n    ? gunzip(data, opts as AsyncInflateOptions, cb)\n    : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n      ? inflate(data, opts as AsyncInflateOptions, cb)\n      : unzlib(data, opts as AsyncInflateOptions, cb);\n}\n\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data: Uint8Array, out?: Uint8Array) {\n  return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n    ? gunzipSync(data, out)\n    : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n      ? inflateSync(data, out)\n      : unzlibSync(data, out);\n}\n\n/**\n * Attributes for files added to a ZIP archive object\n */\nexport interface ZipAttributes {\n  /**\n   * The operating system of origin for this file. The value is defined\n   * by PKZIP's APPNOTE.txt, section 4.4.2.2. For example, 0 (the default)\n   * is MS/DOS, 3 is UNIX, 19 is macOS.\n   */\n  os?: number;\n\n  /**\n   * The file's attributes. These are traditionally somewhat complicated\n   * and platform-dependent, so using them is scarcely necessary. However,\n   * here is a representation of what this is, bit by bit:\n   * \n   * `TTTTugtrwxrwxrwx0000000000ADVSHR`\n   * \n   * TTTT = file type (rarely useful)\n   * \n   * u = setuid, g = setgid, t = sticky\n   * \n   * rwx = user permissions, rwx = group permissions, rwx = other permissions\n   * \n   * 0000000000 = unused\n   * \n   * A = archive, D = directory, V = volume label, S = system file, H = hidden, R = read-only\n   * \n   * If you want to set the Unix permissions, for instance, just bit shift by 16, e.g. 0644 << 16\n   */\n  attrs?: number;\n\n  /**\n   * Extra metadata to add to the file. This field is defined by PKZIP's APPNOTE.txt,\n   * section 4.4.28. At most 65,535 bytes may be used in each ID. The ID must be an\n   * integer between 0 and 65,535, inclusive.\n   * \n   * This field is incredibly rare and almost never needed except for compliance with\n   * proprietary standards and software.\n   */\n  extra?: Record<number, Uint8Array>;\n\n  /**\n   * The comment to attach to the file. This field is defined by PKZIP's APPNOTE.txt,\n   * section 4.4.26. The comment must be at most 65,535 bytes long UTF-8 encoded. This\n   * field is not read by consumer software.\n   */\n  comment?: string;\n\n  /**\n   * When the file was last modified. Defaults to the current time.\n   */\n  mtime?: GzipOptions['mtime'];\n}\n\n/**\n * Options for creating a ZIP archive\n */\nexport interface ZipOptions extends DeflateOptions, ZipAttributes {}\n\n/**\n * Options for asynchronously creating a ZIP archive\n */\nexport interface AsyncZipOptions extends AsyncDeflateOptions, ZipAttributes {}\n\n/**\n * Options for asynchronously expanding a ZIP archive\n */\nexport interface AsyncUnzipOptions extends AsyncOptions {}\n\n/**\n * A file that can be used to create a ZIP archive\n */\nexport type ZippableFile = Uint8Array | [Uint8Array, ZipOptions];\n\n/**\n * A file that can be used to asynchronously create a ZIP archive\n */\nexport type AsyncZippableFile = Uint8Array | [Uint8Array, AsyncZipOptions];\n\n/**\n * The complete directory structure of a ZIPpable archive\n */\nexport interface Zippable {\n  [path: string]: Zippable | ZippableFile;\n}\n\n/**\n * The complete directory structure of an asynchronously ZIPpable archive\n */\nexport interface AsyncZippable {\n  [path: string]: AsyncZippable | AsyncZippableFile;\n}\n\n/**\n * An unzipped archive. The full path of each file is used as the key,\n * and the file is the value\n */\nexport interface Unzipped {\n  [path: string]: Uint8Array\n}\n\n/**\n * Handler for string generation streams\n * @param data The string output from the stream processor\n * @param final Whether this is the final block\n */\nexport type StringStreamHandler = (data: string, final: boolean) => void;\n\n/**\n * Callback for asynchronous ZIP decompression\n * @param err Any error that occurred\n * @param data The decompressed ZIP archive\n */\nexport type UnzipCallback = (err: FlateError, data: Unzipped) => void;\n\n/**\n * Handler for streaming ZIP decompression\n * @param file The file that was found in the archive\n */\nexport type UnzipFileHandler = (file: UnzipFile) => void;\n\n// flattened Zippable\ntype FlatZippable<A extends boolean> = Record<string, [Uint8Array, (A extends true ? AsyncZipOptions : ZipOptions)]>;\n\n// flatten a directory structure\nconst fltn = <A extends boolean>(d: A extends true ? AsyncZippable : Zippable, p: string, t: FlatZippable<A>, o: ZipOptions) => {\n  for (const k in d) {\n    const val = d[k], n = p + k;\n    if (val instanceof u8) t[n] = [val, o] as unknown as FlatZippable<A>[string];\n    else if (Array.isArray(val)) t[n] = [val[0], mrg(o, val[1])] as FlatZippable<A>[string];\n    else fltn(val as unknown as (A extends true ? AsyncZippable : Zippable), n + '/', t, o);\n  }\n}\n\n// text encoder\nconst te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nconst td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nlet tds = 0;\ntry {\n  td.decode(et, { stream: true });\n  tds = 1;\n} catch(e) {}\n\n// decode UTF8\nconst dutf8 = (d: Uint8Array) => {\n  for (let r = '', i = 0;;) {\n    let c = d[i++];\n    const eb = ((c > 127) as unknown as number) + ((c > 223) as unknown as number) + ((c > 239) as unknown as number);\n    if (i + eb > d.length) return [r, slc(d, i - 1)] as const;\n    if (!eb) r += String.fromCharCode(c)\n    else if (eb == 3) {\n      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n      r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n    } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n    else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n  }\n}\n\n/**\n * Streaming UTF-8 decoding\n */\nexport class DecodeUTF8 {\n  private p: Uint8Array;\n  private t: TextDecoder;\n  /**\n   * Creates a UTF-8 decoding stream\n   * @param cb The callback to call whenever data is decoded\n   */\n  constructor(cb?: StringStreamHandler) {\n    this.ondata = cb;\n    if (tds) this.t = new TextDecoder();\n    else this.p = et;\n  }\n\n  /**\n   * Pushes a chunk to be decoded from UTF-8 binary\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.ondata) err(5);\n    final = !!final;\n    if (this.t) {\n      this.ondata(this.t.decode(chunk, { stream: true }), final);\n      if (final) {\n        if (this.t.decode().length) err(8);\n        this.t = null;\n      }\n      return;\n    }\n    if (!this.p) err(4);\n    const dat = new u8(this.p.length + chunk.length);\n    dat.set(this.p);\n    dat.set(chunk, this.p.length);\n    const [ch, np] = dutf8(dat);\n    if (final) {\n      if (np.length) err(8);\n      this.p = null;\n    } else this.p = np;\n    this.ondata(ch, final);\n  }\n\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: StringStreamHandler;\n}\n\n/**\n * Streaming UTF-8 encoding\n */\nexport class EncodeUTF8 {\n  private d: boolean;\n  /**\n   * Creates a UTF-8 decoding stream\n   * @param cb The callback to call whenever data is encoded\n   */\n  constructor(cb?: FlateStreamHandler) {\n    this.ondata = cb;\n  }\n\n  /**\n   * Pushes a chunk to be encoded to UTF-8\n   * @param chunk The string data to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: string, final?: boolean) {\n    if (!this.ondata) err(5);\n    if (this.d) err(4);\n    this.ondata(strToU8(chunk), this.d = final || false);\n  }\n\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n}\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str: string, latin1?: boolean): Uint8Array {\n  if (latin1) {\n    const ar = new u8(str.length);\n    for (let i = 0; i < str.length; ++i) ar[i] = str.charCodeAt(i);\n    return ar;\n  }\n  if (te) return te.encode(str);\n  const l = str.length;\n  let ar = new u8(str.length + (str.length >> 1));\n  let ai = 0;\n  const w = (v: number) => { ar[ai++] = v; };\n  for (let i = 0; i < l; ++i) {\n    if (ai + 5 > ar.length) {\n      const n = new u8(ai + 8 + ((l - i) << 1));\n      n.set(ar);\n      ar = n;\n    }\n    let c = str.charCodeAt(i);\n    if (c < 128 || latin1) w(c);\n    else if (c < 2048) w(192 | (c >> 6)), w(128 | (c & 63));\n    else if (c > 55295 && c < 57344)\n      c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n      w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    else w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n  }\n  return slc(ar, 0, ai);\n}\n\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat: Uint8Array, latin1?: boolean) {\n  if (latin1) {\n    let r = '';\n    for (let i = 0; i < dat.length; i += 16384)\n      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n    return r;\n  } else if (td) return td.decode(dat)\n  else {\n    const [out, ext] = dutf8(dat);\n    if (ext.length) err(8);\n    return out;\n  } \n};\n\n// deflate bit flag\nconst dbf = (l: number) => l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n\n// skip local zip header\nconst slzh = (d: Uint8Array, b: number) => b + 30 + b2(d, b + 26) + b2(d, b + 28);\n\n// read zip header\nconst zh = (d: Uint8Array, b: number, z: boolean) => {\n  const fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n  const [sc, su, off] = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)];\n  return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off] as const;\n}\n\n// read zip64 extra field\nconst z64e = (d: Uint8Array, b: number) => {\n  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2));\n  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)] as const;\n}\n\n// zip header file\ntype ZHF = Omit<ZipInputFile, 'terminate' | 'ondata' | 'filename'>;\n\n// extra field length\nconst exfl = (ex?: ZHF['extra']) => {\n  let le = 0;\n  if (ex) {\n    for (const k in ex) {\n      const l = ex[k].length;\n      if (l > 65535) err(9);\n      le += l + 4;\n    }\n  }\n  return le;\n}\n\n// write zip header\nconst wzh = (d: Uint8Array, b: number, f: ZHF, fn: Uint8Array, u: boolean, c?: number, ce?: number, co?: Uint8Array) => {\n  const fl = fn.length, ex = f.extra, col = co && co.length;\n  let exl = exfl(ex);\n  wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n  if (ce != null) d[b++] = 20, d[b++] = f.os;\n  d[b] = 20, b += 2; // spec compliance? what's that?\n  d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n  const dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n  if (y < 0 || y > 119) err(10);\n  wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n  if (c != null) {\n    wbytes(d, b, f.crc);\n    wbytes(d, b + 4, c);\n    wbytes(d, b + 8, f.size);\n  }\n  wbytes(d, b + 12, fl);\n  wbytes(d, b + 14, exl), b += 16;\n  if (ce != null) {\n    wbytes(d, b, col);\n    wbytes(d, b + 6, f.attrs);\n    wbytes(d, b + 10, ce), b += 14;\n  }\n  d.set(fn, b);\n  b += fl;\n  if (exl) {\n    for (const k in ex) {\n      const exf = ex[k], l = exf.length;\n      wbytes(d, b, +k);\n      wbytes(d, b + 2, l);\n      d.set(exf, b + 4), b += 4 + l;\n    }\n  }\n  if (col) d.set(co, b), b += col;\n  return b;\n}\n\n// write zip footer (end of central directory)\nconst wzf = (o: Uint8Array, b: number, c: number, d: number, e: number) => {\n  wbytes(o, b, 0x6054B50); // skip disk\n  wbytes(o, b + 8, c);\n  wbytes(o, b + 10, c);\n  wbytes(o, b + 12, d);\n  wbytes(o, b + 16, e);\n}\n\n/**\n * A stream that can be used to create a file in a ZIP archive\n */\nexport interface ZipInputFile extends ZipAttributes {\n  /**\n   * The filename to associate with the data provided to this stream. If you\n   * want a file in a subdirectory, use forward slashes as a separator (e.g.\n   * `directory/filename.ext`). This will still work on Windows.\n   */\n  filename: string;\n\n  /**\n   * The size of the file in bytes. This attribute may be invalid after\n   * the file is added to the ZIP archive; it must be correct only before the\n   * stream completes.\n   * \n   * If you don't want to have to compute this yourself, consider extending the\n   * ZipPassThrough class and overriding its process() method, or using one of\n   * ZipDeflate or AsyncZipDeflate.\n   */\n  size: number;\n\n  /**\n   * A CRC of the original file contents. This attribute may be invalid after\n   * the file is added to the ZIP archive; it must be correct only before the\n   * stream completes.\n   * \n   * If you don't want to have to generate this yourself, consider extending the\n   * ZipPassThrough class and overriding its process() method, or using one of\n   * ZipDeflate or AsyncZipDeflate.\n   */\n  crc: number;\n\n  /**\n   * The compression format for the data stream. This number is determined by\n   * the spec in PKZIP's APPNOTE.txt, section 4.4.5. For example, 0 = no\n   * compression, 8 = deflate, 14 = LZMA\n   */\n  compression: number;\n\n  /**\n   * Bits 1 and 2 of the general purpose bit flag, specified in PKZIP's\n   * APPNOTE.txt, section 4.4.4. Should be between 0 and 3. This is unlikely\n   * to be necessary.\n   */\n  flag?: number;\n\n  /**\n   * The handler to be called when data is added. After passing this stream to\n   * the ZIP file object, this handler will always be defined. To call it:\n   * \n   * `stream.ondata(error, chunk, final)`\n   * \n   * error = any error that occurred (null if there was no error)\n   * \n   * chunk = a Uint8Array of the data that was added (null if there was an\n   * error)\n   * \n   * final = boolean, whether this is the final chunk in the stream\n   */\n  ondata?: AsyncFlateStreamHandler;\n  \n  /**\n   * A method called when the stream is no longer needed, for clean-up\n   * purposes. This will not always be called after the stream completes,\n   * so you may wish to call this.terminate() after the final chunk is\n   * processed if you have clean-up logic.\n   */\n  terminate?: AsyncTerminable;\n}\n\ntype AsyncZipDat = ZHF & {\n  // compressed data\n  c: Uint8Array;\n  // filename\n  f: Uint8Array;\n  // comment\n  m?: Uint8Array;\n  // unicode\n  u: boolean;\n};\n\ntype ZipDat = AsyncZipDat & {\n  // offset\n  o: number;\n}\n\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nexport class ZipPassThrough implements ZipInputFile {\n  filename: string;\n  crc: number;\n  size: number;\n  compression: number;\n  os?: number;\n  attrs?: number;\n  comment?: string;\n  extra?: Record<number, Uint8Array>;\n  mtime?: GzipOptions['mtime'];\n  ondata: AsyncFlateStreamHandler;\n  private c: CRCV;\n\n  /**\n   * Creates a pass-through stream that can be added to ZIP archives\n   * @param filename The filename to associate with this data stream\n   */\n  constructor(filename: string) {\n    this.filename = filename;\n    this.c = crc();\n    this.size = 0;\n    this.compression = 0;\n  }\n\n  /**\n   * Processes a chunk and pushes to the output stream. You can override this\n   * method in a subclass for custom behavior, but by default this passes\n   * the data through. You must call this.ondata(err, chunk, final) at some\n   * point in this method.\n   * @param chunk The chunk to process\n   * @param final Whether this is the last chunk\n   */\n  protected process(chunk: Uint8Array, final: boolean) {\n    this.ondata(null, chunk, final);\n  }\n\n  /**\n   * Pushes a chunk to be added. If you are subclassing this with a custom\n   * compression algorithm, note that you must push data from the source\n   * file only, pre-compression.\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.ondata) err(5);\n    this.c.p(chunk);\n    this.size += chunk.length;\n    if (final) this.crc = this.c.d();\n    this.process(chunk, final || false);\n  }\n}\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nexport class ZipDeflate implements ZipInputFile {\n  filename: string;\n  crc: number;\n  size: number;\n  compression: number;\n  flag: 0 | 1 | 2 | 3;\n  os?: number;\n  attrs?: number;\n  comment?: string;\n  extra?: Record<number, Uint8Array>;\n  mtime?: GzipOptions['mtime'];\n  ondata: AsyncFlateStreamHandler;\n  private d: Deflate;\n\n  /**\n   * Creates a DEFLATE stream that can be added to ZIP archives\n   * @param filename The filename to associate with this data stream\n   * @param opts The compression options\n   */\n  constructor(filename: string, opts?: DeflateOptions) {\n    if (!opts) opts = {};\n    ZipPassThrough.call(this, filename);\n    this.d = new Deflate(opts, (dat, final) => {\n      this.ondata(null, dat, final);\n    });\n    this.compression = 8;\n    this.flag = dbf(opts.level);\n  }\n  \n  process(chunk: Uint8Array, final: boolean) {\n    try {\n      this.d.push(chunk, final);\n    } catch(e) {\n      this.ondata(e, null, final);\n    }\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    ZipPassThrough.prototype.push.call(this, chunk, final);\n  }\n}\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nexport class AsyncZipDeflate implements ZipInputFile {\n  filename: string;\n  crc: number;\n  size: number;\n  compression: number;\n  flag: 0 | 1 | 2 | 3;\n  os?: number;\n  attrs?: number;\n  comment?: string;\n  extra?: Record<number, Uint8Array>;\n  mtime?: GzipOptions['mtime'];\n  ondata: AsyncFlateStreamHandler;\n  private d: AsyncDeflate;\n  terminate: AsyncTerminable;\n\n  /**\n   * Creates a DEFLATE stream that can be added to ZIP archives\n   * @param filename The filename to associate with this data stream\n   * @param opts The compression options\n   */\n  constructor(filename: string, opts?: DeflateOptions) {\n    if (!opts) opts = {};\n    ZipPassThrough.call(this, filename);\n    this.d = new AsyncDeflate(opts, (err, dat, final) => {\n      this.ondata(err, dat, final);\n    });\n    this.compression = 8;\n    this.flag = dbf(opts.level);\n    this.terminate = this.d.terminate;\n  }\n  \n  process(chunk: Uint8Array, final: boolean) {\n    this.d.push(chunk, final);\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    ZipPassThrough.prototype.push.call(this, chunk, final);\n  }\n}\n\ntype ZIFE = {\n  // compressed size\n  c: number;\n  // filename\n  f: Uint8Array;\n  // comment\n  o?: Uint8Array;\n  // unicode\n  u: boolean;\n  // byte offset\n  b: number;\n  // header offset\n  h: number;\n  // terminator\n  t: () => void;\n  // turn\n  r: () => void;\n};\n\ntype ZipInternalFile = ZHF & ZIFE;\n\n// TODO: Better tree shaking\n\n/**\n * A zippable archive to which files can incrementally be added\n */\nexport class Zip {\n  private u: ZipInternalFile[];\n  private d: number;\n\n  /**\n   * Creates an empty ZIP archive to which files can be added\n   * @param cb The callback to call whenever data for the generated ZIP archive\n   *           is available\n   */\n  constructor(cb?: AsyncFlateStreamHandler) {\n    this.ondata = cb;\n    this.u = [];\n    this.d = 1;\n  }\n  /**\n   * Adds a file to the ZIP archive\n   * @param file The file stream to add\n   */\n  add(file: ZipInputFile) {\n    if (!this.ondata) err(5);\n    // finishing or finished\n    if (this.d & 2) this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n    else {\n      const f = strToU8(file.filename), fl = f.length;\n      const com = file.comment, o = com && strToU8(com);\n      const u = fl != file.filename.length || (o && (com.length != o.length));\n      const hl = fl + exfl(file.extra) + 30;\n      if (fl > 65535) this.ondata(err(11, 0, 1), null, false);\n      const header = new u8(hl);\n      wzh(header, 0, file, f, u);\n      let chks: Uint8Array[] = [header];\n      const pAll = () => {\n        for (const chk of chks) this.ondata(null, chk, false);\n        chks = [];\n      };\n      let tr = this.d;\n      this.d = 0;\n      const ind = this.u.length;\n      const uf = mrg(file, {\n        f,\n        u,\n        o,\n        t: () => { \n          if (file.terminate) file.terminate();\n        },\n        r: () => {\n          pAll();\n          if (tr) {\n            const nxt = this.u[ind + 1];\n            if (nxt) nxt.r();\n            else this.d = 1;\n          }\n          tr = 1;\n        }\n      } as ZIFE);\n      let cl = 0;\n      file.ondata = (err, dat, final) => {\n        if (err) {\n          this.ondata(err, dat, final);\n          this.terminate();\n        } else {\n          cl += dat.length;\n          chks.push(dat);\n          if (final) {\n            const dd = new u8(16);\n            wbytes(dd, 0, 0x8074B50)\n            wbytes(dd, 4, file.crc);\n            wbytes(dd, 8, cl);\n            wbytes(dd, 12, file.size);\n            chks.push(dd);\n            uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n            if (tr) uf.r();\n            tr = 1;\n          } else if (tr) pAll();\n        }\n      }\n      this.u.push(uf);\n    }\n  }\n\n  /**\n   * Ends the process of adding files and prepares to emit the final chunks.\n   * This *must* be called after adding all desired files for the resulting\n   * ZIP file to work properly.\n   */\n  end() {\n    if (this.d & 2) {\n      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n      return;\n    }\n    if (this.d) this.e();\n    else this.u.push({\n      r: () => {\n        if (!(this.d & 1)) return;\n        this.u.splice(-1, 1);\n        this.e();\n      },\n      t: () => {}\n    } as unknown as ZipInternalFile);\n    this.d = 3;\n  }\n\n  private e() {\n    let bt = 0, l = 0, tl = 0;\n    for (const f of this.u) tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n    const out = new u8(tl + 22);\n    for (const f of this.u) {\n      wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n    }\n    wzf(out, bt, this.u.length, tl, l)\n    this.ondata(null, out, true);\n    this.d = 2;\n  }\n\n  /**\n   * A method to terminate any internal workers used by the stream. Subsequent\n   * calls to add() will fail.\n   */\n  terminate() {\n    for (const f of this.u) f.t();\n    this.d = 2;\n  }\n\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n}\n\n/**\n * Asynchronously creates a ZIP file\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @param cb The callback to call with the generated ZIP archive\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function zip(data: AsyncZippable, opts: AsyncZipOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously creates a ZIP file\n * @param data The directory structure for the ZIP archive\n * @param cb The callback to call with the generated ZIP archive\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function zip(data: AsyncZippable, cb: FlateCallback): AsyncTerminable;\nexport function zip(data: AsyncZippable, opts: AsyncZipOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  const r: FlatZippable<true> = {};\n  fltn(data, '', r, opts as AsyncZipOptions);\n  const k = Object.keys(r);\n  let lft = k.length, o = 0, tot = 0;\n  const slft = lft, files = new Array<AsyncZipDat>(lft);\n  const term: AsyncTerminable[] = [];\n  const tAll = () => {\n    for (let i = 0; i < term.length; ++i) term[i]();\n  }\n  let cbd: FlateCallback = (a, b) => {\n    mt(() => { cb(a, b); });\n  }\n  mt(() => { cbd = cb; });\n  const cbf = () => {\n    const out = new u8(tot + 22), oe = o, cdl = tot - o;\n    tot = 0;\n    for (let i = 0; i < slft; ++i) {\n      const f = files[i];\n      try {\n        const l = f.c.length;\n        wzh(out, tot, f, f.f, f.u, l);\n        const badd = 30 + f.f.length + exfl(f.extra);\n        const loc = tot + badd;\n        out.set(f.c, loc);\n        wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n      } catch(e) {\n        return cbd(e, null);\n      }\n    }\n    wzf(out, o, files.length, cdl, oe);\n    cbd(null, out);\n  }\n  if (!lft) cbf();\n  // Cannot use lft because it can decrease\n  for (let i = 0; i < slft; ++i) {\n    const fn = k[i];\n    const [file, p] = r[fn];\n    const c = crc(), size = file.length;\n    c.p(file);\n    const f = strToU8(fn), s = f.length;\n    const com = p.comment, m = com && strToU8(com), ms = m && m.length;\n    const exl = exfl(p.extra);\n    const compression = p.level == 0 ? 0 : 8;\n    const cbl: FlateCallback = (e, d) => {\n      if (e) {\n        tAll();\n        cbd(e, null);\n      } else {\n        const l = d.length;\n        files[i] = mrg(p, {\n          size,\n          crc: c.d(),\n          c: d,\n          f,\n          m,\n          u: s != fn.length || (m && (com.length != ms)),\n          compression\n        });\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n        if (!--lft) cbf();\n      }\n    }\n    if (s > 65535) cbl(err(11, 0, 1), null);\n    if (!compression) cbl(null, file);\n    else if (size < 160000) {\n      try {\n        cbl(null, deflateSync(file, p));\n      } catch(e) {\n        cbl(e, null);\n      }\n    } else term.push(deflate(file, p, cbl));\n  }\n  return tAll;\n}\n\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data: Zippable, opts?: ZipOptions) {\n  if (!opts) opts = {};\n  const r: FlatZippable<false> = {};\n  const files: ZipDat[] = [];\n  fltn(data, '', r, opts);\n  let o = 0;\n  let tot = 0;\n  for (const fn in r) {\n    const [file, p] = r[fn];\n    const compression = p.level == 0 ? 0 : 8;\n    const f = strToU8(fn), s = f.length;\n    const com = p.comment, m = com && strToU8(com), ms = m && m.length;\n    const exl = exfl(p.extra);\n    if (s > 65535) err(11);\n    const d = compression ? deflateSync(file, p) : file, l = d.length;\n    const c = crc();\n    c.p(file);\n    files.push(mrg(p, {\n      size: file.length,\n      crc: c.d(),\n      c: d,\n      f,\n      m,\n      u: s != fn.length || (m && (com.length != ms)),\n      o,\n      compression\n    }));\n    o += 30 + s + exl + l;\n    tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n  }\n  const out = new u8(tot + 22), oe = o, cdl = tot - o;\n  for (let i = 0; i < files.length; ++i) {\n    const f = files[i];\n    wzh(out, f.o, f, f.f, f.u, f.c.length);\n    const badd = 30 + f.f.length + exfl(f.extra);\n    out.set(f.c, f.o + badd);\n    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n  }\n  wzf(out, o, files.length, cdl, oe);\n  return out;\n}\n\n/**\n * A decoder for files in ZIP streams\n */\nexport interface UnzipDecoder {  \n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n  \n  /**\n   * Pushes a chunk to be decompressed\n   * @param data The data in this chunk. Do not consume (detach) this data.\n   * @param final Whether this is the last chunk in the data stream\n   */\n  push(data: Uint8Array, final: boolean): void;\n\n  /**\n   * A method to terminate any internal workers used by the stream. Subsequent\n   * calls to push() should silently fail.\n   */\n  terminate?: AsyncTerminable\n}\n\n/**\n * A constructor for a decoder for unzip streams\n */\nexport interface UnzipDecoderConstructor {\n  /**\n   * Creates an instance of the decoder\n   * @param filename The name of the file\n   * @param size The compressed size of the file\n   * @param originalSize The original size of the file\n   */\n  new(filename: string, size?: number, originalSize?: number): UnzipDecoder;\n\n  /**\n   * The compression format for the data stream. This number is determined by\n   * the spec in PKZIP's APPNOTE.txt, section 4.4.5. For example, 0 = no\n   * compression, 8 = deflate, 14 = LZMA\n   */\n  compression: number;\n}\n\n/**\n * Streaming file extraction from ZIP archives\n */\nexport interface UnzipFile {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * The name of the file\n   */\n  name: string;\n\n  /**\n   * The compression format for the data stream. This number is determined by\n   * the spec in PKZIP's APPNOTE.txt, section 4.4.5. For example, 0 = no\n   * compression, 8 = deflate, 14 = LZMA. If start() is called but there is no\n   * decompression stream available for this method, start() will throw.\n   */\n  compression: number;\n\n  /**\n   * The compressed size of the file\n   */\n  size?: number;\n\n  /**\n   * The original size of the file\n   */\n  originalSize?: number;\n\n  /**\n   * Starts reading from the stream. Calling this function will always enable\n   * this stream, but ocassionally the stream will be enabled even without\n   * this being called.\n   */\n  start(): void;\n\n  /**\n   * A method to terminate any internal workers used by the stream. ondata\n   * will not be called any further.\n   */\n  terminate: AsyncTerminable\n}\n\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nexport class UnzipPassThrough implements UnzipDecoder {\n  static compression = 0;\n  ondata: AsyncFlateStreamHandler;\n  push(data: Uint8Array, final: boolean) {\n    this.ondata(null, data, final);\n  }\n}\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nexport class UnzipInflate implements UnzipDecoder {\n  static compression = 8;\n  private i: Inflate;\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates a DEFLATE decompression that can be used in ZIP archives\n   */\n  constructor() {\n    this.i = new Inflate((dat, final) => {\n      this.ondata(null, dat, final);\n    });\n  }\n\n  push(data: Uint8Array, final: boolean) {\n    try {\n      this.i.push(data, final);\n    } catch(e) {\n      this.ondata(e, data, final);\n    }\n  }\n}\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nexport class AsyncUnzipInflate implements UnzipDecoder {\n  static compression = 8;\n  private i: AsyncInflate | Inflate;\n  ondata: AsyncFlateStreamHandler;\n  terminate: AsyncTerminable;\n\n  /**\n   * Creates a DEFLATE decompression that can be used in ZIP archives\n   */\n  constructor(_: string, sz?: number) {\n    if (sz < 320000) {\n      this.i = new Inflate((dat, final) => {\n        this.ondata(null, dat, final);\n      });\n    } else {\n      this.i = new AsyncInflate((err, dat, final) => {\n        this.ondata(err, dat, final);\n      });\n      this.terminate = this.i.terminate;\n    }\n  }\n\n  push(data: Uint8Array, final: boolean) {\n    if ((this.i as AsyncInflate).terminate) data = slc(data, 0);\n    this.i.push(data, final);\n  }\n}\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nexport class Unzip {\n  private d: UnzipDecoder;\n  private c: number;\n  private p: Uint8Array;\n  private k: Uint8Array[][];\n  private o: Record<number, UnzipDecoderConstructor>;\n\n  /**\n   * Creates a ZIP decompression stream\n   * @param cb The callback to call whenever a file in the ZIP archive is found\n   */\n  constructor(cb?: UnzipFileHandler) {\n    this.onfile = cb;\n    this.k = [];\n    this.o = {\n      0: UnzipPassThrough\n    };\n    this.p = et;\n  }\n  \n  /**\n   * Pushes a chunk to be unzipped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.onfile) err(5);\n    if (!this.p) err(4);\n    if (this.c > 0) {\n      const len = Math.min(this.c, chunk.length);\n      const toAdd = chunk.subarray(0, len);\n      this.c -= len;\n      if (this.d) this.d.push(toAdd, !this.c);\n      else this.k[0].push(toAdd);\n      chunk = chunk.subarray(len);\n      if (chunk.length) return this.push(chunk, final);\n    } else {\n      let f = 0, i = 0, is: number, buf: Uint8Array;\n      if (!this.p.length) buf = chunk;\n      else if (!chunk.length) buf = this.p;\n      else {\n        buf = new u8(this.p.length + chunk.length)\n        buf.set(this.p), buf.set(chunk, this.p.length);\n      }\n      const l = buf.length, oc = this.c, add = oc && this.d;\n      for (; i < l - 4; ++i) {\n        const sig = b4(buf, i);\n        if (sig == 0x4034B50) {\n          f = 1, is = i;\n          this.d = null;\n          this.c = 0;\n          const bf = b2(buf, i + 6), cmp = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n          if (l > i + 30 + fnl + es) {\n            const chks: Uint8Array[] = [];\n            this.k.unshift(chks);\n            f = 2;\n            let sc = b4(buf, i + 18), su = b4(buf, i + 22);\n            const fn = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n            if (sc == 4294967295) { [sc, su] = dd ? [-2] : z64e(buf, i); }\n            else if (dd) sc = -1;\n            i += es;\n            this.c = sc;\n            let d: UnzipDecoder;\n            const file = {\n              name: fn,\n              compression: cmp,\n              start: () => {\n                if (!file.ondata) err(5);\n                if (!sc) file.ondata(null, et, true);\n                else {\n                  const ctr = this.o[cmp];\n                  if (!ctr) file.ondata(err(14, 'unknown compression type ' + cmp, 1), null, false);\n                  d = sc < 0 ? new ctr(fn) : new ctr(fn, sc, su);\n                  d.ondata = (err, dat, final) => { file.ondata(err, dat, final); }\n                  for (const dat of chks) d.push(dat, false);\n                  if (this.k[0] == chks && this.c) this.d = d;\n                  else d.push(et, true);\n                }\n              },\n              terminate: () => {\n                if (d && d.terminate) d.terminate();\n              }\n            } as UnzipFile;\n            if (sc >= 0) file.size = sc, file.originalSize = su;\n            this.onfile(file);\n          }\n          break;\n        } else if (oc) {\n          if (sig == 0x8074B50) {\n            is = i += 12 + (oc == -2 && 8), f = 3, this.c = 0;\n            break;\n          } else if (sig == 0x2014B50) {\n            is = i -= 4, f = 3, this.c = 0;\n            break;\n          }\n        }\n      }\n      this.p = et\n      if (oc < 0) {\n        const dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n        if (add) add.push(dat, !!f);\n        else this.k[+(f == 2)].push(dat);\n      }\n      if (f & 2) return this.push(buf.subarray(i), final);\n      this.p = buf.subarray(i);\n    }\n    if (final) {\n      if (this.c) err(13);\n      this.p = null;\n    }\n  }\n\n  /**\n   * Registers a decoder with the stream, allowing for files compressed with\n   * the compression type provided to be expanded correctly\n   * @param decoder The decoder constructor\n   */\n  register(decoder: UnzipDecoderConstructor) {\n    this.o[decoder.compression] = decoder;\n  }\n\n  /**\n   * The handler to call whenever a file is discovered\n   */\n  onfile: UnzipFileHandler;\n}\n\nconst mt = typeof queueMicrotask == 'function' ? queueMicrotask : setTimeout;\n\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data: Uint8Array, cb: UnzipCallback): AsyncTerminable {\n  if (typeof cb != 'function') err(7);\n  const term: AsyncTerminable[] = [];\n  const tAll = () => {\n    for (let i = 0; i < term.length; ++i) term[i]();\n  }\n  const files: Unzipped = {};\n  let cbd: UnzipCallback = (a, b) => {\n    mt(() => { cb(a, b); });\n  }\n  mt(() => { cbd = cb; });\n  let e = data.length - 22;\n  for (; b4(data, e) != 0x6054B50; --e) {\n    if (!e || data.length - e > 65558) {\n      cbd(err(13, 0, 1), null);\n      return tAll;\n    }\n  };\n  let lft = b2(data, e + 8);\n  if (lft) {\n    let c = lft;\n    let o = b4(data, e + 16);\n    const z = o == 4294967295;\n    if (z) {\n      e = b4(data, e - 12);\n      if (b4(data, e) != 0x6064B50) {\n        cbd(err(13, 0, 1), null);\n        return tAll;\n      }\n      c = lft = b4(data, e + 32);\n      o = b4(data, e + 48);\n    }\n    for (let i = 0; i < c; ++i) {\n      const [c, sc, su, fn, no, off] = zh(data, o, z), b = slzh(data, off);\n      o = no\n      const cbl: FlateCallback = (e, d) => {\n        if (e) {\n          tAll();\n          cbd(e, null);\n        } else {\n          files[fn] = d;\n          if (!--lft) cbd(null, files);\n        }\n      }\n      if (!c) cbl(null, slc(data, b, b + sc))\n      else if (c == 8) {\n        const infl = data.subarray(b, b + sc);\n        if (sc < 320000) {\n          try {\n            cbl(null, inflateSync(infl, new u8(su)));\n          } catch(e) {\n            cbl(e, null);\n          }\n        }\n        else term.push(inflate(infl, { size: su }, cbl));\n      } else cbl(err(14, 'unknown compression type ' + c, 1), null);\n    }\n  } else cbd(null, {});\n  return tAll;\n}\n\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data: Uint8Array) {\n  const files: Unzipped = {};\n  let e = data.length - 22;\n  for (; b4(data, e) != 0x6054B50; --e) {\n    if (!e || data.length - e > 65558) err(13);\n  };\n  let c = b2(data, e + 8);\n  if (!c) return {};\n  let o = b4(data, e + 16);\n  const z = o == 4294967295;\n  if (z) {\n    e = b4(data, e - 12);\n    if (b4(data, e) != 0x6064B50) err(13);\n    c = b4(data, e + 32);\n    o = b4(data, e + 48);\n  }\n  for (let i = 0; i < c; ++i) {\n    const [c, sc, su, fn, no, off] = zh(data, o, z), b = slzh(data, off);\n    o = no;\n    if (!c) files[fn] = slc(data, b, b + sc);\n    else if (c == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n    else err(14, 'unknown compression type ' + c);\n  }\n  return files;\n}","// @ts-nocheck\n\nimport { strFromU8, strToU8, zlibSync } from '../fflate';\nimport { PackFn, MARK, eventWithTimeAndPacker } from './base';\n\nexport const pack: PackFn = (event) => {\n  const _e: eventWithTimeAndPacker = {\n    ...event,\n    v: MARK,\n  };\n  return strFromU8(zlibSync(strToU8(JSON.stringify(_e))), true);\n};\n","import { eventWithTime } from '../types';\n\nexport type PackFn = (event: eventWithTime) => string;\nexport type UnpackFn = (raw: string) => eventWithTime;\n\nexport type eventWithTimeAndPacker = eventWithTime & {\n  v: string;\n};\n\nexport const MARK = 'v1';\n","import { AskLevel } from \"../types/types\"\nimport { config } from \"../config/config\"\nimport { W } from \"../constants\"\nimport record from \"../rrweb/record\"\nimport { pack } from \"../rrweb/packer\"\nimport { eventWithTime } from \"../rrweb/types\"\nimport { warn } from \"../utils/console\"\n/**\n * Error Trap\n */\n\nexport default class ErrorTrace {\n  private static instance: ErrorTrace | null = null\n  private eventsMatrix: Array<Array<eventWithTime>> = [[]]\n\n  private constructor() {\n    this.globalErrorTrace()\n    this.networkErrorTrace()\n    this.promiseErrorTrace()\n    this.iframeErrorTrace()\n    record({\n      ...config.recordOptions,\n      emit: (event, isCheckout) => {\n        if (isCheckout) {\n          this.eventsMatrix.push([]);\n        }\n        const lastEvents = this.eventsMatrix[this.eventsMatrix.length - 1];\n        lastEvents.push(event);\n      },\n      recordLog: false,\n      checkoutEveryNth: 10,\n      packFn: pack,\n    })\n  }\n\n  public static getInstance(): ErrorTrace {\n    if (!this.instance) {\n      this.instance = new ErrorTrace()\n    }\n    return this.instance\n  }\n\n  /**\n   * Globally catch synchronous or asynchronous errors\n   * 捕获异常的能力比try-catch稍微强点，无论是异步还是非异步，onerror都能捕获到运行时错误，返回true就不回报红\n   * 当时当<img src=\"\" />这种情况是捕获不到的\n   * 使用未使用的变量\n   */\n  private globalErrorTrace(): void {\n    W.onerror = (\n      event: Event | string,\n      source?: string,\n      lineno?: number,\n      colno?: number,\n      error?: Error\n    ) => {\n\n      warn({\n        source,\n        lineno,\n        colno,\n        error,\n      })\n\n      const len = this.eventsMatrix.length;\n\n      if (config.errEventRoute && len >= 2) {\n        const events = this.eventsMatrix[len - 2].concat(this.eventsMatrix[len - 1]);\n        config.reportData?.fetch(\n          AskLevel.IDLE,\n          JSON.stringify({ events }),\n          config.errEventRoute\n        )\n      }\n\n      if (config.errLogRoute) {\n        config.reportData?.fetch(\n          AskLevel.IDLE,\n          JSON.stringify({\n            source,\n            lineno,\n            colno,\n            error: JSON.stringify({\n              message: error?.message,\n              stack: error?.stack,\n              name: error?.name,\n            }),\n          }),\n          config.errLogRoute\n        )\n      }\n      return true\n    }\n  }\n  /**\n   * Catch network errors\n   * 图片加载失败等\n   */\n  private networkErrorTrace(): void {\n    W.addEventListener(\n      \"error\",\n      (e: ErrorEvent) => {\n        if (e.target !== W) {\n          warn(e.target)\n        }\n      },\n      true\n    )\n  }\n\n  /**\n   * Catching Promise errors\n   */\n  private promiseErrorTrace(): void {\n    window.addEventListener(\"unhandledrejection\", (e) => {\n      e.preventDefault()\n      warn(e.reason)\n      return true\n    })\n  }\n\n  private iframeErrorTrace(): void {\n    const frames = W.frames\n    for (let i = 0; i < frames.length; i++) {\n      frames[i].addEventListener(\n        \"error\",\n        (e: ErrorEvent) => {\n          warn(e)\n        },\n        true\n      )\n      frames[i].addEventListener(\n        \"unhandledrejection\",\n        (e) => {\n          warn(e)\n        },\n        true\n      )\n    }\n  }\n}\n","import { AskLevel, ReportDataAchieve } from \"../types/types\"\nimport { W, WN } from \"../constants\"\nimport { config } from \"../config/config\"\n\nexport interface ReportDataOptions {\n  logDomain: string | undefined,\n}\n\n/**\n * Log collection\n * 日志收集\n */\nexport default class ReportData implements ReportDataAchieve {\n  /**\n   * Log report, error report\n   * If the level is urgent, use http request directly, otherwise use navigator.sendBeacon\n   * 日志上报、错误上报\n   * 如果level很紧急，直接使用http请求，否者使用navigator.sendBeacon\n   * @param level\n   * @param body \n   * @param uri \n   */\n  public fetch(level: AskLevel, body: string, uri: string): void {\n    uri = config.fetchDomain + uri\n\n    switch (level) {\n      case AskLevel.URGENT: {\n        if (!!W.fetch) {\n          fetch(uri, { body, method: \"POST\", keepalive: true })\n        } else {\n          let xhr: XMLHttpRequest | null = new XMLHttpRequest()\n          xhr.open(\"post\", uri, true)\n          xhr.setRequestHeader(\"Content-Type\", \"application/json\")\n          xhr.send(body)\n          xhr.onload = () => xhr = null // 防止内存泄漏\n        }\n        return\n      }\n      default:\n        if (!!WN.sendBeacon) {\n          navigator.sendBeacon(uri, body)\n        } else {\n          let image: HTMLImageElement | null = new Image()\n          image.src = `${uri}?body=${body}`\n          image.onload = () => image = null // 防止内存泄漏\n        }\n    }\n  }\n}","import { W, WP } from \"../constants\"\n\n/**\n * Determine whether the browser supports getEntriesByType\n * @returns \n */\nexport const isPerformanceSupported = (): boolean => {\n  return WP && !!WP.getEntriesByType && !!WP.now && !!WP.mark\n}\n\n/**\n * bytes to kb\n * @param {number} bytes\n */\nexport const bytes2kb = (bytes: number) => {\n  return parseFloat((bytes / Math.pow(1024, 2)).toFixed(2))\n}\n\n/**\n * Keep two decimal places\n * @param {number} num\n * @returns \n */\nexport const roundByTwo = (num: number) => {\n  return parseFloat(num.toFixed(2))\n}\n\n/**\n * PushTask to requestIdleCallback\n * Efficient use of each frame for data collection\n * @param {() => void} callback\n */\nexport const pushTask = (callback: () => void) => {\n  if (\"requestIdleCallback\" in W) {\n    (W as any).requestIdleCallback(callback, { timeout: 3000 })\n  } else {\n    callback()\n  }\n}","import { bytes2kb } from \"../utils/helper\"\nimport { WN } from \"../constants\"\nimport type { StorageOpt } from \"../types/types\"\n\n/**\n  * Record local cache information\n*/\n\nexport const recordingStorage = async (): Promise<StorageOpt> => {\n  if (!WN.storage) return { usageDetails: {} }\n\n  const { quota, usage, usageDetails } = await WN.storage.estimate() as StorageOpt\n  let res = {\n    quota: bytes2kb(quota || 0),\n    usage: bytes2kb(usage || 0),\n    usageDetails,\n  }\n  if (res.usageDetails) {\n    Object.keys(res.usageDetails || {}).forEach(key => res.usageDetails[key] = bytes2kb(res.usageDetails[key]))\n  }\n  return res\n}","import { WN } from \"../constants\"\nimport type { EffectiveType, NavigatorOpt } from \"../types/types\"\nimport { pushTask } from \"../utils/helper\"\n\nexport let effectiveType: EffectiveType = \"4g\"\nexport let saveData: boolean = false\n\n/**\n   * Get user's browser information, internet speed and other information\n   * Calculating network speed formula\n   * T1 = DNS + New Connection(TCP) + RTT(One-time transmission)\n   * T2 = New Connection(TCP) + RTT(One-time transmission)\n   * T3 = RTT(One-time transmission)\n   * bandwidth = (100k-50k)/(t5-t4)\n   * @return {NavigatorOpt}\n   */\nexport const recordClientNavigator = async (): Promise<NavigatorOpt> => {\n  return new Promise(resolve => {\n    let res = {} as NavigatorOpt\n    if (\"connection\" in WN) {\n      res.connection = {\n        downlink: WN.connection.downlink,\n        effectiveType: WN.connection.effectiveType,\n        rtt: WN.connection.rtt,\n        saveData: WN.connection.saveData,\n      }\n      saveData = res.connection.saveData || saveData\n      effectiveType = res.connection.effectiveType || effectiveType\n    }\n    // Doppler Velocity\n    if (\"fetch\" in window) {\n      pushTask(async () => {\n        let times = []\n        const sizes = [0, 0, 0, 50, 100]\n        const fetchs = sizes.map(i => (() => new Promise(async resolve => {\n          await fetch(`http://performance-monitoring.zhourengui.top/performance-monitoring/doppler-velocity?size=${i}`)\n          resolve(true)\n        })))\n\n        times.push(+ new Date())\n\n        while (fetchs.length) {\n          const f = fetchs.shift()\n          await f?.()\n          times.push(+ new Date())\n        }\n        res.connection.bandwidth = `${((sizes[4] - sizes[3]) / ((times[5] - times[4]) / 1000)).toFixed(2)} k/s`\n        resolve(res)\n      })\n    }\n\n    res.userAgent = WN.userAgent\n  })\n}","import { WP } from \"../constants\"\nimport { isPerformanceSupported } from \"../utils/helper\"\nimport type { TimingOpt } from \"../types/types\"\n/**\n  * Navigation Timing API provides performance metrics for HTML documents.\n  * w3c.github.io/navigation-timing/\n  * developers.google.com/web/fundamentals/performance/navigation-and-resource-timing\n  */\nexport const recordTiming = async (): Promise<TimingOpt> => {\n  let res = {} as TimingOpt\n  if (isPerformanceSupported()) {\n    // There is an open issue to type correctly getEntriesByType\n    // github.com/microsoft/TypeScript/issues/33866\n    const n = WP.getEntriesByType(\"navigation\")[0] as any\n    if (n) {\n      const responseEnd = n.responseEnd\n      const responseStart = n.responseStart\n      const requestStart = n.requestStart\n      res = {\n        // fetchStart marks when the browser starts to fetch a resource\n        // responseEnd is when the last byte of the response arrives\n        fetchTime: responseEnd - n.fetchStart,\n        // Service worker time plus response time\n        workerTime: responseEnd - n.workerStart,\n        // Request plus response time (network only)\n        networkTime: responseEnd - requestStart,\n        // Response time only (download)\n        downloadTime: responseEnd - responseStart,\n        // Time to First Byte (TTFB)\n        timeToFirstByte: responseStart - requestStart,\n        // HTTP header size\n        headerSize: n.decodedBodySize - n.transferSize || 0,\n        // DNS Lookup Time\n        dnsLookupTime: n.domainLookupStart - n.domainLookupEnd,\n        // TCP time\n        tcpTime: n.connectStart - n.connectEnd || 0,\n        // First paint\n        firstPaintTime: responseEnd - responseStart || 0,\n        // Dom Parse Time\n        domParseTime: n.domComplete - n.domInteractive,\n        // Dom Render Time\n        domRenderTime: n.domContentLoadedEventEnd - n.domContentLoadedEventStart || 0,\n        // onload time\n        onloadTime: n.loadEventEnd - n.loadEventStart\n      }\n    }\n  }\n\n  return res\n}","import { WN } from \"../constants\"\nimport { effectiveType, saveData } from \"../performance/record-client-navigator\"\nimport { EffectiveType, NavigatorInformation } from \"../types/types\"\n\nexport const isLowEndDevice = (): boolean => {\n  return WN.deviceMemory <= 4 || WN.hardwareConcurrency <= 4\n}\n\nexport const isLowEndExperience = (\n  effectiveType: EffectiveType,\n  saveData: boolean\n): boolean => {\n  if ([\"slow-2g\", \"2g\", \"3g\"].includes(effectiveType)) {\n    return true\n  }\n\n  return isLowEndDevice() || saveData\n}\n\n/**\n * 信息来源于 window.navigator:\n * 1. Device Memory 设备内存\n * 2. Hardware Concurency 并发数\n * 3. Status of the service worker:\n *     - controlled: a service worker is controlling the page\n *     - supported: the browser supports service worker\n *     - unsupported: the user's browser does not support service worker\n */\nexport const getNavigatorInformation = (): NavigatorInformation | undefined => {\n  if (WN) {\n    return {\n      deviceMemory: WN.deviceMemory || 0,\n      hardwareConcurrency: WN.hardwareConcurrency || 0,\n      serviceWorkerStatus:\n        'serviceWorker' in WN\n          ? WN.serviceWorker?.controller\n            ? \"controlled\"\n            : \"supported\"\n          : \"unsupported\",\n      isLowEndDevice: isLowEndDevice(),\n      isLowEndExperience: isLowEndExperience(effectiveType, saveData)\n    }\n  }\n}","import { NavigatorOpt, TimingOpt, VitalsScore } from \"../types/types\";\n\n/**\n * https://web.dev/vitals/\n * https://web.dev/cls/\n */\nconst fcpScore = [1000, 2500];\nconst lcpScore = [2500, 4000];\nconst fidcore = [100, 300];\nconst clsScore = [0.1, 0.25];\nconst tbtScore = [300, 600];\n\nexport const webVitalsScore: Record<string, number[]> = {\n  fp: fcpScore,\n  fcp: fcpScore,\n  lcp: lcpScore,\n  lcpFinal: lcpScore,\n  fid: fidcore,\n  fidVitals: fidcore,\n  cls: clsScore,\n  clsFinal: clsScore,\n  tbt: tbtScore,\n  tbt5S: tbtScore,\n  tbt10S: tbtScore,\n  tbtFinal: tbtScore,\n};\n\nexport const getVitalsScore = (\n  measureName: string,\n  value: number\n): VitalsScore => {\n  if (!webVitalsScore[measureName]) {\n    return null\n  }\n\n  if (value <= webVitalsScore[measureName][0]) {\n    return \"good\"\n  }\n\n  return value <= webVitalsScore[measureName][1] ? \"needsImprovement\" : \"poor\"\n}","import { config } from \"../config/config\"\nimport { D } from \"../constants\"\nimport { NavigatorOpt, TimingOpt } from \"../types/types\"\nimport { pushTask } from \"./helper\"\nimport { getNavigatorInformation } from \"./navigator-information\"\nimport { getVitalsScore } from \"./vitals-score\"\n\n/**\n * Sends the User timing measure to analyticsTracker\n * Do not report specific data when the page is hidden\n * @param {string} measureName\n * @param {number} duration\n * @param {object} eventProperties\n */\nexport const reportPerformance = (\n  data: TimingOpt | number | NavigatorOpt | any,\n  measureName: string,\n  eventProperties?: object\n): void => {\n  pushTask(() => {\n    if (D.visibilityState === \"hidden\" && !measureName.includes(\"Final\") || !config.analyticsTracker) return\n    config.analyticsTracker({\n      metricName: measureName,\n      data,\n      eventProperties,\n      navigatorInformation: getNavigatorInformation(),\n      vitalsScore: getVitalsScore(measureName, data as number)\n    })\n  })\n}","import { config } from \"../config/config\"\nimport { roundByTwo } from \"./helper\"\nimport { reportPerformance } from \"./report-performance\"\n\n/**\n * Sends the metric to an external tracking service\n * 将指标发送到外部跟踪服务\n * @param {string} measureName \n * @param {{[key: string]: any}} metric \n * @param {object} customProperties \n */\nexport const logData = (\n  measureName: string,\n  metric: { [key: string]: any },\n  customProperties?: object\n): void => {\n  Object.keys(metric).forEach((key) => {\n    if (typeof metric[key] === 'number') {\n      metric[key] = roundByTwo(metric[key]);\n    }\n  });\n  reportPerformance(metric, measureName, customProperties);\n};\n\n/**\n * Dispatches the metric duration into internal logs\n * and the external time tracking service.\n * @param {string} measureName\n * @param {number} duration\n * @param {object} customProperties\n */\nexport const logMetric = (\n  measureName: string,\n  duration: number,\n  customProperties?: object\n) => {\n  const duration2decimal = roundByTwo(duration)\n  if (duration2decimal <= (config.maxTime as number)) {\n    reportPerformance(duration, measureName, customProperties)\n  }\n}","import { ResourceTime } from \"../types/types\";\n\n// first-pait\nexport const fp = {\n  value: 0\n}\n\n// first-contentful-paint\nexport const fcp = {\n  value: 0\n}\n\n// block-time\nexport const bt = {\n  value: 0\n}\n\n// largest-contentful-paint\nexport const lcp = {\n  value: 0\n}\n\n// resource-time\nexport const rt: { value: ResourceTime } = {\n  value: {\n    beacon: 0,\n    css: 0,\n    fetch: 0,\n    img: 0,\n    other: 0,\n    script: 0,\n    total: 0,\n    xmlhttprequest: 0,\n  },\n};\n\n// cumulative-layout-shift\nexport const cls = {\n  value: 0\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logMetric } from \"../utils/log\"\nimport { fcp, fp, lcp } from \"../utils/metrics\"\nimport { disconnectPO } from \"./performance-observer\"\n\n/**\n * FirstPaintObserverCallback\n * @returns \n */\nexport const initFirstPaint = (\n  callback: () => void\n) => (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (entry.name === \"first-paint\") {\n      fp.value = entry.startTime\n      logMetric(\"fp\", entry.startTime)\n    } else if (entry.name === \"first-contentful-paint\") {\n      fcp.value = entry.startTime\n      logMetric(\"fcp\", entry.startTime)\n      callback()\n      disconnectPO(\"paint\")\n    }\n  }\n}\n\n/**\n * LargestContentfulPaintObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries \n */\nexport const initLargestContentfulPaint = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry) {\n    lcp.value = lastEntry.renderTime || lastEntry.startTime\n  }\n}\n\n/**\n * ElementTimingObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries\n */\nexport const initElementTiming = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (entry.identifier) {\n      logMetric(entry.identifier, entry.startTime, {\n        performanceEntry: entry\n      })\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logMetric } from \"../utils/log\"\nimport { bt, fcp } from \"../utils/metrics\"\n\n/**\n * LongtaskObserverCallback\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Long_Tasks_API\n * The definition of a long task is a task longer than 50ms\n * 长任务的定义是超过50ms的任务\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns \n */\nexport const initLongtask = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    const blockingTime = entry.startTime - 50\n    if (entry.name !== \"self\" && entry.startTime < fcp.value) return\n    if (blockingTime > 0) {\n      bt.value += entry.startTime\n      logMetric(\"longtask\", entry.startTime)\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logData, logMetric } from \"../utils/log\"\nimport { bt, cls, lcp, rt } from \"../utils/metrics\"\nimport { disconnectPO, performanceObserverInstance } from \"./performance-observer\"\n\n/**\n * FirstInputObserverCallback\n * Take the last entry\n * @param {Array<PerformanceEntryEncapsulation>} entries\n */\nexport const initFirstInput = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry) {\n    // Core Web Vitals FID logic\n    // Delayed operation of measurement input events\n    // 测量输入事件的延迟操作\n    logMetric(\n      \"fidVitals\",\n      lastEntry.processingStart - lastEntry.startTime,\n      {\n        performanceEntry: lastEntry\n      }\n    )\n\n    // Measure the duration of processing the first input event\n    // 测量处理第一个输入事件的持续时间\n    logMetric(\n      \"fid\",\n      lastEntry.duration,\n      {\n        performanceEntry: lastEntry\n      }\n    )\n  }\n\n  // Destroy the registered callback for FID to avoid memory leaks caused by too many observers\n  // 销毁对FID的注册回调 避免过多的观察者造成内存泄露\n  disconnectPO(\"first-input\")\n\n  // lcp log\n  logMetric(\"lcp\", lcp.value)\n\n  // Force any pending records to be dispatched\n  // 强制分派所有待处理的记录\n  if (\n    performanceObserverInstance[\"layout-shift\"] &&\n    typeof performanceObserverInstance[\"layout-shift\"].takeRecords === \"function\"\n  ) {\n    performanceObserverInstance[\"layout-shift\"].takeRecords()\n  }\n\n  // cls log\n  logMetric(\"cls\", cls.value)\n\n  // bt log\n  logMetric(\"bt\", bt.value)\n\n  // TBT with 5 second delay after FID\n  setTimeout(() => {\n    logMetric(\"bt5S\", bt.value)\n  }, 5000)\n\n  // TBT with 10 second delay after FID\n  // 10S overall data consumption after FID is activated\n  setTimeout(() => {\n    logMetric(\"bt10S\", bt.value)\n    logData(\"dataConsumption\", rt.value)\n  }, 10000)\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logData, logMetric } from \"../utils/log\"\nimport { bt, fcp, rt } from \"../utils/metrics\"\n\n/**\n * ResouceTimingObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns \n */\nexport const initResouceTiming = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n\n    logData(\"resourceTiming\", entry)\n\n    if (entry.decodedBodySize && entry.initiatorType) {\n      const bodySize = entry.decodedBodySize / 1000\n      rt.value[entry.initiatorType] += bodySize\n      rt.value.total += bodySize\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\";\nimport { cls } from \"../utils/metrics\";\n\n/**\n * https://web.dev/cls/\n * https://requestmetrics.com/web-performance/cumulative-layout-shift\n * \n * Cumulative Layout Shift (CLS), \n * sometimes known as jank, \n * is a measurement of how much elements move due to late-rendered content.\n * You can think of it as a measurement of layout instability. \n * It has become a common problem for many websites due to third-party scripts and tag management and its one of the new Core Web Vital metrics.\n * \n * LayoutShiftObserverCallback\n * Detects new layout shift occurrences and updates the\n * Only count layout shifts without recent user input.\n * 检测新的布局偏移情况并更新\n * 仅在没有最近用户输入的情况下计算布局转移。\n * \n * What is a good CLS score?\n * To provide a good user experience, sites should strive to have a CLS score of 0.1 or less. To ensure you're hitting this target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices.\n * 为了提供良好的用户体验，网站应努力使CLS得分不超过0.1。为确保您达到大多数用户的这一目标，衡量移动设备和台式机设备的页面加载量的第75个百分位数是一个很好的衡量标准。\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns\n */\nexport const initLayoutShift = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry && !lastEntry.hadRecentInput && lastEntry.value) {\n    cls.value += lastEntry.value\n  }\n}","import { PerformanceEntryEncapsulation, PerformanceObserverEventType, PerformanceObservers } from \"../types/types\"\nimport { name } from \"../../package.json\"\nimport { C } from \"../constants\"\nimport { initElementTiming, initFirstPaint, initLargestContentfulPaint } from \"./paint\"\nimport { initLongtask } from \"./longtask\"\nimport { initFirstInput } from \"./first-input\"\nimport { config } from \"../config/config\"\nimport { initResouceTiming } from \"./resource\"\nimport { initLayoutShift } from \"./layout-shift\"\nimport { logMetric } from \"../utils/log\"\nimport { bt, cls, lcp } from \"../utils/metrics\"\n\nexport const performanceObserverInstance: PerformanceObservers = {}\n\n/**\n * PerformanceObserver asynchronous subscription\n * PerformanceObserver异步订阅\n * @param {PerformanceObserverEventType} eventType 监听的事件类型 Types of events monitored\n * @param {(entries: Array<PerformanceEntryEncapsulation>) => void} callback 监听的回调 Listened callback\n */\nconst asyncSubscripePO = (\n  eventType: PerformanceObserverEventType,\n  callback: (entries: Array<PerformanceEntryEncapsulation>) => void\n): PerformanceObserver | null => {\n  try {\n    const Observer = new PerformanceObserver(\n      (entries) =>\n        callback(\n          entries.getEntries() as Array<PerformanceEntryEncapsulation>\n        )\n    )\n    Observer.observe({ type: eventType, buffered: true })\n    return Observer\n  } catch (error) {\n    C.warn(\"PerformanceMonitoring obsever🌲:\",`${name}: ${error}`);\n  }\n  return null\n}\n\n/**\n * Cancel the monitoring of PerformanceObserver\n * 取消PerformanceObserver的监听\n * @param {string} eventType 监听的事件类型 Types of events monitored\n */\nexport const disconnectPO = (eventType: string) => {\n  if (performanceObserverInstance[eventType]) {\n    performanceObserverInstance[eventType]?.disconnect()\n  }\n  delete performanceObserverInstance[eventType]\n}\n\n/**\n * PerformanceObserver initialization\n * PerformanceObserver初始化\n * paint: fp、fcp、largest-contentful-paint\n * longtask\n * first-input\n */\nexport const initPerformanceObserver = (): void => {\n  performanceObserverInstance[\"paint\"] = asyncSubscripePO(\n    \"paint\",\n    initFirstPaint(\n      () => performanceObserverInstance[\"longtask\"] = asyncSubscripePO(\"longtask\", initLongtask)\n    )\n  )\n\n  performanceObserverInstance[\"first-input\"] = asyncSubscripePO(\n    \"first-input\",\n    initFirstInput\n  )\n\n  performanceObserverInstance[\"largest-contentful-paint\"] = asyncSubscripePO(\n    \"largest-contentful-paint\",\n    initLargestContentfulPaint\n  )\n\n  // Collect page performance data\n  // 收集页面性能数据\n  if (config.isObserverResourceTiming) {\n    asyncSubscripePO(\"resource\", initResouceTiming)\n  }\n\n  performanceObserverInstance[\"layout-shift\"] = asyncSubscripePO(\n    \"layout-shift\",\n    initLayoutShift\n  )\n\n  if (config.isObserverElementTiming) {\n    asyncSubscripePO(\"element\", initElementTiming)\n  }\n}\n\n\nexport const disconnectPerformanceObserver = (): void => {\n  if (performanceObserverInstance[\"largest-contentful-paint\"]) {\n    logMetric(\"lcpFinal\", lcp.value)\n    disconnectPO(\"largest-contentful-paint\")\n  }\n\n  if (performanceObserverInstance[\"layout-shift\"]) {\n    // Force any pending records to be dispatched\n    // 强制分派所有待处理的记录\n    if (typeof performanceObserverInstance[\"layout-shift\"].takeRecords === \"function\") {\n      performanceObserverInstance[\"layout-shift\"].takeRecords()\n    }\n    logMetric(\"clsFinal\", cls.value)\n    disconnectPO(\"layout-shift\")\n  }\n\n  if (performanceObserverInstance[\"longtask\"]) {\n    logMetric(\"btFinal\", bt.value)\n    disconnectPO(\"longtask\")\n  }\n}","import ErrorTrace from \"./error-trace\"\nimport ReportData from \"./utils/ReportData\"\nimport { recordingStorage } from \"./performance/record-storage\"\nimport { version } from \"../package.json\"\nimport { config } from \"./config/config\"\nimport { recordClientNavigator } from \"./performance/record-client-navigator\"\nimport { recordTiming } from \"./performance/record-timing\"\nimport { isPerformanceSupported } from \"./utils/helper\"\nimport { AskLevel, PerformanceMonitoringOptions } from \"./types/types\"\nimport { disconnectPerformanceObserver, initPerformanceObserver } from \"./performance/performance-observer\"\nimport { D } from \"./constants\"\nimport { log } from \"./utils/console\"\n\n/**\n * A performance monitoring platform SDK\n * Features include error capture, error recording, performance monitoring\n * 功能包括错误捕获、错误录制、性能监控\n * 一款性能监控平台SDK\n * @packageDocumentation\n */\nexport default class PerformanceMonitoring {\n  constructor(options: PerformanceMonitoringOptions = {}) {\n    const {\n      isObserverElementTiming,\n      isObserverResourceTiming,\n      maxTime,\n      captureError,\n      fetchDomain,\n      errLogRoute,\n      errEventRoute,\n      logRoute,\n      analyticsTracker,\n      recordOptions,\n    } = options\n\n    config.isObserverElementTiming = !!isObserverElementTiming\n    config.isObserverResourceTiming = !!isObserverResourceTiming\n    config.maxTime = maxTime || config.maxTime\n    config.captureError = captureError || config.captureError\n    config.fetchDomain = fetchDomain\n    config.errLogRoute = errLogRoute\n    config.errEventRoute = errEventRoute\n    config.logRoute = logRoute\n    config.reportData = new ReportData()\n    config.analyticsTracker = analyticsTracker || config.analyticsTracker\n    config.recordOptions = recordOptions || config.recordOptions\n\n    log(version)\n\n    if (captureError && fetchDomain) {\n      ErrorTrace.getInstance()\n    }\n\n    if (isPerformanceSupported()) {\n\n      if (D.visibilityState === \"hidden\") {\n        D.addEventListener(\n          \"visibilitychange\",\n          disconnectPerformanceObserver\n        )\n      }\n\n      if (fetchDomain && logRoute) {\n        Promise.all([\n          recordTiming(),\n          recordClientNavigator(),\n          recordingStorage()\n        ]).then(res => {\n          config.reportData?.fetch(\n            AskLevel.IDLE,\n            JSON.stringify(res),\n            logRoute\n          )\n        })\n      }\n\n      initPerformanceObserver()\n    }\n  }\n}"],"names":["AskLevel","NodeType","W","window","WP","performance","WN","navigator","C","console","D","document","prefix","log","message","warn","config","isObserverResourceTiming","isObserverElementTiming","maxTime","captureError","reportData","analyticsTracker","options","recordOptions","isShadowRoot","n","host","Boolean","shadowRoot","_id","tagNameRegex","RegExp","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","isCSSImportRule","styleSheet","cssText","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","url","filePath","maybeQuote","test","indexOf","split","slice","stack","parts","pop","part","push","EventType","IncrementalSource","MouseInteractions","ReplayerEvents","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","transformAttribute","tagName","name","value","pos","collectCharacters","regEx","chars","match","exec","substring","length","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","nodeType","ELEMENT_NODE","classList","contains","forEach","className","matches","parentNode","lowerIfExists","maybeAttr","undefined","toLowerCase","serializeNodeWithId","id","blockClass","blockSelector","skipChild","inlineStylesheet","maskInputOptions","maskTextFn","slimDOMOptions","recordCanvas","onSerialize","onIframeLoad","iframeLoadTimeout","preserveWhiteSpace","_serializedNode","rootId","el","__sn","docId","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","eIndex","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","textContent","repeat","checked","parentElement","selected","rr_dataURL","toDataURL","rr_mediaState","paused","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","getBoundingClientRect","class","rr_width","width","rr_height","height","src","Element","isSVG","SVGElement","TEXT_NODE","parentTagName","isStyle","isScript","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNode","sn","comment","script","as","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","Object","assign","recordChild","headWhitespace","bypassOptions","serializedChildNode","isElement","isShadowHost","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","blankUrl","location","addEventListener","timer","setTimeout","clearTimeout","onceIframeLoaded","iframeDoc","contentDocument","serializedIframeNode","on","fn","target","capture","passive","removeEventListener","DEPARTED_MIRROR_ACCESS_WARNING","_mirror","getId","getNode","removeNodeFromMap","has","reset","throttle","func","wait","timeout","previous","arg","now","Date","leading","remaining","context","this","args","arguments","apply","trailing","hookSetter","key","d","isRevoked","original","getOwnPropertyDescriptor","defineProperty","set","call","_this2","patch","source","replacement","wrapped","prototype","defineProperties","__rrweb_original__","enumerable","getWindowHeight","innerHeight","documentElement","clientHeight","body","getWindowWidth","innerWidth","clientWidth","isBlocked","isIgnored","isAncestorRemoved","mirror","isTouchEvent","event","changedTouches","isIframeINode","hasShadowRoot","isNodeInLinkedList","Proxy","Reflect","get","prop","receiver","DoubleLinkedList","position","Error","current","head","index","next","addNode","__ln","previousSibling","nextSibling","removeNode","moveKey","parentId","isINode","MutationBuffer","Set","mutations","_this","processMutation","emit","frozen","locked","adds","addList","getNextId","ns","nextId","pushAdd","shadowHost","getRootNode","_n$getRootNode","notInDoc","currentN","iframeManager","addIframe","shadowDomManager","addShadowRoot","iframe","childSn","attachIframe","mapRemoves","shift","movedSet","isParentRemoved","removes","addedSet","isAncestorInSet","droppedSet","add","candidate","_node","payload","texts","text","filter","attribute","movedMap","emissionCallback","m","oldValue","getAttribute","attributeName","item","addedNodes","genAdds","removedNodes","nodeId","deepDelete","targetId","childN","init","cb","freeze","unfreeze","isFrozen","lock","unlock","addsSet","some","r","pathToSelector","outerHTML","path","localName","parent","domSiblings","children","i","sibling","stringify","obj","stringifyOptions","numOfKeysLimit","keys","JSON","thisPos","splice","Infinity","_obj","str","toString","stringLengthLimit","Event","eventResult","eventKey","eventValue","isArray","Node","HTMLElement","nodeName","StackFrame","fileName","functionName","lineNumber","columnNumber","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","ErrorStackParser","parse","stacktrace","parseOpera","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","line","sanitizedLine","tokens","locationParts","functionNameRegex","e","parseOpera9","parseOpera11","parseOpera10","lineRE","lines","result","len","parseFloat","mutationBuffers","initMutationObserver","rootEl","mutationBuffer","mutationObserverCtor","MutationObserver","__rrMutationObserver","angularZoneSymbol","_window","Zone","_window$Zone","__symbol__","observer","processMutations","bind","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","wrappedEmit","takeFullSnapshot","INPUT_TAGS","lastInputValueMap","WeakMap","IframeManager","mutationCb","iframes","addLoadListener","loadListener","isAttachIframe","ShadowDomManager","wrapEvent","timestamp","child","hasOwnProperty","record","checkoutEveryNms","checkoutEveryNth","ignoreClass","maskAllInputs","_maskInputOptions","_slimDOMOptions","maskInputFn","hooks","packFn","sampling","mousemoveWait","collectFonts","recordLog","mousemove","lastFullSnapshotEvent","color","date","datetime-local","email","month","number","range","search","tel","time","week","textarea","select","defaultLogOptions","level","lengthThreshold","logger","logOptions","NodeList","DOMTokenList","TypeError","incrementalSnapshotCount","isCheckout","FullSnapshot","IncrementalSnapshot","data","Mutation","buf","wrappedMutationEmit","Meta","slimDOM","idNodeMap","password","snapshot","initialOffset","left","pageXOffset","_document2","_document2$body","_document2$body$paren","_document3","top","pageYOffset","_document5","_document5$body","_document5$body$paren","_document6","handlers","DomContentLoaded","o","mousemoveCb","mouseInteractionCb","scrollCb","viewportResizeCb","inputCb","mediaInteractionCb","styleSheetRuleCb","canvasMutationCb","fontCb","logCb","p","mutation","mouseInteraction","scroll","viewportResize","input","mediaInteaction","styleSheetRule","canvasMutation","font","mergeHooks","lastH","lastW","mutationObserver","mousemoveHandler","timeBaseline","threshold","positions","wrappedCb","totalOffset","timeOffset","mousemoveCallback","updatePosition","evt","clientX","clientY","x","y","MouseEvent","MouseMove","DragEvent","Drag","TouchMove","h","initMoveObserver","mouseInteractionHandler","disableMap","Number","isNaN","endsWith","eventName","handler","getHandler","initMouseInteractionObserver","scrollHandler","scrollEl","scrollingElement","initScrollObserver","viewportResizeHandler","inputHandler","eventHandler","isChecked","cbWithDedup","querySelectorAll","v","lastInputValue","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","initInputObserver","mediaInteractionHandler","initMediaInteractionObserver","styleSheetObserver","insertRule","CSSStyleSheet","ownerNode","deleteRule","initStyleSheetObserver","canvasMutationObserver","props","getOwnPropertyNames","CanvasRenderingContext2D","restoreHandler","canvas","recordArgs","HTMLCanvasElement","hookHandler","setter","initCanvasMutationObserver","fontObserver","fontMap","originalFontFace","FontFace","family","descriptors","fontFace","buffer","fontSource","Uint8Array","fonts","FonFace","initFontObserver","logObserver","logCount","cancelHandlers","includes","originalOnError","onerror","msg","file","col","_this3","trace","stackFrame","_logger","initLogObserver","disconnect","initObservers","MouseInteraction","Scroll","ViewportResize","Input","MediaInteraction","StyleSheetRule","CanvasMutation","Font","Log","Load","addCustomEvent","tag","Custom","freezePage","require","u8","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","b","j","revfl","revfd","rev","hMap","cd","mb","l","co","le","rvb","sv","flt","fdt","flm","fdm","shft","slc","subarray","ec","err","ind","nt","code","captureStackTrace","wbits","wbits16","hTree","t","f","t2","et","sort","i0","i1","i2","maxSym","tr","mbt","ln","dt","lft","cst","Math","max","lc","cl","cli","cln","cls","w","clen","cf","wfblk","out","dat","wblk","final","syms","lf","df","li","bs","bl","dlt","mlb","ddt","mdb","lclt","nlc","lcdt","ndc","lcfreq","lct","mlcb","nlcc","lm","ll","dm","dl","flen","ftlen","dtlen","llm","lcts","it","clct","dst","deo","te","TextEncoder","td","TextDecoder","decode","stream","strFromU8","latin1","String","fromCharCode","dutf8","pack","_e","opts","min","adler","opt","lv","fl","lvl","plvl","pre","post","lst","ceil","msk","prev","bs1","bs2","hsh","wi","hv","imod","pimod","rem","ch","dif","maxn","maxd","ml","nl","mmd","md","ti","lin","din","dflt","mem","wbytes","zlibSync","encode","ar","ai","charCodeAt","strToU8","ErrorTrace","globalErrorTrace","networkErrorTrace","promiseErrorTrace","iframeErrorTrace","eventsMatrix","getInstance","instance","lineno","colno","errEventRoute","events","concat","fetch","IDLE","errLogRoute","preventDefault","reason","frames","ReportData","uri","fetchDomain","URGENT","method","keepalive","xhr","XMLHttpRequest","open","setRequestHeader","send","onload","sendBeacon","image","Image","isPerformanceSupported","getEntriesByType","mark","bytes2kb","bytes","pow","toFixed","roundByTwo","num","pushTask","callback","requestIdleCallback","recordingStorage","storage","estimate","usage","usageDetails","res","quota","state","_settle","onFulfilled","effectiveType","saveData","recordClientNavigator","Promise","resolve","connection","downlink","rtt","bandwidth","sizes","times","fetchs","userAgent","recordTiming","responseEnd","responseStart","requestStart","fetchTime","fetchStart","workerTime","workerStart","networkTime","downloadTime","timeToFirstByte","headerSize","decodedBodySize","transferSize","dnsLookupTime","domainLookupStart","domainLookupEnd","tcpTime","connectStart","connectEnd","firstPaintTime","domParseTime","domComplete","domInteractive","domRenderTime","domContentLoadedEventEnd","domContentLoadedEventStart","onloadTime","loadEventEnd","loadEventStart","isLowEndDevice","deviceMemory","hardwareConcurrency","isLowEndExperience","getNavigatorInformation","serviceWorkerStatus","serviceWorker","controller","fcpScore","lcpScore","fidcore","clsScore","tbtScore","webVitalsScore","fp","fcp","lcp","lcpFinal","fid","fidVitals","clsFinal","tbt","tbt5S","tbt10S","tbtFinal","getVitalsScore","measureName","reportPerformance","eventProperties","visibilityState","metricName","navigatorInformation","vitalsScore","logData","metric","customProperties","logMetric","duration","bt","rt","beacon","css","img","other","total","xmlhttprequest","initLargestContentfulPaint","entries","lastEntry","renderTime","startTime","initElementTiming","entry","identifier","performanceEntry","initLongtask","initFirstInput","processingStart","disconnectPO","performanceObserverInstance","takeRecords","initResouceTiming","initiatorType","bodySize","initLayoutShift","hadRecentInput","asyncSubscripePO","eventType","Observer","PerformanceObserver","getEntries","buffered","disconnectPerformanceObserver","logRoute","all","then"],"mappings":"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"}