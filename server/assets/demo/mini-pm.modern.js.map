{"version":3,"file":"mini-pm.modern.js","sources":["../src/types/types.ts","../src/constants.ts","../src/utils/console.ts","../src/config/config.ts","../src/rrweb/snapshot/types.ts","../src/rrweb/snapshot/utils.ts","../src/rrweb/snapshot/snapshot.ts","../src/rrweb/types.ts","../src/rrweb/utils.ts","../src/rrweb/record/mutation.ts","../src/rrweb/record/stringify.ts","../src/rrweb/record/error-stack-parser.ts","../src/rrweb/record/observer.ts","../src/rrweb/record/iframe-manager.ts","../src/rrweb/record/shadow-dom-manager.ts","../src/rrweb/record/index.ts","../src/rrweb/fflate/node-worker.ts","../src/rrweb/fflate/index.ts","../src/rrweb/packer/pack.ts","../src/rrweb/packer/base.ts","../src/error-trace/index.ts","../src/utils/ReportData.ts","../src/utils/helper.ts","../src/performance/record-storage.ts","../src/performance/record-client-navigator.ts","../src/performance/record-timing.ts","../src/utils/navigator-information.ts","../src/utils/vitals-score.ts","../src/utils/report-performance.ts","../src/utils/log.ts","../src/utils/metrics.ts","../src/performance/paint.ts","../src/performance/longtask.ts","../src/performance/first-input.ts","../src/performance/resource.ts","../src/performance/layout-shift.ts","../src/performance/performance-observer.ts","../src/index.ts"],"sourcesContent":["import { recordOptions } from \"../rrweb/types\";\n\nexport interface PerformanceMonitoringOptions {\n  isObserverResourceTiming?: boolean,\n  isObserverElementTiming?: boolean,\n  maxTime?: number,\n  captureError?: boolean,\n  reportData?: ReportDataAchieve | null,\n  fetchDomain?: string,\n  errLogRoute?: string,\n  errEventRoute?: string,\n  logRoute?: string,\n  analyticsTracker?: (options: AnalyticsTrackerOptions) => void,\n  recordOptions?: recordOptions<any>\n}\n\nexport interface StorageOpt {\n  quota?: number | undefined,\n  usage?: number | undefined,\n  usageDetails: { [key: string]: any }\n}\n\nexport interface TimingOpt {\n  // The time to initiate the network is from AppCache to ResponseEnd\n  // 发起网络的时间是从AppCache到ResponseEnd\n  fetchTime: number,\n  // Response time\n  // 响应时间\n  workerTime: number,\n  // Network request time\n  // 网络请求时间\n  networkTime: number,\n  // Server response time\n  // 服务器响应时间\n  downloadTime: number,\n  // The time when the browser received the first byte of the server\n  // 浏览器接收服务端的第一个字节的时间\n  timeToFirstByte: number,\n  // Request header size\n  // 请求头大小\n  headerSize: number,\n  // dns resolution time\n  // dns解析时间\n  dnsLookupTime: number,\n  // tcp connection time\n  // tcp连接时间\n  tcpTime: number,\n  // Blank screen time\n  // 白屏时间\n  firstPaintTime: number,\n  // dom rendering time\n  // dom渲染时间\n  domRenderTime: number,\n  // onload time\n  // onload时间\n  onloadTime: number,\n  // dom parsing time\n  // dom解析时间\n  domParseTime: number,\n}\n\nexport interface NavigatorOpt {\n  // 浏览器信息\n  // Browser information\n  userAgent: string,\n  // User's internet speed\n  // 用户的网速\n  connection: {\n    downlink?: number,\n    effectiveType?: EffectiveType,\n    rtt?: number,\n    saveData?: boolean,\n    [key: string]: unknown,\n    bandwidth?: string\n  }\n}\n\nexport interface ReportDataAchieve {\n  fetch: (label: AskLevel, body: string, uri: string) => void\n}\n\nexport interface PerformanceObservers {\n  [eventType: string]: PerformanceObserver | null;\n}\n\nexport enum AskLevel {\n  URGENT = 1,\n  IDLE = 2,\n}\n\nexport type PerformanceObserverEventType =\n  | \"paint\"\n  | \"longtask\"\n  | \"first-input\"\n  | \"largest-contentful-paint\"\n  | \"resource\"\n  | \"layout-shift\"\n  | \"element\"\n\nexport type VitalsScore = 'good' | 'needsImprovement' | 'poor' | null;\n\nexport interface AnalyticsTrackerOptions {\n  metricName: string;\n  data: TimingOpt | number | NavigatorOpt;\n  eventProperties: object | undefined;\n  navigatorInformation: unknown;\n  vitalsScore: VitalsScore;\n}\n\nexport interface NavigatorInformation {\n  deviceMemory?: number;\n  hardwareConcurrency?: number;\n  isLowEndDevice?: boolean;\n  isLowEndExperience?: boolean;\n  serviceWorkerStatus?: 'controlled' | 'supported' | 'unsupported';\n}\n\nexport type EffectiveType =\n  | '2g'\n  | '3g'\n  | '4g'\n  | '5g'\n  | 'slow-2g'\n  | 'lte';\n\nexport interface PerformanceEntryEncapsulation extends PerformanceEntry {\n  identifier: any;\n  value?: number | undefined;\n  hadRecentInput?: PerformanceEntryEncapsulation | undefined;\n  initiatorType?: string;\n  decodedBodySize?: number;\n  processingStart: DOMHighResTimeStamp;\n  target?: Node;\n  renderTime?: number\n}\n\nexport interface ResourceTime {\n  beacon: number;\n  css: number;\n  fetch: number;\n  img: number;\n  other: number;\n  script: number;\n  total: number;\n  xmlhttprequest: number;\n  [key: string]: number\n}","interface Navigator {\n  sendBeacon: any\n  connection?: any\n  storage: any\n  userAgent: string\n  deviceMemory: number;\n  hardwareConcurrency: number;\n  serviceWorker?: {\n    controller?: string;\n  };\n}\n\nexport const W = window\nexport const WP = W.performance\nexport const WN = W.navigator as any as Navigator\nexport const C = W.console\nexport const D = document","import { C } from \"../constants\"\n\nconst prefix = \"mini-pm🐢：\"\n\nexport const log = (message: any, ...options: any[]): void => C.log(prefix, message, ...options)\n\nexport const warn = (message: any, ...options: any[]) => C.warn(prefix, message, ...options)\n\nexport const error = (message: any, ...options: any[]) => C.error(prefix, message, ...options)","import type { AnalyticsTrackerOptions, PerformanceMonitoringOptions } from \"../types/types\";\nimport { log } from \"../utils/console\";\n\nexport const config: PerformanceMonitoringOptions = {\n  isObserverResourceTiming: false,\n  isObserverElementTiming: false,\n  maxTime: 15000,\n  captureError: true,\n  reportData: null,\n  analyticsTracker: (options: AnalyticsTrackerOptions) => {\n    log(options)\n  },\n  recordOptions: {}\n}","export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n\nexport type MaskTextFn = (text: string) => string;\n","import { INode } from './types';\n\nexport function isElement(n: Node | INode): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n  MaskTextFn,\n} from './types';\nimport { isElement, isShadowRoot } from './utils';\n\nlet _id = 1;\nconst tagNameRegex = RegExp('[^a-z0-9-_]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule)\n    ? getCssRulesString(rule.styleSheet) || ''\n    : rule.cssText;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin;\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    var chars,\n      match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  let output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        let c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n\nfunction getHref() {\n  // return a href without hash\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: string,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || ((name === 'href' || name === 'xlink:href') && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    value &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    // tslint:disable-next-line: prefer-for-of\n    for (let eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      const className = element.classList[eIndex];\n      if (blockClass.test(className)) {\n        return true;\n      }\n    }\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nexport function needMaskingText(\n  node: Node | null,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (typeof maskTextClass === 'string') {\n      if ((node as HTMLElement).classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (maskTextClass.test(className)) {\n          return true;\n        }\n      });\n    }\n    if (maskTextSelector) {\n      if ((node as HTMLElement).matches(maskTextSelector)) {\n        return true;\n      }\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    listener();\n    return;\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    recordCanvas: boolean;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    recordCanvas,\n  } = options;\n  // Only record root id when document object is not the base document\n  let rootId: number | undefined;\n  if (((doc as unknown) as INode).__sn) {\n    const docId = ((doc as unknown) as INode).__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      return {\n        type: NodeType.Document,\n        childNodes: [],\n        rootId,\n      };\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, tagName, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        const cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value =\n            maskInputOptions[attributes.type as keyof MaskInputOptions] ||\n            maskInputOptions[tagName as keyof MaskInputOptions]\n              ? '*'.repeat(value.length)\n              : value;\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        const selectValue = (n as HTMLOptionElement).parentElement;\n        if (attributes.value === (selectValue as HTMLSelectElement).value) {\n          attributes.selected = (n as HTMLOptionElement).selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL();\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      // block element\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      // iframe\n      if (tagName === 'iframe') {\n        delete attributes.src;\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n        rootId,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n      if (isStyle && textContent) {\n        textContent = absoluteToStylesheet(textContent, getHref());\n      }\n      if (isScript) {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      if (\n        !isStyle &&\n        !isScript &&\n        needMaskingText(n, maskTextClass, maskTextSelector) &&\n        textContent\n      ) {\n        textContent = maskTextFn\n          ? maskTextFn(textContent)\n          : textContent.replace(/[\\S]/g, '*');\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n        rootId,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      (sn.tagName === 'script' ||\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script'))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions?: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskTextFn,\n    slimDOMOptions,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    recordCanvas,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  if (onSerialize) {\n    onSerialize(n as INode);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      map,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      serializedNode.isShadowHost = true;\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            map,\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            slimDOMOptions,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(n as INode, serializedIframeNode);\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    slimDOM?: boolean | SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    blockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskTextFn,\n    slimDOM = false,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","import {\n  serializedNodeWithId,\n  idNodeMap,\n  INode,\n  MaskInputOptions,\n  SlimDOMOptions,\n} from './snapshot';\nimport { PackFn, UnpackFn } from './packer/base';\nimport { FontFaceDescriptors } from 'css-font-loading-module';\nimport { IframeManager } from './record/iframe-manager';\nimport { ShadowDomManager } from './record/shadow-dom-manager';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n  Custom,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport type logEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type customEvent<T = unknown> = {\n  type: EventType.Custom;\n  data: {\n    tag: string;\n    payload: T;\n  };\n};\n\nexport type styleSheetEvent = {};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n  TouchMove,\n  MediaInteraction,\n  StyleSheetRule,\n  CanvasMutation,\n  Font,\n  Log,\n  Drag,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source:\n  | IncrementalSource.MouseMove\n  | IncrementalSource.TouchMove\n  | IncrementalSource.Drag;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimension;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type mediaInteractionData = {\n  source: IncrementalSource.MediaInteraction;\n} & mediaInteractionParam;\n\nexport type styleSheetRuleData = {\n  source: IncrementalSource.StyleSheetRule;\n} & styleSheetRuleParam;\n\nexport type canvasMutationData = {\n  source: IncrementalSource.CanvasMutation;\n} & canvasMutationParam;\n\nexport type fontData = {\n  source: IncrementalSource.Font;\n} & fontParam;\n\nexport type logData = {\n  source: IncrementalSource.Log;\n} & LogParam;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData\n  | mediaInteractionData\n  | styleSheetRuleData\n  | canvasMutationData\n  | fontData\n  | logData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent\n  | logEvent\n  | customEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type blockClass = string | RegExp;\n\nexport type maskTextClass = string | RegExp;\n\nexport type SamplingStrategy = Partial<{\n  /**\n   * false means not to record mouse/touch move events\n   * number is the throttle threshold of recording mouse/touch move\n   */\n  mousemove: boolean | number;\n  /**\n   * number is the throttle threshold of mouse/touch move callback\n   */\n  mousemoveCallback: number;\n  /**\n   * false means not to record mouse interaction events\n   * can also specify record some kinds of mouse interactions\n   */\n  mouseInteraction: boolean | Record<string, boolean | undefined>;\n  /**\n   * number is the throttle threshold of recording scroll\n   */\n  scroll: number;\n  /**\n   * 'all' will record all the input events\n   * 'last' will only record the last input value while input a sequence of chars\n   */\n  input: 'all' | 'last';\n}>;\n\nexport type recordOptions<T> = {\n  emit?: (e: T, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n  blockClass?: blockClass;\n  blockSelector?: string;\n  ignoreClass?: string;\n  maskTextClass?: maskTextClass;\n  maskTextSelector?: string;\n  maskAllInputs?: boolean;\n  maskInputOptions?: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  slimDOMOptions?: SlimDOMOptions | 'all' | true;\n  inlineStylesheet?: boolean;\n  hooks?: hooksParam;\n  packFn?: PackFn;\n  sampling?: SamplingStrategy;\n  recordCanvas?: boolean;\n  collectFonts?: boolean;\n  // departed, please use sampling options\n  mousemoveWait?: number;\n  recordLog?: boolean | LogRecordOptions;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n  mediaInteractionCb: mediaInteractionCallback;\n  blockClass: blockClass;\n  blockSelector: string | null;\n  ignoreClass: string;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  maskInputOptions: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  inlineStylesheet: boolean;\n  styleSheetRuleCb: styleSheetRuleCallback;\n  canvasMutationCb: canvasMutationCallback;\n  fontCb: fontCallback;\n  logCb: logCallback;\n  logOptions: LogRecordOptions;\n  sampling: SamplingStrategy;\n  recordCanvas: boolean;\n  collectFonts: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  doc: Document;\n  mirror: Mirror;\n  iframeManager: IframeManager;\n  shadowDomManager: ShadowDomManager;\n};\n\nexport type hooksParam = {\n  mutation?: mutationCallBack;\n  mousemove?: mousemoveCallBack;\n  mouseInteraction?: mouseInteractionCallBack;\n  scroll?: scrollCallback;\n  viewportResize?: viewportResizeCallback;\n  input?: inputCallback;\n  mediaInteaction?: mediaInteractionCallback;\n  styleSheetRule?: styleSheetRuleCallback;\n  canvasMutation?: canvasMutationCallback;\n  font?: fontCallback;\n  log?: logCallback;\n};\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\nexport type mutationRecord = {\n  type: string;\n  target: Node;\n  oldValue: string | null;\n  addedNodes: NodeList;\n  removedNodes: NodeList;\n  attributeName: string | null;\n};\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n  isShadow?: boolean;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  // Newly recorded mutations will not have previousId any more, just for compatibility\n  previousId?: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\nexport type mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n  isAttachIframe?: true;\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (\n  p: mousePosition[],\n  source:\n    | IncrementalSource.MouseMove\n    | IncrementalSource.TouchMove\n    | IncrementalSource.Drag,\n) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove_Departed, // we will start a separate observer for touch move event\n  TouchEnd,\n}\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type styleSheetAddRule = {\n  rule: string;\n  index?: number;\n};\n\nexport type styleSheetDeleteRule = {\n  index: number;\n};\n\nexport type styleSheetRuleParam = {\n  id: number;\n  removes?: styleSheetDeleteRule[];\n  adds?: styleSheetAddRule[];\n};\n\nexport type styleSheetRuleCallback = (s: styleSheetRuleParam) => void;\n\nexport type canvasMutationCallback = (p: canvasMutationParam) => void;\n\nexport type canvasMutationParam = {\n  id: number;\n  property: string;\n  args: Array<unknown>;\n  setter?: true;\n};\n\nexport type fontParam = {\n  family: string;\n  fontSource: string;\n  buffer: boolean;\n  descriptors?: FontFaceDescriptors;\n};\n\nexport type LogLevel =\n  | 'assert'\n  | 'clear'\n  | 'count'\n  | 'countReset'\n  | 'debug'\n  | 'dir'\n  | 'dirxml'\n  | 'error'\n  | 'group'\n  | 'groupCollapsed'\n  | 'groupEnd'\n  | 'info'\n  | 'log'\n  | 'table'\n  | 'time'\n  | 'timeEnd'\n  | 'timeLog'\n  | 'trace'\n  | 'warn';\n\n/* fork from interface Console */\n// all kinds of console functions\nexport type Logger = {\n  assert?: typeof console.assert;\n  clear?: typeof console.clear;\n  count?: typeof console.count;\n  countReset?: typeof console.countReset;\n  debug?: typeof console.debug;\n  dir?: typeof console.dir;\n  dirxml?: typeof console.dirxml;\n  error?: typeof console.error;\n  group?: typeof console.group;\n  groupCollapsed?: typeof console.groupCollapsed;\n  groupEnd?: () => void;\n  info?: typeof console.info;\n  log?: typeof console.log;\n  table?: typeof console.table;\n  time?: typeof console.time;\n  timeEnd?: typeof console.timeEnd;\n  timeLog?: typeof console.timeLog;\n  trace?: typeof console.trace;\n  warn?: typeof console.warn;\n};\n\n/**\n * define an interface to replay log records\n * (data: logData) => void> function to display the log data\n */\nexport type ReplayLogger = Partial<Record<LogLevel, (data: logData) => void>>;\n\nexport type LogParam = {\n  level: LogLevel;\n  trace: string[];\n  payload: string[];\n};\n\nexport type fontCallback = (p: fontParam) => void;\n\nexport type logCallback = (p: LogParam) => void;\n\nexport type viewportResizeDimension = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimension) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport const enum MediaInteractions {\n  Play,\n  Pause,\n}\n\nexport type mediaInteractionParam = {\n  type: MediaInteractions;\n  id: number;\n};\n\nexport type mediaInteractionCallback = (p: mediaInteractionParam) => void;\n\nexport type DocumentDimension = {\n  x: number;\n  y: number;\n  // scale value relative to its parent iframe\n  relativeScale: number;\n  // scale value relative to the root iframe\n  absoluteScale: number;\n};\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n  reset: () => void;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type playerConfig = {\n  speed: number;\n  maxSpeed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: boolean;\n  showWarning: boolean;\n  showDebug: boolean;\n  blockClass: string;\n  liveMode: boolean;\n  insertStyleRules: string[];\n  triggerFocus: boolean;\n  UNSAFE_replayCanvas: boolean;\n  pauseAnimation?: boolean;\n  mouseTail:\n  | boolean\n  | {\n    duration?: number;\n    lineCap?: string;\n    lineWidth?: number;\n    strokeStyle?: string;\n  };\n  unpackFn?: UnpackFn;\n  logConfig: LogReplayConfig;\n};\n\nexport type LogReplayConfig = {\n  level?: LogLevel[] | undefined;\n  replayLogger: ReplayLogger | undefined;\n};\n\nexport type playerMetaData = {\n  startTime: number;\n  endTime: number;\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport type Handler = (event?: unknown) => void;\n\nexport type Emitter = {\n  on(type: string, handler: Handler): void;\n  emit(type: string, event?: unknown): void;\n  off(type: string, handler: Handler): void;\n};\n\nexport type Arguments<T> = T extends (...payload: infer U) => unknown\n  ? U\n  : unknown;\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n  MouseInteraction = 'mouse-interaction',\n  EventCast = 'event-cast',\n  CustomEvent = 'custom-event',\n  Flush = 'flush',\n  StateChange = 'state-change',\n  PlayBack = 'play-back',\n}\n\nexport type MaskInputFn = (text: string) => string;\n\nexport type MaskTextFn = (text: string) => string;\n\n// store the state that would be changed during the process(unmount from dom and mount again)\nexport type ElementState = {\n  // [scrollLeft,scrollTop]\n  scroll?: [number, number];\n};\n\nexport type StringifyOptions = {\n  // limit of string length\n  stringLengthLimit?: number;\n  /**\n   * limit of number of keys in an object\n   * if an object contains more keys than this limit, we would call its toString function directly\n   */\n  numOfKeysLimit: number;\n};\n\nexport type LogRecordOptions = {\n  level?: LogLevel[] | undefined;\n  lengthThreshold?: number;\n  stringifyOptions?: StringifyOptions;\n  logger?: Logger;\n};\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n  blockClass,\n  eventWithTime,\n  EventType,\n  IncrementalSource,\n  addedNodeMutation,\n  removedNodeMutation,\n  textMutation,\n  attributeMutation,\n  mutationData,\n  scrollData,\n  inputData,\n  DocumentDimension,\n} from './types';\nimport {\n  INode,\n  IGNORED_NODE,\n  serializedNodeWithId,\n  NodeType,\n  isShadowRoot,\n} from './snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | Window = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport function createMirror(): Mirror {\n  return {\n    map: {},\n    getId(n) {\n      // if n is not a serialized INode, use -1 as its id.\n      if (!n.__sn) {\n        return -1;\n      }\n      return n.__sn.id;\n    },\n    getNode(id) {\n      return this.map[id] || null;\n    },\n    // TODO: use a weakmap to get rid of manually memory management\n    removeNodeFromMap(n) {\n      const id = n.__sn && n.__sn.id;\n      delete this.map[id];\n      if (n.childNodes) {\n        n.childNodes.forEach((child) =>\n          this.removeNodeFromMap((child as Node) as INode),\n        );\n      }\n    },\n    has(id) {\n      return this.map.hasOwnProperty(id);\n    },\n    reset() {\n      this.map = {};\n    },\n  };\n}\n\n// https://github.com/rrweb-io/rrweb/pull/407\nconst DEPARTED_MIRROR_ACCESS_WARNING =\n  'Please stop import mirror directly. Instead of that,' +\n  '\\r\\n' +\n  'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\n  '\\r\\n' +\n  'or you can use record.mirror to access the mirror instance during recording.';\nexport let _mirror: Mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n};\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === 'map') {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: number | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function (arg: T) {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait - (now - previous);\n    let context = this;\n    let args = arguments as any;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        window.clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = window.setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n  isRevoked?: boolean,\n  win = window,\n): hookResetter {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked\n      ? d\n      : {\n        set(value) {\n          // put hooked setter into event loop to avoid of set latency\n          setTimeout(() => {\n            d.set!.call(this, value);\n          }, 0);\n          if (original && original.set) {\n            original.set.call(this, value);\n          }\n        },\n      },\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\n\n// copy from https://github.com/getsentry/sentry-javascript/blob/b2109071975af8bf0316d3b5b38f519bdaf5dc15/packages/utils/src/object.ts\nexport function patch(\n  // tslint:disable-next-line:no-any\n  source: { [key: string]: any },\n  name: string,\n  // tslint:disable-next-line:no-any\n  replacement: (...args: any[]) => any,\n): () => void {\n  try {\n    if (!(name in source)) {\n      return () => { };\n    }\n\n    const original = source[name] as () => unknown;\n    const wrapped = replacement(original);\n\n    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n    // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    }\n\n    source[name] = wrapped;\n\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => { };\n    // This can throw if multiple fill happens on a global object like XMLHttpRequest\n    // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n  }\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nexport function isBlocked(node: Node | null, blockClass: blockClass): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    let needBlock = false;\n    if (typeof blockClass === 'string') {\n      needBlock = (node as HTMLElement).classList.contains(blockClass);\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (blockClass.test(className)) {\n          needBlock = true;\n        }\n      });\n    }\n    return needBlock || isBlocked(node.parentNode, blockClass);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return isBlocked(node.parentNode, blockClass);\n  }\n  return isBlocked(node.parentNode, blockClass);\n}\n\nexport function isIgnored(n: Node | INode): boolean {\n  if ('__sn' in n) {\n    return (n as INode).__sn.id === IGNORED_NODE;\n  }\n  // The main part of the slimDOM check happens in\n  // rrweb-snapshot::serializeNodeWithId\n  return false;\n}\n\nexport function isAncestorRemoved(target: INode, mirror: Mirror): boolean {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode, mirror);\n}\n\nexport function isTouchEvent(\n  event: MouseEvent | TouchEvent,\n): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches);\n}\n\nexport function polyfill(win = window) {\n  if ('NodeList' in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as NodeList['forEach'];\n  }\n\n  if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as DOMTokenList['forEach'];\n  }\n\n  // https://github.com/Financial-Times/polyfill-service/pull/183\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = function contains(node) {\n      if (!(0 in arguments)) {\n        throw new TypeError('1 argument is required');\n      }\n\n      do {\n        if (this === node) {\n          return true;\n        }\n        // tslint:disable-next-line: no-conditional-assignment\n      } while ((node = node && node.parentNode));\n\n      return false;\n    };\n  }\n}\n\nexport function needCastInSyncMode(event: eventWithTime): boolean {\n  switch (event.type) {\n    case EventType.DomContentLoaded:\n    case EventType.Load:\n    case EventType.Custom:\n      return false;\n    case EventType.FullSnapshot:\n    case EventType.Meta:\n      return true;\n    default:\n      break;\n  }\n\n  switch (event.data.source) {\n    case IncrementalSource.MouseMove:\n    case IncrementalSource.MouseInteraction:\n    case IncrementalSource.TouchMove:\n    case IncrementalSource.MediaInteraction:\n      return false;\n    case IncrementalSource.ViewportResize:\n    case IncrementalSource.StyleSheetRule:\n    case IncrementalSource.Scroll:\n    case IncrementalSource.Input:\n      return true;\n    default:\n      break;\n  }\n\n  return true;\n}\n\nexport type TreeNode = {\n  id: number;\n  mutation: addedNodeMutation;\n  parent?: TreeNode;\n  children: Record<number, TreeNode>;\n  texts: textMutation[];\n  attributes: attributeMutation[];\n};\nexport class TreeIndex {\n  public tree!: Record<number, TreeNode>;\n\n  private removeNodeMutations!: removedNodeMutation[];\n  private textMutations!: textMutation[];\n  private attributeMutations!: attributeMutation[];\n  private indexes!: Map<number, TreeNode>;\n  private removeIdSet!: Set<number>;\n  private scrollMap!: Map<number, scrollData>;\n  private inputMap!: Map<number, inputData>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public add(mutation: addedNodeMutation) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode: TreeNode = {\n      id: mutation.node.id,\n      mutation,\n      children: [],\n      texts: [],\n      attributes: [],\n    };\n    if (!parentTreeNode) {\n      this.tree[treeNode.id] = treeNode;\n    } else {\n      treeNode.parent = parentTreeNode;\n      parentTreeNode.children[treeNode.id] = treeNode;\n    }\n    this.indexes.set(treeNode.id, treeNode);\n  }\n\n  public remove(mutation: removedNodeMutation, mirror: Mirror) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode = this.indexes.get(mutation.id);\n\n    const deepRemoveFromMirror = (id: number) => {\n      this.removeIdSet.add(id);\n      const node = mirror.getNode(id);\n      node?.childNodes.forEach((childNode) => {\n        if ('__sn' in childNode) {\n          deepRemoveFromMirror(((childNode as unknown) as INode).__sn.id);\n        }\n      });\n    };\n    const deepRemoveFromTreeIndex = (node: TreeNode) => {\n      this.removeIdSet.add(node.id);\n      Object.values(node.children).forEach((n) => deepRemoveFromTreeIndex(n));\n      const _treeNode = this.indexes.get(node.id);\n      if (_treeNode) {\n        const _parentTreeNode = _treeNode.parent;\n        if (_parentTreeNode) {\n          delete _treeNode.parent;\n          delete _parentTreeNode.children[_treeNode.id];\n          this.indexes.delete(mutation.id);\n        }\n      }\n    };\n\n    if (!treeNode) {\n      this.removeNodeMutations.push(mutation);\n      deepRemoveFromMirror(mutation.id);\n    } else if (!parentTreeNode) {\n      delete this.tree[treeNode.id];\n      this.indexes.delete(treeNode.id);\n      deepRemoveFromTreeIndex(treeNode);\n    } else {\n      delete treeNode.parent;\n      delete parentTreeNode.children[treeNode.id];\n      this.indexes.delete(mutation.id);\n      deepRemoveFromTreeIndex(treeNode);\n    }\n  }\n\n  public text(mutation: textMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.texts.push(mutation);\n    } else {\n      this.textMutations.push(mutation);\n    }\n  }\n\n  public attribute(mutation: attributeMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.attributes.push(mutation);\n    } else {\n      this.attributeMutations.push(mutation);\n    }\n  }\n\n  public scroll(d: scrollData) {\n    this.scrollMap.set(d.id, d);\n  }\n\n  public input(d: inputData) {\n    this.inputMap.set(d.id, d);\n  }\n\n  public flush(): {\n    mutationData: mutationData;\n    scrollMap: TreeIndex['scrollMap'];\n    inputMap: TreeIndex['inputMap'];\n  } {\n    const {\n      tree,\n      removeNodeMutations,\n      textMutations,\n      attributeMutations,\n    } = this;\n\n    const batchMutationData: mutationData = {\n      source: IncrementalSource.Mutation,\n      removes: removeNodeMutations,\n      texts: textMutations,\n      attributes: attributeMutations,\n      adds: [],\n    };\n\n    const walk = (treeNode: TreeNode, removed: boolean) => {\n      if (removed) {\n        this.removeIdSet.add(treeNode.id);\n      }\n      batchMutationData.texts = batchMutationData.texts\n        .concat(removed ? [] : treeNode.texts)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      batchMutationData.attributes = batchMutationData.attributes\n        .concat(removed ? [] : treeNode.attributes)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      if (\n        !this.removeIdSet.has(treeNode.id) &&\n        !this.removeIdSet.has(treeNode.mutation.parentId) &&\n        !removed\n      ) {\n        batchMutationData.adds.push(treeNode.mutation);\n        if (treeNode.children) {\n          Object.values(treeNode.children).forEach((n) => walk(n, false));\n        }\n      } else {\n        Object.values(treeNode.children).forEach((n) => walk(n, true));\n      }\n    };\n\n    Object.values(tree).forEach((n) => walk(n, false));\n\n    for (const id of this.scrollMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.scrollMap.delete(id);\n      }\n    }\n    for (const id of this.inputMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.inputMap.delete(id);\n      }\n    }\n\n    const scrollMap = new Map(this.scrollMap);\n    const inputMap = new Map(this.inputMap);\n\n    this.reset();\n\n    return {\n      mutationData: batchMutationData,\n      scrollMap,\n      inputMap,\n    };\n  }\n\n  private reset() {\n    this.tree = [];\n    this.indexes = new Map();\n    this.removeNodeMutations = [];\n    this.textMutations = [];\n    this.attributeMutations = [];\n    this.removeIdSet = new Set();\n    this.scrollMap = new Map();\n    this.inputMap = new Map();\n  }\n}\n\ntype ResolveTree = {\n  value: addedNodeMutation;\n  children: ResolveTree[];\n  parent: ResolveTree | null;\n};\n\nexport function queueToResolveTrees(queue: addedNodeMutation[]): ResolveTree[] {\n  const queueNodeMap: Record<number, ResolveTree> = {};\n  const putIntoMap = (\n    m: addedNodeMutation,\n    parent: ResolveTree | null,\n  ): ResolveTree => {\n    const nodeInTree: ResolveTree = {\n      value: m,\n      parent,\n      children: [],\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n\n  const queueNodeTrees: ResolveTree[] = [];\n  for (const mutation of queue) {\n    const { nextId, parentId } = mutation;\n    if (nextId && nextId in queueNodeMap) {\n      const nextInTree = queueNodeMap[nextId];\n      if (nextInTree.parent) {\n        const idx = nextInTree.parent.children.indexOf(nextInTree);\n        nextInTree.parent.children.splice(\n          idx,\n          0,\n          putIntoMap(mutation, nextInTree.parent),\n        );\n      } else {\n        const idx = queueNodeTrees.indexOf(nextInTree);\n        queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n      }\n      continue;\n    }\n    if (parentId in queueNodeMap) {\n      const parentInTree = queueNodeMap[parentId];\n      parentInTree.children.push(putIntoMap(mutation, parentInTree));\n      continue;\n    }\n    queueNodeTrees.push(putIntoMap(mutation, null));\n  }\n\n  return queueNodeTrees;\n}\n\nexport function iterateResolveTree(\n  tree: ResolveTree,\n  cb: (mutation: addedNodeMutation) => unknown,\n) {\n  cb(tree.value);\n  /**\n   * The resolve tree was designed to reflect the DOM layout,\n   * but we need append next sibling first, so we do a reverse\n   * loop here.\n   */\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    iterateResolveTree(tree.children[i], cb);\n  }\n}\n\ntype HTMLIFrameINode = HTMLIFrameElement & {\n  __sn: serializedNodeWithId;\n};\nexport type AppendedIframe = {\n  mutationInQueue: addedNodeMutation;\n  builtNode: HTMLIFrameINode;\n};\n\nexport function isIframeINode(\n  node: INode | ShadowRoot,\n): node is HTMLIFrameINode {\n  if ('__sn' in node) {\n    return (\n      node.__sn.type === NodeType.Element && node.__sn.tagName === 'iframe'\n    );\n  }\n  // node can be document fragment when using the virtual parent feature\n  return false;\n}\n\nexport function getBaseDimension(\n  node: Node,\n  rootIframe: Node,\n): DocumentDimension {\n  const frameElement = node.ownerDocument?.defaultView?.frameElement;\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1,\n    };\n  }\n\n  const frameDimension = frameElement.getBoundingClientRect();\n  const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  // the iframe element may have a scale transform\n  const relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x:\n      frameDimension.x * frameBaseDimension.relativeScale +\n      frameBaseDimension.x,\n    y:\n      frameDimension.y * frameBaseDimension.relativeScale +\n      frameBaseDimension.y,\n    relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale,\n  };\n}\n\nexport function hasShadowRoot<T extends Node>(\n  n: T,\n): n is T & { shadowRoot: ShadowRoot } {\n  return Boolean(((n as unknown) as Element)?.shadowRoot);\n}\n","// @ts-nocheck\nimport {\n  INode,\n  serializeNodeWithId,\n  transformAttribute,\n  MaskInputOptions,\n  SlimDOMOptions,\n  IGNORED_NODE,\n  isShadowRoot,\n  needMaskingText,\n} from '../snapshot';\nimport {\n  mutationRecord,\n  blockClass,\n  maskTextClass,\n  mutationCallBack,\n  textCursor,\n  attributeCursor,\n  removedNodeMutation,\n  addedNodeMutation,\n  MaskTextFn,\n  Mirror,\n} from '../types';\nimport {\n  isBlocked,\n  isAncestorRemoved,\n  isIgnored,\n  isIframeINode,\n  hasShadowRoot,\n} from '../utils';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\n\ntype DoubleLinkedListNode = {\n  previous: DoubleLinkedListNode | null;\n  next: DoubleLinkedListNode | null;\n  value: NodeInLinkedList;\n};\ntype NodeInLinkedList = Node & {\n  __ln: DoubleLinkedListNode;\n};\n\nfunction isNodeInLinkedList(n: Node | NodeInLinkedList): n is NodeInLinkedList {\n  return '__ln' in n;\n}\nclass DoubleLinkedList {\n  public length = 0;\n  public head: DoubleLinkedListNode | null = null;\n\n  public get(position: number) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n\n  public addNode(n: Node) {\n    const node: DoubleLinkedListNode = {\n      value: n as NodeInLinkedList,\n      previous: null,\n      next: null,\n    };\n    (n as NodeInLinkedList).__ln = node;\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      const current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (\n      n.nextSibling &&\n      isNodeInLinkedList(n.nextSibling) &&\n      n.nextSibling.__ln.previous\n    ) {\n      const current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    this.length++;\n  }\n\n  public removeNode(n: NodeInLinkedList) {\n    const current = n.__ln;\n    if (!this.head) {\n      return;\n    }\n\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      }\n    }\n    if (n.__ln) {\n      delete n.__ln;\n    }\n    this.length--;\n  }\n}\n\nconst moveKey = (id: number, parentId: number) => `${id}@${parentId}`;\nfunction isINode(n: Node | INode): n is INode {\n  return '__sn' in n;\n}\n\n/**\n * controls behaviour of a MutationObserver\n */\nexport default class MutationBuffer {\n  private frozen: boolean = false;\n  private locked: boolean = false;\n\n  private texts: textCursor[] = [];\n  private attributes: attributeCursor[] = [];\n  private removes: removedNodeMutation[] = [];\n  private mapRemoves: Node[] = [];\n\n  private movedMap: Record<string, true> = {};\n\n  /**\n   * the browser MutationObserver emits multiple mutations after\n   * a delay for performance reasons, making tracing added nodes hard\n   * in our `processMutations` callback function.\n   * For example, if we append an element el_1 into body, and then append\n   * another element el_2 into el_1, these two mutations may be passed to the\n   * callback function together when the two operations were done.\n   * Generally we need to trace child nodes of newly added nodes, but in this\n   * case if we count el_2 as el_1's child node in the first mutation record,\n   * then we will count el_2 again in the second mutation record which was\n   * duplicated.\n   * To avoid of duplicate counting added nodes, we use a Set to store\n   * added nodes and its child nodes during iterate mutation records. Then\n   * collect added nodes from the Set which have no duplicate copy. But\n   * this also causes newly added nodes will not be serialized with id ASAP,\n   * which means all the id related calculation should be lazy too.\n   */\n  private addedSet = new Set<Node>();\n  private movedSet = new Set<Node>();\n  private droppedSet = new Set<Node>();\n\n  private emissionCallback: mutationCallBack;\n  private blockClass: blockClass;\n  private blockSelector: string | null;\n  private maskTextClass: maskTextClass;\n  private maskTextSelector: string | null;\n  private inlineStylesheet: boolean;\n  private maskInputOptions: MaskInputOptions;\n  private maskTextFn: MaskTextFn | undefined;\n  private recordCanvas: boolean;\n  private slimDOMOptions: SlimDOMOptions;\n  private doc: Document;\n\n  private mirror: Mirror;\n  private iframeManager: IframeManager;\n  private shadowDomManager: ShadowDomManager;\n\n  public init(\n    cb: mutationCallBack,\n    blockClass: blockClass,\n    blockSelector: string | null,\n    maskTextClass: maskTextClass,\n    maskTextSelector: string | null,\n    inlineStylesheet: boolean,\n    maskInputOptions: MaskInputOptions,\n    maskTextFn: MaskTextFn | undefined,\n    recordCanvas: boolean,\n    slimDOMOptions: SlimDOMOptions,\n    doc: Document,\n    mirror: Mirror,\n    iframeManager: IframeManager,\n    shadowDomManager: ShadowDomManager,\n  ) {\n    this.blockClass = blockClass;\n    this.blockSelector = blockSelector;\n    this.maskTextClass = maskTextClass;\n    this.maskTextSelector = maskTextSelector;\n    this.inlineStylesheet = inlineStylesheet;\n    this.maskInputOptions = maskInputOptions;\n    this.maskTextFn = maskTextFn;\n    this.recordCanvas = recordCanvas;\n    this.slimDOMOptions = slimDOMOptions;\n    this.emissionCallback = cb;\n    this.doc = doc;\n    this.mirror = mirror;\n    this.iframeManager = iframeManager;\n    this.shadowDomManager = shadowDomManager;\n  }\n\n  public freeze() {\n    this.frozen = true;\n  }\n\n  public unfreeze() {\n    this.frozen = false;\n    this.emit();\n  }\n\n  public isFrozen() {\n    return this.frozen;\n  }\n\n  public lock() {\n    this.locked = true;\n  }\n\n  public unlock() {\n    this.locked = false;\n    this.emit();\n  }\n\n  public processMutations = (mutations: mutationRecord[]) => {\n    mutations.forEach(this.processMutation);\n    this.emit();\n  };\n\n  public emit = () => {\n    if (this.frozen || this.locked) {\n      return;\n    }\n\n    // delay any modification of the mirror until this function\n    // so that the mirror for takeFullSnapshot doesn't get mutated while it's event is being processed\n\n    const adds: addedNodeMutation[] = [];\n\n    /**\n     * Sometimes child node may be pushed before its newly added\n     * parent, so we init a queue to store these nodes.\n     */\n    const addList = new DoubleLinkedList();\n    const getNextId = (n: Node): number | null => {\n      let ns: Node | null = n;\n      let nextId: number | null = IGNORED_NODE; // slimDOM: ignored\n      while (nextId === IGNORED_NODE) {\n        ns = ns && ns.nextSibling;\n        nextId = ns && this.mirror.getId((ns as unknown) as INode);\n      }\n      if (nextId === -1 && isBlocked(n.nextSibling, this.blockClass)) {\n        nextId = null;\n      }\n      return nextId;\n    };\n    const pushAdd = (n: Node) => {\n      const shadowHost: Element | null = n.getRootNode\n        ? (n.getRootNode() as ShadowRoot)?.host\n        : null;\n      const notInDoc = !this.doc.contains(n) && !this.doc.contains(shadowHost);\n      if (!n.parentNode || notInDoc) {\n        return;\n      }\n      const parentId = isShadowRoot(n.parentNode)\n        ? this.mirror.getId((shadowHost as unknown) as INode)\n        : this.mirror.getId((n.parentNode as Node) as INode);\n      const nextId = getNextId(n);\n      if (parentId === -1 || nextId === -1) {\n        return addList.addNode(n);\n      }\n      let sn = serializeNodeWithId(n, {\n        doc: this.doc,\n        map: this.mirror.map,\n        blockClass: this.blockClass,\n        blockSelector: this.blockSelector,\n        maskTextClass: this.maskTextClass,\n        maskTextSelector: this.maskTextSelector,\n        skipChild: true,\n        inlineStylesheet: this.inlineStylesheet,\n        maskInputOptions: this.maskInputOptions,\n        maskTextFn: this.maskTextFn,\n        slimDOMOptions: this.slimDOMOptions,\n        recordCanvas: this.recordCanvas,\n        onSerialize: (currentN) => {\n          if (isIframeINode(currentN)) {\n            this.iframeManager.addIframe(currentN);\n          }\n          if (hasShadowRoot(n)) {\n            this.shadowDomManager.addShadowRoot(n.shadowRoot, document);\n          }\n        },\n        onIframeLoad: (iframe, childSn) => {\n          this.iframeManager.attachIframe(iframe, childSn);\n        },\n      });\n      if (sn) {\n        adds.push({\n          parentId,\n          nextId,\n          node: sn,\n        });\n      }\n    };\n\n    while (this.mapRemoves.length) {\n      this.mirror.removeNodeFromMap(this.mapRemoves.shift() as INode);\n    }\n\n    for (const n of this.movedSet) {\n      if (\n        isParentRemoved(this.removes, n, this.mirror) &&\n        !this.movedSet.has(n.parentNode!)\n      ) {\n        continue;\n      }\n      pushAdd(n);\n    }\n\n    for (const n of this.addedSet) {\n      if (\n        !isAncestorInSet(this.droppedSet, n) &&\n        !isParentRemoved(this.removes, n, this.mirror)\n      ) {\n        pushAdd(n);\n      } else if (isAncestorInSet(this.movedSet, n)) {\n        pushAdd(n);\n      } else {\n        this.droppedSet.add(n);\n      }\n    }\n\n    let candidate: DoubleLinkedListNode | null = null;\n    while (addList.length) {\n      let node: DoubleLinkedListNode | null = null;\n      if (candidate) {\n        const parentId = this.mirror.getId(\n          (candidate.value.parentNode as Node) as INode,\n        );\n        const nextId = getNextId(candidate.value);\n        if (parentId !== -1 && nextId !== -1) {\n          node = candidate;\n        }\n      }\n      if (!node) {\n        for (let index = addList.length - 1; index >= 0; index--) {\n          const _node = addList.get(index)!;\n          const parentId = this.mirror.getId(\n            (_node.value.parentNode as Node) as INode,\n          );\n          const nextId = getNextId(_node.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = _node;\n            break;\n          }\n        }\n      }\n      if (!node) {\n        /**\n         * If all nodes in queue could not find a serialized parent,\n         * it may be a bug or corner case. We need to escape the\n         * dead while loop at once.\n         */\n        while (addList.head) {\n          addList.removeNode(addList.head.value);\n        }\n        break;\n      }\n      candidate = node.previous;\n      addList.removeNode(node.value);\n      pushAdd(node.value);\n    }\n\n    const payload = {\n      texts: this.texts\n        .map((text) => ({\n          id: this.mirror.getId(text.node as INode),\n          value: text.value,\n        }))\n        // text mutation's id was not in the mirror map means the target node has been removed\n        .filter((text) => this.mirror.has(text.id)),\n      attributes: this.attributes\n        .map((attribute) => ({\n          id: this.mirror.getId(attribute.node as INode),\n          attributes: attribute.attributes,\n        }))\n        // attribute mutation's id was not in the mirror map means the target node has been removed\n        .filter((attribute) => this.mirror.has(attribute.id)),\n      removes: this.removes,\n      adds,\n    };\n    // payload may be empty if the mutations happened in some blocked elements\n    if (\n      !payload.texts.length &&\n      !payload.attributes.length &&\n      !payload.removes.length &&\n      !payload.adds.length\n    ) {\n      return;\n    }\n\n    // reset\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.addedSet = new Set<Node>();\n    this.movedSet = new Set<Node>();\n    this.droppedSet = new Set<Node>();\n    this.movedMap = {};\n\n    this.emissionCallback(payload);\n  };\n\n  private processMutation = (m: mutationRecord) => {\n    // console.log({ m });\n    if (isIgnored(m.target)) {\n      return;\n    }\n    switch (m.type) {\n      case 'characterData': {\n        const value = m.target.textContent;\n        if (!isBlocked(m.target, this.blockClass) && value !== m.oldValue) {\n          this.texts.push({\n            value:\n              needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n              ) && value\n                ? this.maskTextFn\n                  ? this.maskTextFn(value)\n                  : value.replace(/[\\S]/g, '*')\n                : value,\n            node: m.target,\n          });\n        }\n        break;\n      }\n      case 'attributes': {\n        const value = (m.target as HTMLElement).getAttribute(m.attributeName!);\n        if (isBlocked(m.target, this.blockClass) || value === m.oldValue) {\n          return;\n        }\n        let item: attributeCursor | undefined = this.attributes.find(\n          (a) => a.node === m.target,\n        );\n        if (!item) {\n          item = {\n            node: m.target,\n            attributes: {},\n          };\n          this.attributes.push(item);\n        }\n        // overwrite attribute if the mutations was triggered in same time\n        item.attributes[m.attributeName!] = transformAttribute(\n          this.doc,\n          (m.target as HTMLElement).tagName,\n          m.attributeName!,\n          value!,\n        );\n        break;\n      }\n      case 'childList': {\n        m.addedNodes.forEach((n) => this.genAdds(n, m.target));\n        m.removedNodes.forEach((n) => {\n          const nodeId = this.mirror.getId(n as INode);\n          const parentId = isShadowRoot(m.target)\n            ? this.mirror.getId((m.target.host as unknown) as INode)\n            : this.mirror.getId(m.target as INode);\n          if (\n            isBlocked(n, this.blockClass) ||\n            isBlocked(m.target, this.blockClass) ||\n            isIgnored(n)\n          ) {\n            return;\n          }\n          // removed node has not been serialized yet, just remove it from the Set\n          if (this.addedSet.has(n)) {\n            deepDelete(this.addedSet, n);\n            this.droppedSet.add(n);\n          } else if (this.addedSet.has(m.target) && nodeId === -1) {\n            /**\n             * If target was newly added and removed child node was\n             * not serialized, it means the child node has been removed\n             * before callback fired, so we can ignore it because\n             * newly added node will be serialized without child nodes.\n             * TODO: verify this\n             */\n          } else if (isAncestorRemoved(m.target as INode, this.mirror)) {\n            /**\n             * If parent id was not in the mirror map any more, it\n             * means the parent node has already been removed. So\n             * the node is also removed which we do not need to track\n             * and replay.\n             */\n          } else if (\n            this.movedSet.has(n) &&\n            this.movedMap[moveKey(nodeId, parentId)]\n          ) {\n            deepDelete(this.movedSet, n);\n          } else {\n            this.removes.push({\n              parentId,\n              id: nodeId,\n              isShadow: isShadowRoot(m.target) ? true : undefined,\n            });\n          }\n          this.mapRemoves.push(n);\n        });\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  private genAdds = (n: Node | INode, target?: Node | INode) => {\n    if (isBlocked(n, this.blockClass)) {\n      return;\n    }\n    if (target && isBlocked(target, this.blockClass)) {\n      return;\n    }\n    if (isINode(n)) {\n      if (isIgnored(n)) {\n        return;\n      }\n      this.movedSet.add(n);\n      let targetId: number | null = null;\n      if (target && isINode(target)) {\n        targetId = target.__sn.id;\n      }\n      if (targetId) {\n        this.movedMap[moveKey(n.__sn.id, targetId)] = true;\n      }\n    } else {\n      this.addedSet.add(n);\n      this.droppedSet.delete(n);\n    }\n    n.childNodes.forEach((childN) => this.genAdds(childN));\n  };\n}\n\n/**\n * Some utils to handle the mutation observer DOM records.\n * It should be more clear to extend the native data structure\n * like Set and Map, but currently Typescript does not support\n * that.\n */\nfunction deepDelete(addsSet: Set<Node>, n: Node) {\n  addsSet.delete(n);\n  n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\n\nfunction isParentRemoved(\n  removes: removedNodeMutation[],\n  n: Node,\n  mirror: Mirror,\n): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId((parentNode as Node) as INode);\n  if (removes.some((r) => r.id === parentId)) {\n    return true;\n  }\n  return isParentRemoved(removes, parentNode, mirror);\n}\n\nfunction isAncestorInSet(set: Set<Node>, n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return isAncestorInSet(set, parentNode);\n}\n","// tslint:disable:no-any no-bitwise forin\n/**\n * this file is used to serialize log message to string\n *\n */\n\nimport { StringifyOptions } from '../types';\n\n/**\n * transfer the node path in Event to string\n * @param node the first node in a node path array\n */\nfunction pathToSelector(node: HTMLElement): string | '' {\n  if (!node || !node.outerHTML) {\n    return '';\n  }\n\n  let path = '';\n  while (node.parentElement) {\n    let name = node.localName;\n    if (!name) {\n      break;\n    }\n    name = name.toLowerCase();\n    let parent = node.parentElement;\n\n    let domSiblings = [];\n\n    if (parent.children && parent.children.length > 0) {\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < parent.children.length; i++) {\n        let sibling = parent.children[i];\n        if (sibling.localName && sibling.localName.toLowerCase) {\n          if (sibling.localName.toLowerCase() === name) {\n            domSiblings.push(sibling);\n          }\n        }\n      }\n    }\n\n    if (domSiblings.length > 1) {\n      name += ':eq(' + domSiblings.indexOf(node) + ')';\n    }\n    path = name + (path ? '>' + path : '');\n    node = parent;\n  }\n\n  return path;\n}\n\n/**\n * stringify any js object\n * @param obj the object to stringify\n */\nexport function stringify(\n  obj: any,\n  stringifyOptions?: StringifyOptions,\n): string {\n  const options: StringifyOptions = {\n    numOfKeysLimit: 50,\n  };\n  Object.assign(options, stringifyOptions);\n  const stack: any[] = [];\n  const keys: any[] = [];\n  return JSON.stringify(obj, function (key, value) {\n    /**\n     * forked from https://github.com/moll/json-stringify-safe/blob/master/stringify.js\n     * to deCycle the object\n     */\n    if (stack.length > 0) {\n      const thisPos = stack.indexOf(this);\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n      if (~stack.indexOf(value)) {\n        if (stack[0] === value) {\n          value = '[Circular ~]';\n        } else {\n          value =\n            '[Circular ~.' +\n            keys.slice(0, stack.indexOf(value)).join('.') +\n            ']';\n        }\n      }\n    } else {\n      stack.push(value);\n    }\n    /* END of the FORK */\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n    if (shouldToString(value)) {\n      return toString(value);\n    }\n    if (value instanceof Event) {\n      const eventResult: any = {};\n      for (const eventKey in value) {\n        const eventValue = (value as any)[eventKey];\n        if (Array.isArray(eventValue)) {\n          eventResult[eventKey] = pathToSelector(\n            eventValue.length ? eventValue[0] : null,\n          );\n        } else {\n          eventResult[eventKey] = eventValue;\n        }\n      }\n      return eventResult;\n    } else if (value instanceof Node) {\n      if (value instanceof HTMLElement) {\n        return value ? value.outerHTML : '';\n      }\n      return value.nodeName;\n    }\n    return value;\n  });\n\n  /**\n   * whether we should call toString function of this object\n   */\n  function shouldToString(_obj: object): boolean {\n    if (\n      typeof _obj === 'object' &&\n      Object.keys(_obj).length > options.numOfKeysLimit\n    ) {\n      return true;\n    }\n    if (typeof _obj === 'function') {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * limit the toString() result according to option\n   */\n  function toString(_obj: object): string {\n    let str = _obj.toString();\n    if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n      str = `${str.slice(0, options.stringLengthLimit)}...`;\n    }\n    return str;\n  }\n}\n","/**\n * Class StackFrame is a fork of https://github.com/stacktracejs/stackframe/blob/master/stackframe.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n * 3. StackFrame contains some functions we don't need.\n */\nexport class StackFrame {\n  private fileName: string;\n  private functionName: string;\n  private lineNumber?: number;\n  private columnNumber?: number;\n\n  constructor(obj: {\n    fileName?: string;\n    functionName?: string;\n    lineNumber?: number;\n    columnNumber?: number;\n  }) {\n    this.fileName = obj.fileName || '';\n    this.functionName = obj.functionName || '';\n    this.lineNumber = obj.lineNumber;\n    this.columnNumber = obj.columnNumber;\n  }\n\n  toString() {\n    const lineNumber = this.lineNumber || '';\n    const columnNumber = this.columnNumber || '';\n    if (this.functionName) {\n      return (\n        this.functionName +\n        ' (' +\n        this.fileName +\n        ':' +\n        lineNumber +\n        ':' +\n        columnNumber +\n        ')'\n      );\n    }\n    return this.fileName + ':' + lineNumber + ':' + columnNumber;\n  }\n}\n\n/**\n * ErrorStackParser is a fork of https://github.com/stacktracejs/error-stack-parser/blob/master/error-stack-parser.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n */\nconst FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nexport const ErrorStackParser = {\n  /**\n   * Given an Error object, extract the most information from it.\n   *\n   * @param {Error} error object\n   * @return {Array} of StackFrames\n   */\n  parse: function (error: Error): StackFrame[] {\n    if (\n      // @ts-ignore\n      typeof error.stacktrace !== 'undefined' ||\n      // @ts-ignore\n      typeof error['opera#sourceloc'] !== 'undefined'\n    ) {\n      return this.parseOpera(\n        error as {\n          stacktrace?: string;\n          message: string;\n          stack?: string;\n        },\n      );\n    } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n      return this.parseV8OrIE(error as { stack: string });\n    } else if (error.stack) {\n      return this.parseFFOrSafari(error as { stack: string });\n    } else {\n      throw new Error('Cannot parse given Error object');\n    }\n  },\n  // Separate line and column numbers from a string of the form: (URI:Line:Column)\n  extractLocation: function (urlLike: string) {\n    // Fail-fast but return locations like \"(native)\"\n    if (urlLike.indexOf(':') === -1) {\n      return [urlLike];\n    }\n\n    const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n    const parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n    if (!parts) throw new Error(`Cannot parse given url: ${urlLike}`);\n    return [parts[1], parts[2] || undefined, parts[3] || undefined];\n  },\n  parseV8OrIE: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !!line.match(CHROME_IE_STACK_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      if (line.indexOf('(eval ') > -1) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        line = line\n          .replace(/eval code/g, 'eval')\n          .replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n      }\n      let sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n      // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n      // case it has spaces in it, as the string is split on \\s+ later on\n      const location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n      // remove the parenthesized location from the line, if it was matched\n      sanitizedLine = location\n        ? sanitizedLine.replace(location[0], '')\n        : sanitizedLine;\n\n      const tokens = sanitizedLine.split(/\\s+/).slice(1);\n      // if a location was matched, pass it to extractLocation() otherwise pop the last token\n      const locationParts = this.extractLocation(\n        location ? location[1] : tokens.pop(),\n      );\n      const functionName = tokens.join(' ') || undefined;\n      const fileName =\n        ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1\n          ? undefined\n          : locationParts[0];\n\n      return new StackFrame({\n        functionName,\n        fileName,\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n  parseFFOrSafari: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      // Throw away eval information until we implement stacktrace.js/stackframe#8\n      if (line.indexOf(' > eval') > -1) {\n        line = line.replace(\n          / line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,\n          ':$1',\n        );\n      }\n\n      if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n        // Safari eval frames only have function names and nothing else\n        return new StackFrame({\n          functionName: line,\n        });\n      } else {\n        const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n        const matches = line.match(functionNameRegex);\n        const functionName = matches && matches[1] ? matches[1] : undefined;\n        const locationParts = this.extractLocation(\n          line.replace(functionNameRegex, ''),\n        );\n\n        return new StackFrame({\n          functionName,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n        });\n      }\n    }, this);\n  },\n  parseOpera: function (e: {\n    stacktrace?: string;\n    message: string;\n    stack?: string;\n  }): StackFrame[] {\n    if (\n      !e.stacktrace ||\n      (e.message.indexOf('\\n') > -1 &&\n        e.message.split('\\n').length > e.stacktrace.split('\\n').length)\n    ) {\n      return this.parseOpera9(e as { message: string });\n    } else if (!e.stack) {\n      return this.parseOpera10(e as { stacktrace: string });\n    } else {\n      return this.parseOpera11(e as { stack: string });\n    }\n  },\n  parseOpera9: function (e: { message: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n    const lines = e.message.split('\\n');\n    const result = [];\n\n    for (let i = 2, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  parseOpera10: function (e: { stacktrace: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n    const lines = e.stacktrace.split('\\n');\n    const result = [];\n\n    for (let i = 0, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  // Opera 10.65+ Error.stack very similar to FF/Safari\n  parseOpera11: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return (\n        !!line.match(FIREFOX_SAFARI_STACK_REGEXP) &&\n        !line.match(/^Error created at/)\n      );\n    }, this);\n\n    return filtered.map(function (line: string) {\n      const tokens = line.split('@');\n      const locationParts = this.extractLocation(tokens.pop());\n      const functionCall = tokens.shift() || '';\n      const functionName =\n        functionCall\n          .replace(/<anonymous function(: (\\w+))?>/, '$2')\n          .replace(/\\([^)]*\\)/g, '') || undefined;\n      return new StackFrame({\n        functionName,\n        fileName: locationParts[0],\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n};\n","// @ts-nocheck\nimport { INode, MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { FontFaceDescriptors, FontFaceSet } from 'css-font-loading-module';\nimport {\n  throttle,\n  on,\n  hookSetter,\n  getWindowHeight,\n  getWindowWidth,\n  isBlocked,\n  isTouchEvent,\n  patch,\n} from '../utils';\nimport {\n  mutationCallBack,\n  observerParam,\n  mousemoveCallBack,\n  mousePosition,\n  mouseInteractionCallBack,\n  MouseInteractions,\n  listenerHandler,\n  scrollCallback,\n  styleSheetRuleCallback,\n  viewportResizeCallback,\n  inputValue,\n  inputCallback,\n  hookResetter,\n  blockClass,\n  maskTextClass,\n  IncrementalSource,\n  hooksParam,\n  Arguments,\n  mediaInteractionCallback,\n  MediaInteractions,\n  SamplingStrategy,\n  canvasMutationCallback,\n  fontCallback,\n  fontParam,\n  MaskInputFn,\n  MaskTextFn,\n  logCallback,\n  LogRecordOptions,\n  Logger,\n  LogLevel,\n  Mirror,\n} from '../types';\nimport MutationBuffer from './mutation';\nimport { stringify } from './stringify';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\nimport { StackFrame, ErrorStackParser } from './error-stack-parser';\n\ntype WindowWithStoredMutationObserver = Window & {\n  __rrMutationObserver?: MutationObserver;\n};\ntype WindowWithAngularZone = Window & {\n  Zone?: {\n    __symbol__?: (key: string) => string;\n  };\n};\n\nexport const mutationBuffers: MutationBuffer[] = [];\n\nexport function initMutationObserver(\n  cb: mutationCallBack,\n  doc: Document,\n  blockClass: blockClass,\n  blockSelector: string | null,\n  maskTextClass: maskTextClass,\n  maskTextSelector: string | null,\n  inlineStylesheet: boolean,\n  maskInputOptions: MaskInputOptions,\n  maskTextFn: MaskTextFn | undefined,\n  recordCanvas: boolean,\n  slimDOMOptions: SlimDOMOptions,\n  mirror: Mirror,\n  iframeManager: IframeManager,\n  shadowDomManager: ShadowDomManager,\n  rootEl: Node,\n): MutationObserver {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  // see mutation.ts for details\n  mutationBuffer.init(\n    cb,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    recordCanvas,\n    slimDOMOptions,\n    doc,\n    mirror,\n    iframeManager,\n    shadowDomManager,\n  );\n  let mutationObserverCtor =\n    window.MutationObserver ||\n    /**\n     * Some websites may disable MutationObserver by removing it from the window object.\n     * If someone is using rrweb to build a browser extention or things like it, they\n     * could not change the website's code but can have an opportunity to inject some\n     * code before the website executing its JS logic.\n     * Then they can do this to store the native MutationObserver:\n     * window.__rrMutationObserver = MutationObserver\n     */\n    (window as WindowWithStoredMutationObserver).__rrMutationObserver;\n  const angularZoneSymbol = (window as WindowWithAngularZone)?.Zone?.__symbol__?.(\n    'MutationObserver',\n  );\n  if (\n    angularZoneSymbol &&\n    ((window as unknown) as Record<string, typeof MutationObserver>)[\n    angularZoneSymbol\n    ]\n  ) {\n    mutationObserverCtor = ((window as unknown) as Record<\n      string,\n      typeof MutationObserver\n    >)[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    mutationBuffer.processMutations.bind(mutationBuffer),\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  return observer;\n}\n\nfunction initMoveObserver(\n  cb: mousemoveCallBack,\n  sampling: SamplingStrategy,\n  doc: Document,\n  mirror: Mirror,\n): listenerHandler {\n  if (sampling.mousemove === false) {\n    return () => { };\n  }\n\n  const threshold =\n    typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\n  const callbackThreshold =\n    typeof sampling.mousemoveCallback === 'number'\n      ? sampling.mousemoveCallback\n      : 500;\n\n  let positions: mousePosition[] = [];\n  let timeBaseline: number | null;\n  const wrappedCb = throttle(\n    (\n      source:\n        | IncrementalSource.MouseMove\n        | IncrementalSource.TouchMove\n        | IncrementalSource.Drag,\n    ) => {\n      const totalOffset = Date.now() - timeBaseline!;\n      cb(\n        positions.map((p) => {\n          p.timeOffset -= totalOffset;\n          return p;\n        }),\n        source,\n      );\n      positions = [];\n      timeBaseline = null;\n    },\n    callbackThreshold,\n  );\n  const updatePosition = throttle<MouseEvent | TouchEvent | DragEvent>(\n    (evt) => {\n      const { target } = evt;\n      const { clientX, clientY } = isTouchEvent(evt)\n        ? evt.changedTouches[0]\n        : evt;\n      if (!timeBaseline) {\n        timeBaseline = Date.now();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror.getId(target as INode),\n        timeOffset: Date.now() - timeBaseline,\n      });\n      wrappedCb(\n        evt instanceof MouseEvent\n          ? IncrementalSource.MouseMove\n          : evt instanceof DragEvent\n            ? IncrementalSource.Drag\n            : IncrementalSource.TouchMove,\n      );\n    },\n    threshold,\n    {\n      trailing: false,\n    },\n  );\n  const handlers = [\n    on('mousemove', updatePosition, doc),\n    on('touchmove', updatePosition, doc),\n    on('drag', updatePosition, doc),\n  ];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initMouseInteractionObserver(\n  cb: mouseInteractionCallBack,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  if (sampling.mouseInteraction === false) {\n    return () => { };\n  }\n  const disableMap: Record<string, boolean | undefined> =\n    sampling.mouseInteraction === true ||\n      sampling.mouseInteraction === undefined\n      ? {}\n      : sampling.mouseInteraction;\n\n  const handlers: listenerHandler[] = [];\n  const getHandler = (eventKey: keyof typeof MouseInteractions) => {\n    return (event: MouseEvent | TouchEvent) => {\n      if (isBlocked(event.target as Node, blockClass)) {\n        return;\n      }\n      const e = isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e) {\n        return;\n      }\n      const id = mirror.getId(event.target as INode);\n      const { clientX, clientY } = e;\n      cb({\n        type: MouseInteractions[eventKey],\n        id,\n        x: clientX,\n        y: clientY,\n      });\n    };\n  };\n  Object.keys(MouseInteractions)\n    .filter(\n      (key) =>\n        Number.isNaN(Number(key)) &&\n        !key.endsWith('_Departed') &&\n        disableMap[key] !== false,\n    )\n    .forEach((eventKey: keyof typeof MouseInteractions) => {\n      const eventName = eventKey.toLowerCase();\n      const handler = getHandler(eventKey);\n      handlers.push(on(eventName, handler, doc));\n    });\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initScrollObserver(\n  cb: scrollCallback,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  const updatePosition = throttle<UIEvent>((evt) => {\n    if (!evt.target || isBlocked(evt.target as Node, blockClass)) {\n      return;\n    }\n    const id = mirror.getId(evt.target as INode);\n    if (evt.target === doc) {\n      const scrollEl = (doc.scrollingElement || doc.documentElement)!;\n      cb({\n        id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n      });\n    } else {\n      cb({\n        id,\n        x: (evt.target as HTMLElement).scrollLeft,\n        y: (evt.target as HTMLElement).scrollTop,\n      });\n    }\n  }, sampling.scroll || 100);\n  return on('scroll', updatePosition);\n}\n\nfunction initViewportResizeObserver(\n  cb: viewportResizeCallback,\n): listenerHandler {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = throttle(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    if (lastH !== height || lastW !== width) {\n      cb({\n        width: Number(width),\n        height: Number(height),\n      });\n      lastH = height;\n      lastW = width;\n    }\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nexport const INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nconst lastInputValueMap: WeakMap<EventTarget, inputValue> = new WeakMap();\nfunction initInputObserver(\n  cb: inputCallback,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  ignoreClass: string,\n  maskInputOptions: MaskInputOptions,\n  maskInputFn: MaskInputFn | undefined,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  function eventHandler(event: Event) {\n    const { target } = event;\n    if (\n      !target ||\n      !(target as Element).tagName ||\n      INPUT_TAGS.indexOf((target as Element).tagName) < 0 ||\n      isBlocked(target as Node, blockClass)\n    ) {\n      return;\n    }\n    const type: string | undefined = (target as HTMLInputElement).type;\n    if (\n      type === 'password' ||\n      (target as HTMLElement).classList.contains(ignoreClass)\n    ) {\n      return;\n    }\n    let text = (target as HTMLInputElement).value;\n    let isChecked = false;\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = (target as HTMLInputElement).checked;\n    } else if (\n      maskInputOptions[\n      (target as Element).tagName.toLowerCase() as keyof MaskInputOptions\n      ] ||\n      maskInputOptions[type as keyof MaskInputOptions]\n    ) {\n      if (maskInputFn) {\n        text = maskInputFn(text);\n      } else {\n        text = '*'.repeat(text.length);\n      }\n    }\n    cbWithDedup(target, { text, isChecked });\n    // if a radio was checked\n    // the other radios with the same name attribute will be unchecked.\n    const name: string | undefined = (target as HTMLInputElement).name;\n    if (type === 'radio' && name && isChecked) {\n      doc\n        .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\n        .forEach((el) => {\n          if (el !== target) {\n            cbWithDedup(el, {\n              text: (el as HTMLInputElement).value,\n              isChecked: !isChecked,\n            });\n          }\n        });\n    }\n  }\n  function cbWithDedup(target: EventTarget, v: inputValue) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (\n      !lastInputValue ||\n      lastInputValue.text !== v.text ||\n      lastInputValue.isChecked !== v.isChecked\n    ) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target as INode);\n      cb({\n        ...v,\n        id,\n      });\n    }\n  }\n  const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\n  const handlers: Array<\n    listenerHandler | hookResetter\n  > = events.map((eventName) => on(eventName, eventHandler, doc));\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    HTMLInputElement.prototype,\n    'value',\n  );\n  const hookProperties: Array<[HTMLElement, string]> = [\n    [HTMLInputElement.prototype, 'value'],\n    [HTMLInputElement.prototype, 'checked'],\n    [HTMLSelectElement.prototype, 'value'],\n    [HTMLTextAreaElement.prototype, 'value'],\n    // Some UI library use selectedIndex to set select value\n    [HTMLSelectElement.prototype, 'selectedIndex'],\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map((p) =>\n        hookSetter<HTMLElement>(p[0], p[1], {\n          set() {\n            // mock to a normal event\n            eventHandler({ target: this } as Event);\n          },\n        }),\n      ),\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initStyleSheetObserver(\n  cb: styleSheetRuleCallback,\n  mirror: Mirror,\n): listenerHandler {\n  const insertRule = CSSStyleSheet.prototype.insertRule;\n  CSSStyleSheet.prototype.insertRule = function (rule: string, index?: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        adds: [{ rule, index }],\n      });\n    }\n    return insertRule.apply(this, arguments);\n  };\n\n  const deleteRule = CSSStyleSheet.prototype.deleteRule;\n  CSSStyleSheet.prototype.deleteRule = function (index: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        removes: [{ index }],\n      });\n    }\n    return deleteRule.apply(this, arguments);\n  };\n\n  return () => {\n    CSSStyleSheet.prototype.insertRule = insertRule;\n    CSSStyleSheet.prototype.deleteRule = deleteRule;\n  };\n}\n\nfunction initMediaInteractionObserver(\n  mediaInteractionCb: mediaInteractionCallback,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const handler = (type: 'play' | 'pause') => (event: Event) => {\n    const { target } = event;\n    if (!target || isBlocked(target as Node, blockClass)) {\n      return;\n    }\n    mediaInteractionCb({\n      type: type === 'play' ? MediaInteractions.Play : MediaInteractions.Pause,\n      id: mirror.getId(target as INode),\n    });\n  };\n  const handlers = [on('play', handler('play')), on('pause', handler('pause'))];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initCanvasMutationObserver(\n  cb: canvasMutationCallback,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const props = Object.getOwnPropertyNames(CanvasRenderingContext2D.prototype);\n  const handlers: listenerHandler[] = [];\n  for (const prop of props) {\n    try {\n      if (\n        typeof CanvasRenderingContext2D.prototype[\n        prop as keyof CanvasRenderingContext2D\n        ] !== 'function'\n      ) {\n        continue;\n      }\n      const restoreHandler = patch(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        function (original) {\n          return function (\n            this: CanvasRenderingContext2D,\n            ...args: Array<unknown>\n          ) {\n            if (!isBlocked(this.canvas, blockClass)) {\n              setTimeout(() => {\n                const recordArgs = [...args];\n                if (prop === 'drawImage') {\n                  if (\n                    recordArgs[0] &&\n                    recordArgs[0] instanceof HTMLCanvasElement\n                  ) {\n                    recordArgs[0] = recordArgs[0].toDataURL();\n                  }\n                }\n                cb({\n                  id: mirror.getId((this.canvas as unknown) as INode),\n                  property: prop,\n                  args: recordArgs,\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        },\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter<CanvasRenderingContext2D>(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v) {\n            cb({\n              id: mirror.getId((this.canvas as unknown) as INode),\n              property: prop,\n              args: [v],\n              setter: true,\n            });\n          },\n        },\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initFontObserver(cb: fontCallback): listenerHandler {\n  const handlers: listenerHandler[] = [];\n\n  const fontMap = new WeakMap<FontFace, fontParam>();\n\n  const originalFontFace = FontFace;\n  // tslint:disable-next-line: no-any\n  (window as any).FontFace = function FontFace(\n    family: string,\n    source: string | ArrayBufferView,\n    descriptors?: FontFaceDescriptors,\n  ) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== 'string',\n      descriptors,\n      fontSource:\n        typeof source === 'string'\n          ? source\n          : // tslint:disable-next-line: no-any\n          JSON.stringify(Array.from(new Uint8Array(source as any))),\n    });\n    return fontFace;\n  };\n\n  const restoreHandler = patch(document.fonts, 'add', function (original) {\n    return function (this: FontFaceSet, fontFace: FontFace) {\n      setTimeout(() => {\n        const p = fontMap.get(fontFace);\n        if (p) {\n          cb(p);\n          fontMap.delete(fontFace);\n        }\n      }, 0);\n      return original.apply(this, [fontFace]);\n    };\n  });\n\n  handlers.push(() => {\n    // tslint:disable-next-line: no-any\n    (window as any).FonFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initLogObserver(\n  cb: logCallback,\n  logOptions: LogRecordOptions,\n): listenerHandler {\n  const logger = logOptions.logger;\n  if (!logger) {\n    return () => { };\n  }\n  let logCount = 0;\n  const cancelHandlers: listenerHandler[] = [];\n  // add listener to thrown errors\n  if (logOptions.level!.includes('error')) {\n    if (window) {\n      const originalOnError = window.onerror;\n      window.onerror = (\n        msg: Event | string,\n        file: string,\n        line: number,\n        col: number,\n        error: Error,\n      ) => {\n        if (originalOnError) {\n          originalOnError.apply(this, [msg, file, line, col, error]);\n        }\n        const trace: string[] = ErrorStackParser.parse(\n          error,\n        ).map((stackFrame: StackFrame) => stackFrame.toString());\n        const payload = [stringify(msg, logOptions.stringifyOptions)];\n        cb({\n          level: 'error',\n          trace,\n          payload,\n        });\n      };\n      cancelHandlers.push(() => {\n        window.onerror = originalOnError;\n      });\n    }\n  }\n  for (const levelType of logOptions.level!) {\n    cancelHandlers.push(replace(logger, levelType));\n  }\n  return () => {\n    cancelHandlers.forEach((h) => h());\n  };\n\n  /**\n   * replace the original console function and record logs\n   * @param logger the logger object such as Console\n   * @param level the name of log function to be replaced\n   */\n  function replace(_logger: Logger, level: LogLevel) {\n    if (!_logger[level]) {\n      return () => { };\n    }\n    // replace the logger.{level}. return a restore function\n    return patch(_logger, level, (original) => {\n      return (...args: unknown[]) => {\n        original.apply(this, args);\n        try {\n          const trace = ErrorStackParser.parse(new Error())\n            .map((stackFrame: StackFrame) => stackFrame.toString())\n            .splice(1); // splice(1) to omit the hijacked log function\n          const payload = args.map((s) =>\n            stringify(s, logOptions.stringifyOptions),\n          );\n          logCount++;\n          if (logCount < logOptions.lengthThreshold!) {\n            cb({\n              level,\n              trace,\n              payload,\n            });\n          } else if (logCount === logOptions.lengthThreshold) {\n            // notify the user\n            cb({\n              level: 'warn',\n              trace: [],\n              payload: [\n                stringify('The number of log records reached the threshold.'),\n              ],\n            });\n          }\n        } catch (error) {\n          original('rrweb logger error:', error, ...args);\n        }\n      };\n    });\n  }\n}\n\nfunction mergeHooks(o: observerParam, hooks: hooksParam) {\n  const {\n    mutationCb,\n    mousemoveCb,\n    mouseInteractionCb,\n    scrollCb,\n    viewportResizeCb,\n    inputCb,\n    mediaInteractionCb,\n    styleSheetRuleCb,\n    canvasMutationCb,\n    fontCb,\n    logCb,\n  } = o;\n  o.mutationCb = (...p: Arguments<mutationCallBack>) => {\n    if (hooks.mutation) {\n      hooks.mutation(...p);\n    }\n    mutationCb(...p);\n  };\n  o.mousemoveCb = (...p: Arguments<mousemoveCallBack>) => {\n    if (hooks.mousemove) {\n      hooks.mousemove(...p);\n    }\n    mousemoveCb(...p);\n  };\n  o.mouseInteractionCb = (...p: Arguments<mouseInteractionCallBack>) => {\n    if (hooks.mouseInteraction) {\n      hooks.mouseInteraction(...p);\n    }\n    mouseInteractionCb(...p);\n  };\n  o.scrollCb = (...p: Arguments<scrollCallback>) => {\n    if (hooks.scroll) {\n      hooks.scroll(...p);\n    }\n    scrollCb(...p);\n  };\n  o.viewportResizeCb = (...p: Arguments<viewportResizeCallback>) => {\n    if (hooks.viewportResize) {\n      hooks.viewportResize(...p);\n    }\n    viewportResizeCb(...p);\n  };\n  o.inputCb = (...p: Arguments<inputCallback>) => {\n    if (hooks.input) {\n      hooks.input(...p);\n    }\n    inputCb(...p);\n  };\n  o.mediaInteractionCb = (...p: Arguments<mediaInteractionCallback>) => {\n    if (hooks.mediaInteaction) {\n      hooks.mediaInteaction(...p);\n    }\n    mediaInteractionCb(...p);\n  };\n  o.styleSheetRuleCb = (...p: Arguments<styleSheetRuleCallback>) => {\n    if (hooks.styleSheetRule) {\n      hooks.styleSheetRule(...p);\n    }\n    styleSheetRuleCb(...p);\n  };\n  o.canvasMutationCb = (...p: Arguments<canvasMutationCallback>) => {\n    if (hooks.canvasMutation) {\n      hooks.canvasMutation(...p);\n    }\n    canvasMutationCb(...p);\n  };\n  o.fontCb = (...p: Arguments<fontCallback>) => {\n    if (hooks.font) {\n      hooks.font(...p);\n    }\n    fontCb(...p);\n  };\n  o.logCb = (...p: Arguments<logCallback>) => {\n    if (hooks.log) {\n      hooks.log(...p);\n    }\n    logCb(...p);\n  };\n}\n\nexport function initObservers(\n  o: observerParam,\n  hooks: hooksParam = {},\n): listenerHandler {\n  mergeHooks(o, hooks);\n  const mutationObserver = initMutationObserver(\n    o.mutationCb,\n    o.doc,\n    o.blockClass,\n    o.blockSelector,\n    o.maskTextClass,\n    o.maskTextSelector,\n    o.inlineStylesheet,\n    o.maskInputOptions,\n    o.maskTextFn,\n    o.recordCanvas,\n    o.slimDOMOptions,\n    o.mirror,\n    o.iframeManager,\n    o.shadowDomManager,\n    o.doc,\n  );\n  const mousemoveHandler = initMoveObserver(\n    o.mousemoveCb,\n    o.sampling,\n    o.doc,\n    o.mirror,\n  );\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.sampling,\n  );\n  const scrollHandler = initScrollObserver(\n    o.scrollCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.sampling,\n  );\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);\n  const inputHandler = initInputObserver(\n    o.inputCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.ignoreClass,\n    o.maskInputOptions,\n    o.maskInputFn,\n    o.sampling,\n  );\n  const mediaInteractionHandler = initMediaInteractionObserver(\n    o.mediaInteractionCb,\n    o.blockClass,\n    o.mirror,\n  );\n  const styleSheetObserver = initStyleSheetObserver(\n    o.styleSheetRuleCb,\n    o.mirror,\n  );\n  const canvasMutationObserver = o.recordCanvas\n    ? initCanvasMutationObserver(o.canvasMutationCb, o.blockClass, o.mirror)\n    : () => { };\n  const fontObserver = o.collectFonts ? initFontObserver(o.fontCb) : () => { };\n  const logObserver = o.logOptions\n    ? initLogObserver(o.logCb, o.logOptions)\n    : () => { };\n\n  return () => {\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    canvasMutationObserver();\n    fontObserver();\n    logObserver();\n  };\n}\n","import { serializedNodeWithId, INode } from '../snapshot';\nimport { mutationCallBack } from '../types';\n\nexport class IframeManager {\n  private iframes: WeakMap<HTMLIFrameElement, true> = new WeakMap();\n  private mutationCb: mutationCallBack;\n  private loadListener?: (iframeEl: HTMLIFrameElement) => unknown;\n\n  constructor(options: { mutationCb: mutationCallBack }) {\n    this.mutationCb = options.mutationCb;\n  }\n\n  public addIframe(iframeEl: HTMLIFrameElement) {\n    this.iframes.set(iframeEl, true);\n  }\n\n  public addLoadListener(cb: (iframeEl: HTMLIFrameElement) => unknown) {\n    this.loadListener = cb;\n  }\n\n  public attachIframe(iframeEl: INode, childSn: serializedNodeWithId) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: iframeEl.__sn.id,\n          nextId: null,\n          node: childSn,\n        },\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true,\n    });\n    this.loadListener?.((iframeEl as unknown) as HTMLIFrameElement);\n  }\n}\n","import {\n  mutationCallBack,\n  blockClass,\n  maskTextClass,\n  MaskTextFn,\n  Mirror,\n} from '../types';\nimport { MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { IframeManager } from './iframe-manager';\nimport { initMutationObserver } from './observer';\n\ntype BypassOptions = {\n  blockClass: blockClass;\n  blockSelector: string | null;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  inlineStylesheet: boolean;\n  maskInputOptions: MaskInputOptions;\n  maskTextFn: MaskTextFn | undefined;\n  recordCanvas: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  iframeManager: IframeManager;\n};\n\nexport class ShadowDomManager {\n  private mutationCb: mutationCallBack;\n  private bypassOptions: BypassOptions;\n  private mirror: Mirror;\n\n  constructor(options: {\n    mutationCb: mutationCallBack;\n    bypassOptions: BypassOptions;\n    mirror: Mirror;\n  }) {\n    this.mutationCb = options.mutationCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n  }\n\n  public addShadowRoot(shadowRoot: ShadowRoot, doc: Document) {\n    initMutationObserver(\n      this.mutationCb,\n      doc,\n      this.bypassOptions.blockClass,\n      this.bypassOptions.blockSelector,\n      this.bypassOptions.maskTextClass,\n      this.bypassOptions.maskTextSelector,\n      this.bypassOptions.inlineStylesheet,\n      this.bypassOptions.maskInputOptions,\n      this.bypassOptions.maskTextFn,\n      this.bypassOptions.recordCanvas,\n      this.bypassOptions.slimDOMOptions,\n      this.mirror,\n      this.bypassOptions.iframeManager,\n      this,\n      shadowRoot,\n    );\n  }\n}\n","import { snapshot, MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { initObservers, mutationBuffers } from './observer';\nimport {\n  on,\n  getWindowWidth,\n  getWindowHeight,\n  polyfill,\n  isIframeINode,\n  hasShadowRoot,\n  createMirror,\n} from '../utils';\nimport {\n  EventType,\n  event,\n  eventWithTime,\n  recordOptions,\n  IncrementalSource,\n  listenerHandler,\n  LogRecordOptions,\n  mutationCallbackParam,\n} from '../types';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\n\nfunction wrapEvent(e: event): eventWithTime {\n  return {\n    ...e,\n    timestamp: Date.now(),\n  };\n}\n\nlet wrappedEmit!: (e: eventWithTime, isCheckout?: boolean) => void;\n\nlet takeFullSnapshot!: (isCheckout?: boolean) => void;\n\nconst mirror = createMirror();\nfunction record<T = eventWithTime>(\n  options: recordOptions<T> = {},\n): listenerHandler | undefined {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = 'rr-block',\n    blockSelector = null,\n    ignoreClass = 'rr-ignore',\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskInputFn,\n    maskTextFn,\n    hooks,\n    packFn,\n    sampling = {},\n    mousemoveWait,\n    recordCanvas = false,\n    collectFonts = false,\n    recordLog = false,\n  } = options;\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n  // move departed options to new options\n  if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n    sampling.mousemove = mousemoveWait;\n  }\n\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n        }\n      : _maskInputOptions !== undefined\n      ? _maskInputOptions\n      : {};\n\n  const slimDOMOptions: SlimDOMOptions =\n    _slimDOMOptions === true || _slimDOMOptions === 'all'\n      ? {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaVerification: true,\n          // the following are off for slimDOMOptions === true,\n          // as they destroy some (hidden) info:\n          headMetaAuthorship: _slimDOMOptions === 'all',\n          headMetaDescKeywords: _slimDOMOptions === 'all',\n        }\n      : _slimDOMOptions\n      ? _slimDOMOptions\n      : {};\n  const defaultLogOptions: LogRecordOptions = {\n    level: [\n      'assert',\n      'clear',\n      'count',\n      'countReset',\n      'debug',\n      'dir',\n      'dirxml',\n      // 'error',\n      'group',\n      'groupCollapsed',\n      'groupEnd',\n      'info',\n      'log',\n      'table',\n      'time',\n      'timeEnd',\n      'timeLog',\n      'trace',\n      'warn',\n    ],\n    lengthThreshold: 1000,\n    logger: console,\n  };\n\n  const logOptions: LogRecordOptions = recordLog\n    ? recordLog === true\n      ? defaultLogOptions\n      : Object.assign({}, defaultLogOptions, recordLog)\n    : {};\n\n  polyfill();\n\n  let lastFullSnapshotEvent: eventWithTime;\n  let incrementalSnapshotCount = 0;\n  wrappedEmit = (e: eventWithTime, isCheckout?: boolean) => {\n    if (\n      mutationBuffers[0]?.isFrozen() &&\n      e.type !== EventType.FullSnapshot &&\n      !(\n        e.type === EventType.IncrementalSnapshot &&\n        e.data.source === IncrementalSource.Mutation\n      )\n    ) {\n      // we've got a user initiated event so first we need to apply\n      // all DOM changes that have been buffering during paused state\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n\n    emit(((packFn ? packFn(e) : e) as unknown) as T, isCheckout);\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      // attch iframe should be considered as full snapshot\n      if (\n        e.data.source === IncrementalSource.Mutation &&\n        e.data.isAttachIframe\n      ) {\n        return;\n      }\n\n      incrementalSnapshotCount++;\n      const exceedCount =\n        checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime =\n        checkoutEveryNms &&\n        e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  const wrappedMutationEmit = (m: mutationCallbackParam) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.Mutation,\n          ...m,\n        },\n      }),\n    );\n  };\n\n  const iframeManager = new IframeManager({\n    mutationCb: wrappedMutationEmit,\n  });\n\n  const shadowDomManager = new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    bypassOptions: {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      recordCanvas,\n      slimDOMOptions,\n      iframeManager,\n    },\n    mirror,\n  });\n\n  takeFullSnapshot = (isCheckout = false) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight(),\n        },\n      }),\n      isCheckout,\n    );\n\n    mutationBuffers.forEach((buf) => buf.lock()); // don't allow any mirror modifications during snapshotting\n    const [node, idNodeMap] = snapshot(document, {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      recordCanvas,\n      onSerialize: (n) => {\n        if (isIframeINode(n)) {\n          iframeManager.addIframe(n);\n        }\n        if (hasShadowRoot(n)) {\n          shadowDomManager.addShadowRoot(n.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n      },\n    });\n\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n\n    mirror.map = idNodeMap;\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: {\n            left:\n              window.pageXOffset !== undefined\n                ? window.pageXOffset\n                : document?.documentElement.scrollLeft ||\n                  document?.body?.parentElement?.scrollLeft ||\n                  document?.body.scrollLeft ||\n                  0,\n            top:\n              window.pageYOffset !== undefined\n                ? window.pageYOffset\n                : document?.documentElement.scrollTop ||\n                  document?.body?.parentElement?.scrollTop ||\n                  document?.body.scrollTop ||\n                  0,\n          },\n        },\n      }),\n    );\n    mutationBuffers.forEach((buf) => buf.unlock()); // generate & emit any mutations that happened during snapshotting, as can now apply against the newly built mirror\n  };\n\n  try {\n    const handlers: listenerHandler[] = [];\n    handlers.push(\n      on('DOMContentLoaded', () => {\n        wrappedEmit(\n          wrapEvent({\n            type: EventType.DomContentLoaded,\n            data: {},\n          }),\n        );\n      }),\n    );\n\n    const observe = (doc: Document) => {\n      return initObservers(\n        {\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source,\n                  positions,\n                },\n              }),\n            ),\n          mouseInteractionCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MouseInteraction,\n                  ...d,\n                },\n              }),\n            ),\n          scrollCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Scroll,\n                  ...p,\n                },\n              }),\n            ),\n          viewportResizeCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.ViewportResize,\n                  ...d,\n                },\n              }),\n            ),\n          inputCb: (v) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Input,\n                  ...v,\n                },\n              }),\n            ),\n          mediaInteractionCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MediaInteraction,\n                  ...p,\n                },\n              }),\n            ),\n          styleSheetRuleCb: (r) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.StyleSheetRule,\n                  ...r,\n                },\n              }),\n            ),\n          canvasMutationCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.CanvasMutation,\n                  ...p,\n                },\n              }),\n            ),\n          fontCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Font,\n                  ...p,\n                },\n              }),\n            ),\n          logCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Log,\n                  ...p,\n                },\n              }),\n            ),\n          blockClass,\n          ignoreClass,\n          maskTextClass,\n          maskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordCanvas,\n          collectFonts,\n          doc,\n          maskInputFn,\n          maskTextFn,\n          logOptions,\n          blockSelector,\n          slimDOMOptions,\n          mirror,\n          iframeManager,\n          shadowDomManager,\n        },\n        hooks,\n      );\n    };\n\n    iframeManager.addLoadListener((iframeEl) => {\n      handlers.push(observe(iframeEl.contentDocument!));\n    });\n\n    const init = () => {\n      takeFullSnapshot();\n      handlers.push(observe(document));\n    };\n    if (\n      document.readyState === 'interactive' ||\n      document.readyState === 'complete'\n    ) {\n      init();\n    } else {\n      handlers.push(\n        on(\n          'load',\n          () => {\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.Load,\n                data: {},\n              }),\n            );\n            init();\n          },\n          window,\n        ),\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  } catch (error) {\n    // TODO: handle internal error\n    console.warn(error);\n  }\n}\n\nrecord.addCustomEvent = <T>(tag: string, payload: T) => {\n  if (!wrappedEmit) {\n    throw new Error('please add custom event after start recording');\n  }\n  wrappedEmit(\n    wrapEvent({\n      type: EventType.Custom,\n      data: {\n        tag,\n        payload,\n      },\n    }),\n  );\n};\n\nrecord.freezePage = () => {\n  mutationBuffers.forEach((buf) => buf.freeze());\n};\n\nrecord.takeFullSnapshot = (isCheckout?: boolean) => {\n  if (!takeFullSnapshot) {\n    throw new Error('please take full snapshot after start recording');\n  }\n  takeFullSnapshot(isCheckout);\n};\n\nrecord.mirror = mirror;\n\nexport default record;\n","// @ts-nocheck\n// Mediocre shim\nlet Worker: typeof import('worker_threads').Worker;\nconst workerAdd = \";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global\";\n\ntry {\n  Worker = require('worker_threads').Worker;\n} catch(e) {\n}\nexport default Worker ? <T>(c: string, _: number, msg: unknown, transfer: ArrayBuffer[], cb: (err: Error, msg: T) => void) => {\n  let done = false;\n  const w = new Worker(c + workerAdd, { eval: true })\n    .on('error', e => cb(e, null))\n    .on('message', m => cb(null, m))\n    .on('exit', c => {\n      if (c && !done) cb(new Error('exited with code ' + c), null);\n    });\n  w.postMessage(msg, transfer);\n  w.terminate = () => {\n    done = true;\n    return Worker.prototype.terminate.call(w);\n  }\n  return w;\n} : (_: string, __: number, ___: unknown, ____: ArrayBuffer[], cb: (err: Error, msg: null) => void) => {\n  setImmediate(() => cb(new Error('async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)'), null));\n  const NOP = () => {};\n  return {\n    terminate: NOP,\n    postMessage: NOP\n  } as unknown as import('worker_threads').Worker;\n}","// @ts-nocheck\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\n\nimport wk from './node-worker';\n\n// aliases for shorter compressed code (most minifers don't do this)\nconst u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n\n// fixed length extra bits\nconst fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n\n// fixed distance extra bits\n// see fleb note\nconst fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n\n// code length index map\nconst clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n// get base, reverse index map from extra bits\nconst freb = (eb: Uint8Array, start: number) => {\n  const b = new u16(31);\n  for (let i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  }\n  // numbers here are at max 18 bits\n  const r = new u32(b[30]);\n  for (let i = 1; i < 30; ++i) {\n    for (let j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = ((j - b[i]) << 5) | i;\n    }\n  }\n  return [b, r] as const;\n}\n\nconst [fl, revfl] = freb(fleb, 2);\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nconst [fd, revfd] = freb(fdeb, 0);\n\n// map of value to reverse (assuming 16 bits)\nconst rev = new u16(32768);\nfor (let i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  let x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n  x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n  x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n  rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nconst hMap = ((cd: Uint8Array, mb: number, r: 0 | 1) => {\n  const s = cd.length;\n  // index\n  let i = 0;\n  // u16 \"map\": index -> # of codes with bit length = index\n  const l = new u16(mb);\n  // length of cd must be 288 (total # of codes)\n  for (; i < s; ++i) ++l[cd[i] - 1];\n  // u16 \"map\": index -> minimum code for bit length = index\n  const le = new u16(mb);\n  for (i = 0; i < mb; ++i) {\n    le[i] = (le[i - 1] + l[i - 1]) << 1;\n  }\n  let co: Uint16Array;\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb);\n    // bits to remove for reverser\n    const rvb = 15 - mb;\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        const sv = (i << 4) | cd[i];\n        // free bits\n        const r = mb - cd[i];\n        // start value\n        let v = le[cd[i] - 1]++ << r;\n        // m is end value\n        for (const m = v | ((1 << r) - 1); v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n      }\n    }\n  }\n  return co;\n});\n\n// fixed length tree\nconst flt = new u8(288);\nfor (let i = 0; i < 144; ++i) flt[i] = 8;\nfor (let i = 144; i < 256; ++i) flt[i] = 9;\nfor (let i = 256; i < 280; ++i) flt[i] = 7;\nfor (let i = 280; i < 288; ++i) flt[i] = 8;\n// fixed distance tree\nconst fdt = new u8(32);\nfor (let i = 0; i < 32; ++i) fdt[i] = 5;\n// fixed length map\nconst flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nconst fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n\n// find max of array\nconst max = (a: Uint8Array | number[]) => {\n  let m = a[0];\n  for (let i = 1; i < a.length; ++i) {\n    if (a[i] > m) m = a[i];\n  }\n  return m;\n};\n\n// read d, starting at bit p and mask with m\nconst bits = (d: Uint8Array, p: number, m: number) => {\n  const o = (p / 8) | 0;\n  return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n}\n\n// read d, starting at bit p continuing for at least 16 bits\nconst bits16 = (d: Uint8Array, p: number) => {\n  const o = (p / 8) | 0;\n  return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n}\n\n// get end of byte\nconst shft = (p: number) => ((p / 8) | 0) + (p & 7 && 1);\n\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nconst slc = <T extends Uint8Array | Uint16Array | Uint32Array>(v: T, s: number, e?: number): T => {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length;\n  // can't use .constructor in case user-supplied\n  const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s) as T;\n  n.set(v.subarray(s, e));\n  return n;\n}\n\n// inflate state\ntype InflateState = {\n  // lmap\n  l?: Uint16Array;\n  // dmap\n  d?: Uint16Array;\n  // lbits\n  m?: number;\n  // dbits\n  n?: number;\n  // final\n  f?: number;\n  // pos\n  p?: number;\n  // byte\n  b?: number;\n  // lstchk\n  i?: boolean;\n};\n\n/**\n * Codes for errors generated within this library\n */\nexport const FlateErrorCode = {\n  UnexpectedEOF: 0,\n  InvalidBlockType: 1,\n  InvalidLengthLiteral: 2,\n  InvalidDistance: 3,\n  StreamFinished: 4,\n  NoStreamHandler: 5,\n  InvalidHeader: 6,\n  NoCallback: 7,\n  InvalidUTF8: 8,\n  ExtraFieldTooLong: 9,\n  InvalidDate: 10,\n  FilenameTooLong: 11,\n  StreamFinishing: 12,\n  InvalidZipData: 13,\n  UnknownCompressionMethod: 14\n} as const;\n\n// error codes\nconst ec = [\n  'unexpected EOF',\n  'invalid block type',\n  'invalid length/literal',\n  'invalid distance',\n  'stream finished',\n  'no stream handler',\n  , // determined by compression function\n  'no callback',\n  'invalid UTF-8 data',\n  'extra field too long',\n  'date not in range 1980-2099',\n  'filename too long',\n  'stream finishing',\n  'invalid zip data'\n  // determined by unknown compression method\n];\n\n/**\n * An error generated within this library\n */\nexport interface FlateError extends Error {\n  /**\n   * The code associated with this error\n   */\n  code: number;\n};\n\nconst err = (ind: number, msg?: string | 0, nt?: 1) => {\n  const e: Partial<FlateError> = new Error(msg || ec[ind]);\n  e.code = ind;\n  if (Error.captureStackTrace) Error.captureStackTrace(e, err);\n  if (!nt) throw e;\n  return e as FlateError;\n}\n\n// expands raw DEFLATE data\nconst inflt = (dat: Uint8Array, buf?: Uint8Array, st?: InflateState) => {\n  // source length\n  const sl = dat.length;\n  if (!sl || (st && !st.l && sl < 5)) return buf || new u8(0);\n  // have to estimate size\n  const noBuf = !buf || (st as unknown as boolean);\n  // no state\n  const noSt = !st || st.i;\n  if (!st) st = {};\n  // Assumes roughly 33% compression ratio average\n  if (!buf) buf = new u8(sl * 3);\n  // ensure buffer can fit at least l elements\n  const cbuf = (l: number) => {\n    let bl = buf.length;\n    // need to increase size to fit\n    if (l > bl) {\n      // Double or set to necessary, whichever is greater\n      const nbuf = new u8(Math.max(bl * 2, l));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  //  last chunk         bitpos           bytes\n  let final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n  // total bits\n  const tbts = sl * 8;\n  do {\n    if (!lm) {\n      // BFINAL - this is only 1 when last chunk is next\n      st.f = final = bits(dat, pos, 1);\n      // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n      const type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if (!type) {\n        // go to end of byte boundary\n        const s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n        if (t > sl) {\n          if (noSt) err(0);\n          break;\n        }\n        // ensure size\n        if (noBuf) cbuf(bt + l);\n        // Copy over uncompressed data\n        buf.set(dat.subarray(s, t), bt);\n        // Get new bitpos, update byte count\n        st.b = bt += l, st.p = pos = t * 8;\n        continue;\n      }\n      else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        //  literal                            lengths\n        const hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n        const tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        // length+distance tree\n        const ldt = new u8(tl);\n        // code length tree\n        const clt = new u8(19);\n        for (let i = 0; i < hcLen; ++i) {\n          // use index map to get real code\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n        pos += hcLen * 3;\n        // code lengths bits\n        const clb = max(clt), clbmsk = (1 << clb) - 1;\n        // code lengths map\n        const clm = hMap(clt, clb, 1);\n        for (let i = 0; i < tl;) {\n          const r = clm[bits(dat, pos, clbmsk)];\n          // bits read\n          pos += r & 15;\n          // symbol\n          const s = r >>> 4;\n          // code length to copy\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            //  copy   count\n            let c = 0, n = 0;\n            if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n            else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;\n            else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n            while (n--) ldt[i++] = c;\n          }\n        }\n        //    length tree                 distance tree\n        const lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n        // max length bits\n        lbt = max(lt)\n        // max dist bits\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else err(1);\n      if (pos > tbts) {\n        if (noSt) err(0);\n        break;\n      }\n    }\n    // Make sure the buffer can hold this + the largest possible addition\n    // Maximum chunk size (practically, theoretically infinite) is 2^17;\n    if (noBuf) cbuf(bt + 131072);\n    const lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    let lpos = pos;\n    for (;; lpos = pos) {\n      // bits read, code\n      const c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n      pos += c & 15;\n      if (pos > tbts) {\n        if (noSt) err(0);\n        break;\n      }\n      if (!c) err(2);\n      if (sym < 256) buf[bt++] = sym;\n      else if (sym == 256) {\n        lpos = pos, lm = null;\n        break;\n      } else {\n        let add = sym - 254;\n        // no extra bits needed if less\n        if (sym > 264) {\n          // index\n          const i = sym - 257, b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        }\n        // dist\n        const d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n        if (!d) err(3);\n        pos += d & 15;\n        let dt = fd[dsym];\n        if (dsym > 3) {\n          const b = fdeb[dsym];\n          dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n        }\n        if (pos > tbts) {\n          if (noSt) err(0);\n          break;\n        }\n        if (noBuf) cbuf(bt + 131072);\n        const end = bt + add;\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - dt];\n          buf[bt + 1] = buf[bt + 1 - dt];\n          buf[bt + 2] = buf[bt + 2 - dt];\n          buf[bt + 3] = buf[bt + 3 - dt];\n        }\n        bt = end;\n      }\n    }\n    st.l = lm, st.p = lpos, st.b = bt;\n    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final)\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n}\n\n// starting at p, write the minimum number of bits that can hold v to d\nconst wbits = (d: Uint8Array, p: number, v: number) => {\n  v <<= p & 7;\n  const o = (p / 8) | 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n}\n\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nconst wbits16 = (d: Uint8Array, p: number, v: number) => {\n  v <<= p & 7;\n  const o = (p / 8) | 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n  d[o + 2] |= v >>> 16;\n}\n\ntype HuffNode = {\n  // symbol\n  s: number;\n  // frequency\n  f: number;\n  // left child\n  l?: HuffNode;\n  // right child\n  r?: HuffNode;\n};\n\n// creates code lengths from a frequency table\nconst hTree = (d: Uint16Array, mb: number) => {\n  // Need extra info to make a tree\n  const t: HuffNode[] = [];\n  for (let i = 0; i < d.length; ++i) {\n    if (d[i]) t.push({ s: i, f: d[i] });\n  }\n  const s = t.length;\n  const t2 = t.slice();\n  if (!s) return [et, 0] as const;\n  if (s == 1) {\n    const v = new u8(t[0].s + 1);\n    v[t[0].s] = 1;\n    return [v, 1] as const;\n  }\n  t.sort((a, b) => a.f - b.f);\n  // after i2 reaches last ind, will be stopped\n  // freq must be greater than largest possible number of symbols\n  t.push({ s: -1, f: 25001 });\n  let l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n  t[0] = { s: -1, f: l.f + r.f, l, r };\n  // efficient algorithm from UZIP.js\n  // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n  // symbols that combined have high freq, will start processing i2 (high-freq,\n  // non-composite) symbols instead\n  // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n  while (i1 != s - 1) {\n    l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n    t[i1++] = { s: -1, f: l.f + r.f, l, r };\n  }\n  let maxSym = t2[0].s;\n  for (let i = 1; i < s; ++i) {\n    if (t2[i].s > maxSym) maxSym = t2[i].s;\n  }\n  // code lengths\n  const tr = new u16(maxSym + 1);\n  // max bits in tree\n  let mbt = ln(t[i1 - 1], tr, 0);\n  if (mbt > mb) {\n    // more algorithms from UZIP.js\n    // TODO: find out how this code works (debt)\n    //  ind    debt\n    let i = 0, dt = 0;\n    //    left            cost\n    const lft = mbt - mb, cst = 1 << lft;\n    t2.sort((a, b) => tr[b.s] - tr[a.s] || a.f - b.f);\n    for (; i < s; ++i) {\n      const i2 = t2[i].s;\n      if (tr[i2] > mb) {\n        dt += cst - (1 << (mbt - tr[i2]));\n        tr[i2] = mb;\n      } else break;\n    }\n    dt >>>= lft;\n    while (dt > 0) {\n      const i2 = t2[i].s;\n      if (tr[i2] < mb) dt -= 1 << (mb - tr[i2]++ - 1);\n      else ++i;\n    }\n    for (; i >= 0 && dt; --i) {\n      const i2 = t2[i].s;\n      if (tr[i2] == mb) {\n        --tr[i2];\n        ++dt;\n      }\n    }\n    mbt = mb;\n  }\n  return [new u8(tr), mbt] as const;\n}\n// get the max length and assign length codes\nconst ln = (n: HuffNode, l: Uint16Array, d: number): number => {\n  return n.s == -1\n    ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n    : (l[n.s] = d);\n}\n\n// length codes generation\nconst lc = (c: Uint8Array) => {\n  let s = c.length;\n  // Note that the semicolon was intentional\n  while (s && !c[--s]);\n  const cl = new u16(++s);\n  //  ind      num         streak\n  let cli = 0, cln = c[0], cls = 1;\n  const w = (v: number) => { cl[cli++] = v; }\n  for (let i = 1; i <= s; ++i) {\n    if (c[i] == cln && i != s)\n      ++cls;\n    else {\n      if (!cln && cls > 2) {\n        for (; cls > 138; cls -= 138) w(32754);\n        if (cls > 2) {\n          w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n          cls = 0;\n        }\n      } else if (cls > 3) {\n        w(cln), --cls;\n        for (; cls > 6; cls -= 6) w(8304);\n        if (cls > 2) w(((cls - 3) << 5) | 8208), cls = 0;\n      }\n      while (cls--) w(cln);\n      cls = 1;\n      cln = c[i];\n    }\n  }\n  return [cl.subarray(0, cli), s] as const;\n}\n\n// calculate the length of output from tree, code lengths\nconst clen = (cf: Uint16Array, cl: Uint8Array) => {\n  let l = 0;\n  for (let i = 0; i < cl.length; ++i) l += cf[i] * cl[i];\n  return l;\n}\n\n// writes a fixed block\n// returns the new bit pos\nconst wfblk = (out: Uint8Array, pos: number, dat: Uint8Array) => {\n  // no need to write 00 as type: TypedArray defaults to 0\n  const s = dat.length;\n  const o = shft(pos + 2);\n  out[o] = s & 255;\n  out[o + 1] = s >>> 8;\n  out[o + 2] = out[o] ^ 255;\n  out[o + 3] = out[o + 1] ^ 255;\n  for (let i = 0; i < s; ++i) out[o + i + 4] = dat[i];\n  return (o + 4 + s) * 8;\n}\n\n// writes a block\nconst wblk = (dat: Uint8Array, out: Uint8Array, final: number, syms: Uint32Array, lf: Uint16Array, df: Uint16Array, eb: number, li: number, bs: number, bl: number, p: number) => {\n  wbits(out, p++, final);\n  ++lf[256];\n  const [dlt, mlb] = hTree(lf, 15);\n  const [ddt, mdb] = hTree(df, 15);\n  const [lclt, nlc] = lc(dlt);\n  const [lcdt, ndc] = lc(ddt);\n  const lcfreq = new u16(19);\n  for (let i = 0; i < lclt.length; ++i) lcfreq[lclt[i] & 31]++;\n  for (let i = 0; i < lcdt.length; ++i) lcfreq[lcdt[i] & 31]++;\n  const [lct, mlcb] = hTree(lcfreq, 7);\n  let nlcc = 19;\n  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n  const flen = (bl + 5) << 3;\n  const ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n  const dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n  if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n  let lm: Uint16Array, ll: Uint8Array, dm: Uint16Array, dl: Uint8Array;\n  wbits(out, p, 1 + (dtlen < ftlen as unknown as number)), p += 2;\n  if (dtlen < ftlen) {\n    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n    const llm = hMap(lct, mlcb, 0);\n    wbits(out, p, nlc - 257);\n    wbits(out, p + 5, ndc - 1);\n    wbits(out, p + 10, nlcc - 4);\n    p += 14;\n    for (let i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);\n    p += 3 * nlcc;\n    const lcts = [lclt, lcdt];\n    for (let it = 0; it < 2; ++it) {\n      const clct = lcts[it];\n      for (let i = 0; i < clct.length; ++i) {\n        const len = clct[i] & 31;\n        wbits(out, p, llm[len]), p += lct[len];\n        if (len > 15) wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n      }\n    }\n  } else {\n    lm = flm, ll = flt, dm = fdm, dl = fdt;\n  }\n  for (let i = 0; i < li; ++i) {\n    if (syms[i] > 255) {\n      const len = (syms[i] >>> 18) & 31;\n      wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n      if (len > 7) wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n      const dst = syms[i] & 31;\n      wbits16(out, p, dm[dst]), p += dl[dst];\n      if (dst > 3) wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n    } else {\n      wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n    }\n  }\n  wbits16(out, p, lm[256]);\n  return p + ll[256];\n}\n\n// deflate options (nice << 13) | chain\nconst deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n\n// empty\nconst et = /*#__PURE__*/new u8(0);\n\n// compresses data into a raw DEFLATE buffer\nconst dflt = (dat: Uint8Array, lvl: number, plvl: number, pre: number, post: number, lst: 0 | 1) => {\n  const s = dat.length;\n  const o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n  // writing to this writes to the output buffer\n  const w = o.subarray(pre, o.length - post);\n  let pos = 0;\n  if (!lvl || s < 8) {\n    for (let i = 0; i <= s; i += 65535) {\n      // end\n      const e = i + 65535;\n      if (e < s) {\n        // write full block\n        pos = wfblk(w, pos, dat.subarray(i, e));\n      } else {\n        // write final block\n        w[i] = lst;\n        pos = wfblk(w, pos, dat.subarray(i, s));\n      }\n    }\n  } else {\n    const opt = deo[lvl - 1];\n    const n = opt >>> 13, c = opt & 8191;\n    const msk = (1 << plvl) - 1;\n    //    prev 2-byte val map    curr 2-byte val map\n    const prev = new u16(32768), head = new u16(msk + 1);\n    const bs1 = Math.ceil(plvl / 3), bs2 = 2 * bs1;\n    const hsh = (i: number) => (dat[i] ^ (dat[i + 1] << bs1) ^ (dat[i + 2] << bs2)) & msk;\n    // 24576 is an arbitrary number of maximum symbols per block\n    // 424 buffer for last block\n    const syms = new u32(25000);\n    // length/literal freq   distance freq\n    const lf = new u16(288), df = new u16(32);\n    //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n    let lc = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n    for (; i < s; ++i) {\n      // hash value\n      // deopt when i > s - 3 - at end, deopt acceptable\n      const hv = hsh(i);\n      // index mod 32768    previous index mod\n      let imod = i & 32767, pimod = head[hv];\n      prev[imod] = pimod;\n      head[hv] = imod;\n      // We always should modify head and prev, but only add symbols if\n      // this data is not yet processed (\"wait\" for wait index)\n      if (wi <= i) {\n        // bytes remaining\n        const rem = s - i;\n        if ((lc > 7000 || li > 24576) && rem > 423) {\n          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n          li = lc = eb = 0, bs = i;\n          for (let j = 0; j < 286; ++j) lf[j] = 0;\n          for (let j = 0; j < 30; ++j) df[j] = 0;\n        }\n        //  len    dist   chain\n        let l = 2, d = 0, ch = c, dif = (imod - pimod) & 32767;\n        if (rem > 2 && hv == hsh(i - dif)) {\n          const maxn = Math.min(n, rem) - 1;\n          const maxd = Math.min(32767, i);\n          // max possible length\n          // not capped at dif because decompressors implement \"rolling\" index population\n          const ml = Math.min(258, rem);\n          while (dif <= maxd && --ch && imod != pimod) {\n            if (dat[i + l] == dat[i + l - dif]) {\n              let nl = 0;\n              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n              if (nl > l) {\n                l = nl, d = dif;\n                // break out early when we reach \"nice\" (we are satisfied enough)\n                if (nl > maxn) break;\n                // now, find the rarest 2-byte sequence within this\n                // length of literals and search for that instead.\n                // Much faster than just using the start\n                const mmd = Math.min(dif, nl - 2);\n                let md = 0;\n                for (let j = 0; j < mmd; ++j) {\n                  const ti = (i - dif + j + 32768) & 32767;\n                  const pti = prev[ti];\n                  const cd = (ti - pti + 32768) & 32767;\n                  if (cd > md) md = cd, pimod = ti;\n                }\n              }\n            }\n            // check the previous match\n            imod = pimod, pimod = prev[imod];\n            dif += (imod - pimod + 32768) & 32767;\n          }\n        }\n        // d will be nonzero only when a match was found\n        if (d) {\n          // store both dist and len data in one Uint32\n          // Make sure this is recognized as a len/dist with 28th bit (2^28)\n          syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n          const lin = revfl[l] & 31, din = revfd[d] & 31;\n          eb += fleb[lin] + fdeb[din];\n          ++lf[257 + lin];\n          ++df[din];\n          wi = i + l;\n          ++lc;\n        } else {\n          syms[li++] = dat[i];\n          ++lf[dat[i]];\n        }\n      }\n    }\n    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n    // this is the easiest way to avoid needing to maintain state\n    if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);\n  }\n  return slc(o, 0, pre + shft(pos) + post);\n}\n\n// crc check\ntype CRCV = {\n  p(d: Uint8Array): void;\n  d(): number;\n};\n\n// CRC32 table\nconst crct = /*#__PURE__*/ (() => {\n  const t = new Int32Array(256);\n  for (let i = 0; i < 256; ++i) {\n    let c = i, k = 9;\n    while (--k) c = ((c & 1) && -306674912) ^ (c >>> 1);\n    t[i] = c;\n  }\n  return t;\n})();\n\n// CRC32\nconst crc = (): CRCV => {\n  let c = -1;\n  return {\n    p(d) {\n      // closures have awful performance\n      let cr = c;\n      for (let i = 0; i < d.length; ++i) cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n      c = cr;\n    },\n    d() { return ~c; }\n  }\n}\n\n// Alder32\nconst adler = (): CRCV => {\n  let a = 1, b = 0;\n  return {\n    p(d) {\n      // closures have awful performance\n      let n = a, m = b;\n      const l = d.length | 0;\n      for (let i = 0; i != l;) {\n        const e = Math.min(i + 2655, l);\n        for (; i < e; ++i) m += n += d[i];\n        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n      }\n      a = n, b = m;\n    },\n    d() {\n      a %= 65521, b %= 65521;\n      return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n    }\n  }\n}\n\n/**\n * Options for compressing data into a DEFLATE format\n */\nexport interface DeflateOptions {\n  /**\n   * The level of compression to use, ranging from 0-9.\n   * \n   * 0 will store the data without compression.\n   * 1 is fastest but compresses the worst, 9 is slowest but compresses the best.\n   * The default level is 6.\n   * \n   * Typically, binary data benefits much more from higher values than text data.\n   * In both cases, higher values usually take disproportionately longer than the reduction in final size that results.\n   * \n   * For example, a 1 MB text file could:\n   * - become 1.01 MB with level 0 in 1ms\n   * - become 400 kB with level 1 in 10ms\n   * - become 320 kB with level 9 in 100ms\n   */\n  level?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n  /**\n   * The memory level to use, ranging from 0-12. Increasing this increases speed and compression ratio at the cost of memory.\n   * \n   * Note that this is exponential: while level 0 uses 4 kB, level 4 uses 64 kB, level 8 uses 1 MB, and level 12 uses 16 MB.\n   * It is recommended not to lower the value below 4, since that tends to hurt performance.\n   * In addition, values above 8 tend to help very little on most data and can even hurt performance.\n   * \n   * The default value is automatically determined based on the size of the input data.\n   */\n  mem?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n};\n\n/**\n * Options for compressing data into a GZIP format\n */\nexport interface GzipOptions extends DeflateOptions {\n  /**\n   * When the file was last modified. Defaults to the current time.\n   * Set this to 0 to avoid revealing a modification date entirely.\n   */\n  mtime?: Date | string | number;\n  /**\n   * The filename of the data. If the `gunzip` command is used to decompress the data, it will output a file\n   * with this name instead of the name of the compressed file.\n   */\n  filename?: string;\n}\n\n/**\n * Options for compressing data into a Zlib format\n */\nexport interface ZlibOptions extends DeflateOptions {}\n\n/**\n * Handler for data (de)compression streams\n * @param data The data output from the stream processor\n * @param final Whether this is the final block\n */\nexport type FlateStreamHandler = (data: Uint8Array, final: boolean) => void;\n\n/**\n * Handler for asynchronous data (de)compression streams\n * @param err Any error that occurred\n * @param data The data output from the stream processor\n * @param final Whether this is the final block\n */\nexport type AsyncFlateStreamHandler = (err: FlateError, data: Uint8Array, final: boolean) => void;\n\n/**\n * Callback for asynchronous (de)compression methods\n * @param err Any error that occurred\n * @param data The resulting data. Only present if `err` is null\n */\nexport type FlateCallback = (err: FlateError, data: Uint8Array) => void;\n\n// async callback-based compression\ninterface AsyncOptions {\n  /**\n   * Whether or not to \"consume\" the source data. This will make the typed array/buffer you pass in\n   * unusable but will increase performance and reduce memory usage.\n   */\n  consume?: boolean;\n}\n\n/**\n * Options for compressing data asynchronously into a DEFLATE format\n */\nexport interface AsyncDeflateOptions extends DeflateOptions, AsyncOptions {}\n\n/**\n * Options for decompressing DEFLATE data asynchronously\n */\nexport interface AsyncInflateOptions extends AsyncOptions {\n  /**\n   * The original size of the data. Currently, the asynchronous API disallows\n   * writing into a buffer you provide; the best you can do is provide the\n   * size in bytes and be given back a new typed array.\n   */\n  size?: number;\n}\n\n/**\n * Options for compressing data asynchronously into a GZIP format\n */\nexport interface AsyncGzipOptions extends GzipOptions, AsyncOptions {}\n\n/**\n * Options for decompressing GZIP data asynchronously\n */\nexport interface AsyncGunzipOptions extends AsyncOptions {}\n\n/**\n * Options for compressing data asynchronously into a Zlib format\n */\nexport interface AsyncZlibOptions extends ZlibOptions, AsyncOptions {}\n\n/**\n * Options for decompressing Zlib data asynchronously\n */\nexport interface AsyncUnzlibOptions extends AsyncInflateOptions {}\n\n/**\n * A terminable compression/decompression process\n */\nexport interface AsyncTerminable {\n  /**\n   * Terminates the worker thread immediately. The callback will not be called.\n   */\n  (): void;\n}\n\n// deflate with opts\nconst dopt = (dat: Uint8Array, opt: DeflateOptions, pre: number, post: number, st?: boolean) =>\n  dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st as unknown as 0 | 1);\n\n// Walmart object spread\nconst mrg = <A, B>(a: A, b: B) => {\n  const o = {} as Record<string, unknown>;\n  for (const k in a) o[k] = a[k];\n  for (const k in b) o[k] = b[k];\n  return o as A & B;\n}\n\n// worker clone\n\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n\n// This took me three weeks to figure out how to do.\nconst wcln = (fn: () => unknown[], fnStr: string, td: Record<string, unknown>) => {\n  const dt = fn();\n  const st = fn.toString();\n  const ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n  for (let i = 0; i < dt.length; ++i) {\n    let v = dt[i], k = ks[i];\n    if (typeof v == 'function') {\n      fnStr += ';' + k + '=';\n      const st = v.toString();\n      if (v.prototype) {\n        // for global objects\n        if (st.indexOf('[native code]') != -1) {\n          const spInd = st.indexOf(' ', 8) + 1;\n          fnStr += st.slice(spInd, st.indexOf('(', spInd));\n        } else {\n          fnStr += st;\n          for (const t in v.prototype) fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n        }\n      } else fnStr += st;\n    } else td[k] = v;\n  }\n  return [fnStr, td] as const;\n}\n\ntype CachedWorker = readonly [string, Record<string, unknown>];\n\nconst ch: CachedWorker[] = [];\n// clone bufs\nconst cbfs = (v: Record<string, unknown>) => {\n  const tl: ArrayBuffer[] = [];\n  for (const k in v) {\n    if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new (v[k].constructor as typeof u8)(v[k] as Uint8Array)).buffer);\n  }\n  return tl;\n}\n\n// use a worker to execute code\nconst wrkr = <T, R>(fns: (() => unknown[])[], init: (ev: MessageEvent<T>) => void, id: number, cb: (err: FlateError, msg: R) => void) => {\n  if (!ch[id]) {\n    let fnStr = '', td: Record<string, unknown> = {}, m = fns.length - 1;\n    for (let i = 0; i < m; ++i)\n      [fnStr, td] = wcln(fns[i], fnStr, td);\n    ch[id] = wcln(fns[m], fnStr, td);\n  }\n  const td = mrg({}, ch[id][1]);\n  return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n}\n\n// base async inflate fn\nconst bInflt = () => [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8];\nconst bDflt = () => [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]\n\n// gzip extra\nconst gze = () => [gzh, gzhl, wbytes, crc, crct];\n// gunzip extra\nconst guze = () => [gzs, gzl];\n// zlib extra\nconst zle = () => [zlh, wbytes, adler];\n// unzlib extra\nconst zule = () => [zlv];\n\n// post buf\nconst pbf = (msg: Uint8Array) => (postMessage as Worker['postMessage'])(msg, [msg.buffer]);\n\n// get u8\nconst gu8 = (o?: AsyncInflateOptions) => o && o.size && new u8(o.size);\n\n// async helper\nconst cbify = <T extends AsyncOptions>(dat: Uint8Array, opts: T, fns: (() => unknown[])[], init: (ev: MessageEvent<[Uint8Array, T]>) => void, id: number, cb: FlateCallback) => {\n  const w = wrkr<[Uint8Array, T], Uint8Array>(\n    fns,\n    init,\n    id,\n    (err, dat) => {\n      w.terminate();\n      cb(err, dat);\n    }\n  );\n  w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n  return () => { w.terminate(); };\n}\n\ntype CmpDecmpStrm = Inflate | Deflate | Gzip | Gunzip | Zlib | Unzlib;\n\n// auto stream\nconst astrm = (strm: CmpDecmpStrm) => {\n  strm.ondata = (dat, final) => (postMessage as Worker['postMessage'])([dat, final], [dat.buffer]);\n  return (ev: MessageEvent<[Uint8Array, boolean]>) => strm.push(ev.data[0], ev.data[1]);\n}\n\ntype Astrm = { ondata: AsyncFlateStreamHandler; push: (d: Uint8Array, f?: boolean) => void; terminate: AsyncTerminable; };\n\n// async stream attach\nconst astrmify = <T>(fns: (() => unknown[])[], strm: Astrm, opts: T | 0, init: (ev: MessageEvent<T>) => void, id: number) => {\n  let t: boolean;\n  const w = wrkr<T, [Uint8Array, boolean]>(\n    fns,\n    init,\n    id,\n    (err, dat) => {\n      if (err) w.terminate(), strm.ondata.call(strm, err);\n      else {\n        if (dat[1]) w.terminate();\n        strm.ondata.call(strm, err, dat[0], dat[1]);\n      }\n    }\n  )\n  w.postMessage(opts);\n  strm.push = (d, f) => {\n    if (!strm.ondata) err(5);\n    if (t) strm.ondata(err(4, 0, 1), null, !!f);\n    w.postMessage([d, t = f], [d.buffer]);\n  };\n  strm.terminate = () => { w.terminate(); };\n}\n\n// read 2 bytes\nconst b2 = (d: Uint8Array, b: number) => d[b] | (d[b + 1] << 8);\n\n// read 4 bytes\nconst b4 = (d: Uint8Array, b: number) => (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0;\n\nconst b8 = (d: Uint8Array, b: number) => b4(d, b) + (b4(d, b + 4) * 4294967296);\n\n// write bytes\nconst wbytes = (d: Uint8Array, b: number, v: number) => {\n  for (; v; ++b) d[b] = v, v >>>= 8;\n}\n\n// gzip header\nconst gzh = (c: Uint8Array, o: GzipOptions) => {\n  const fn = o.filename;\n  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n  if (o.mtime != 0) wbytes(c, 4, Math.floor((new Date(o.mtime as (string | number) || Date.now()) as unknown as number) / 1000));\n  if (fn) {\n    c[3] = 8;\n    for (let i = 0; i <= fn.length; ++i) c[i + 10] = fn.charCodeAt(i);\n  }\n}\n\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n\n// gzip start\nconst gzs = (d: Uint8Array) => {\n  if (d[0] != 31 || d[1] != 139 || d[2] != 8) err(6, 'invalid gzip data');\n  const flg = d[3];\n  let st = 10;\n  if (flg & 4) st += d[10] | (d[11] << 8) + 2;\n  for (let zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++] as unknown as number);\n  return st + (flg & 2);\n}\n\n// gzip length\nconst gzl = (d: Uint8Array) => {\n  const l = d.length;\n  return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n}\n\n// gzip header length\nconst gzhl = (o: GzipOptions) => 10 + ((o.filename && (o.filename.length + 1)) || 0);\n\n// zlib header\nconst zlh = (c: Uint8Array, o: ZlibOptions) => {\n  const lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n  c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n}\n\n// zlib valid\nconst zlv = (d: Uint8Array) => {\n  if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31)) err(6, 'invalid zlib data');\n  if (d[1] & 32) err(6, 'invalid zlib data: preset dictionaries not supported');\n}\n\n/**\n * Creates an asynchronous compression stream\n * @param opts The compression options\n * @param cb The callback to call whenever data is deflated\n */\nfunction AsyncCmpStrm<T>(opts: T, cb?: AsyncFlateStreamHandler): T;\n/**\n * Creates an asynchronous compression stream\n * @param cb The callback to call whenever data is deflated\n */\nfunction AsyncCmpStrm<T>(cb?: AsyncFlateStreamHandler): T;\nfunction AsyncCmpStrm<T>(opts?: T | AsyncFlateStreamHandler, cb?: AsyncFlateStreamHandler): T {\n  if (!cb && typeof opts == 'function') cb = opts as AsyncFlateStreamHandler, opts = {} as T;\n  this.ondata = cb as AsyncFlateStreamHandler;\n  return opts as T;\n}\n\n// zlib footer: -4 to -0 is Adler32\n\n/**\n * Streaming DEFLATE compression\n */\nexport class Deflate {\n  /**\n   * Creates a DEFLATE stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: DeflateOptions, cb?: FlateStreamHandler);\n  constructor(cb?: FlateStreamHandler);\n  constructor(opts?: DeflateOptions | FlateStreamHandler, cb?: FlateStreamHandler) {\n    if (!cb && typeof opts == 'function') cb = opts as FlateStreamHandler, opts = {};\n    this.ondata = cb;\n    this.o = (opts as DeflateOptions) || {};\n  }\n  private o: DeflateOptions;\n  private d: boolean;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  private p(c: Uint8Array, f: boolean) {\n    this.ondata(dopt(c, this.o, 0, 0, !f), f);\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.ondata) err(5);\n    if (this.d) err(4);\n    this.d = final;\n    this.p(chunk, final || false);\n  }\n}\n\n/**\n * Asynchronous streaming DEFLATE compression\n */\nexport class AsyncDeflate {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous DEFLATE stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: DeflateOptions, cb?: AsyncFlateStreamHandler);\n  /**\n   * Creates an asynchronous DEFLATE stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler);\n  constructor(opts?: DeflateOptions | AsyncFlateStreamHandler, cb?: AsyncFlateStreamHandler) {\n    astrmify([\n      bDflt,\n      () => [astrm, Deflate]\n    ], this as unknown as Astrm, AsyncCmpStrm.call(this, opts, cb), ev => {\n      const strm = new Deflate(ev.data);\n      onmessage = astrm(strm);\n    }, 6);\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n  \n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @param cb The function to be called upon compression completion\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function deflate(data: Uint8Array, opts: AsyncDeflateOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param cb The function to be called upon compression completion\n */\nexport function deflate(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function deflate(data: Uint8Array, opts: AsyncDeflateOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncDeflateOptions, [\n    bDflt,\n  ], ev => pbf(deflateSync(ev.data[0], ev.data[1])), 0, cb);\n}\n\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data: Uint8Array, opts?: DeflateOptions) {\n  return dopt(data, opts || {}, 0, 0);\n}\n\n/**\n * Streaming DEFLATE decompression\n */\nexport class Inflate {\n  /**\n   * Creates an inflation stream\n   * @param cb The callback to call whenever data is inflated\n   */\n  constructor(cb?: FlateStreamHandler) { this.ondata = cb; }\n  private s: InflateState = {};\n  private o: Uint8Array;\n  private p = new u8(0);\n  private d: boolean;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  private e(c: Uint8Array) {\n    if (!this.ondata) err(5);\n    if (this.d) err(4);\n    const l = this.p.length;\n    const n = new u8(l + c.length);\n    n.set(this.p), n.set(c, l), this.p = n;\n  }\n\n  private c(final: boolean) {\n    this.d = this.s.i = final || false;\n    const bts = this.s.b;\n    const dt = inflt(this.p, this.o, this.s);\n    this.ondata(slc(dt, bts, this.s.b), this.d);\n    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n    this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n  }\n\n  /**\n   * Pushes a chunk to be inflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the final chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    this.e(chunk), this.c(final);\n  }\n}\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nexport class AsyncInflate {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous inflation stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler) {\n    this.ondata = cb;\n    astrmify([\n      bInflt,\n      () => [astrm, Inflate]\n    ], this as unknown as Astrm, 0, () => {\n      const strm = new Inflate();\n      onmessage = astrm(strm);\n    }, 7);\n  }\n\n  /**\n   * Pushes a chunk to be inflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function inflate(data: Uint8Array, opts: AsyncInflateOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function inflate(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function inflate(data: Uint8Array, opts: AsyncInflateOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncInflateOptions, [\n    bInflt\n  ], ev => pbf(inflateSync(ev.data[0], gu8(ev.data[1]))), 1, cb);\n}\n\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data: Uint8Array, out?: Uint8Array) {\n  return inflt(data, out);\n}\n\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n\n/**\n * Streaming GZIP compression\n */\nexport class Gzip {\n  private c = crc();\n  private l = 0;\n  private v = 1;\n  private o: GzipOptions;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  /**\n   * Creates a GZIP stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: GzipOptions, cb?: FlateStreamHandler);\n  /**\n   * Creates a GZIP stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: FlateStreamHandler);\n  constructor(opts?: GzipOptions | FlateStreamHandler, cb?: FlateStreamHandler) {\n    Deflate.call(this, opts, cb);\n  }\n\n  /**\n   * Pushes a chunk to be GZIPped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    Deflate.prototype.push.call(this, chunk, final);\n  }\n  \n  private p(c: Uint8Array, f: boolean) {\n    this.c.p(c);\n    this.l += c.length;\n    const raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n    if (this.v) gzh(raw, this.o), this.v = 0;\n    if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n    this.ondata(raw, f);\n  }\n}\n\n/**\n * Asynchronous streaming GZIP compression\n */\nexport class AsyncGzip {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous GZIP stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: GzipOptions, cb?: AsyncFlateStreamHandler);\n  /**\n   * Creates an asynchronous GZIP stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler);\n  constructor(opts?: GzipOptions | AsyncFlateStreamHandler, cb?: AsyncFlateStreamHandler) {\n    astrmify([\n      bDflt,\n      gze,\n      () => [astrm, Deflate, Gzip]\n    ], this as unknown as Astrm, AsyncCmpStrm.call(this, opts, cb), ev => {\n      const strm = new Gzip(ev.data);\n      onmessage = astrm(strm);\n    }, 8);\n  }\n\n  /**\n   * Pushes a chunk to be GZIPped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @param cb The function to be called upon compression completion\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function gzip(data: Uint8Array, opts: AsyncGzipOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously compresses data with GZIP\n * @param data The data to compress\n * @param cb The function to be called upon compression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function gzip(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function gzip(data: Uint8Array, opts: AsyncGzipOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncGzipOptions, [\n    bDflt,\n    gze,\n    () => [gzipSync]\n  ], ev => pbf(gzipSync(ev.data[0], ev.data[1])), 2, cb);\n}\n\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data: Uint8Array, opts?: GzipOptions) {\n  if (!opts) opts = {};\n  const c = crc(), l = data.length;\n  c.p(data);\n  const d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n  return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n\n/**\n * Streaming GZIP decompression\n */\nexport class Gunzip {\n  private v = 1;\n  private p: Uint8Array;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  /**\n   * Creates a GUNZIP stream\n   * @param cb The callback to call whenever data is inflated\n   */\n  constructor(cb?: FlateStreamHandler) { Inflate.call(this, cb); }\n\n  /**\n   * Pushes a chunk to be GUNZIPped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    (Inflate.prototype as unknown as { e: typeof Inflate.prototype['e'] }).e.call(this, chunk);\n    if (this.v) {\n      const s = this.p.length > 3 ? gzs(this.p) : 4;\n      if (s >= this.p.length && !final) return;\n      this.p = this.p.subarray(s), this.v = 0;\n    }\n    if (final) {\n      if (this.p.length < 8) err(6, 'invalid gzip data');\n      this.p = this.p.subarray(0, -8);\n    }\n    // necessary to prevent TS from using the closure value\n    // This allows for workerization to function correctly\n    (Inflate.prototype as unknown as { c: typeof Inflate.prototype['c'] }).c.call(this, final);\n  }\n}\n\n/**\n * Asynchronous streaming GZIP decompression\n */\nexport class AsyncGunzip {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous GUNZIP stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler) {\n    this.ondata = cb;\n    astrmify([\n      bInflt,\n      guze,\n      () => [astrm, Inflate, Gunzip]\n    ], this as unknown as Astrm, 0, () => {\n      const strm = new Gunzip();\n      onmessage = astrm(strm);\n    }, 9);\n  }\n\n  /**\n   * Pushes a chunk to be GUNZIPped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function gunzip(data: Uint8Array, opts: AsyncGunzipOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously expands GZIP data\n * @param data The data to decompress\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function gunzip(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function gunzip(data: Uint8Array, opts: AsyncGunzipOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncGunzipOptions, [\n    bInflt,\n    guze,\n    () => [gunzipSync]\n  ], ev => pbf(gunzipSync(ev.data[0])), 3, cb);\n}\n\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data: Uint8Array, out?: Uint8Array) {\n  return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n\n/**\n * Streaming Zlib compression\n */\nexport class Zlib {\n  private c = adler();\n  private v = 1;\n  private o: GzipOptions;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n\n  /**\n   * Creates a Zlib stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: ZlibOptions, cb?: FlateStreamHandler);\n  /**\n   * Creates a Zlib stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: FlateStreamHandler);\n  constructor(opts?: ZlibOptions | FlateStreamHandler, cb?: FlateStreamHandler) {\n    Deflate.call(this, opts, cb);\n  }\n\n  /**\n   * Pushes a chunk to be zlibbed\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    Deflate.prototype.push.call(this, chunk, final);\n  }\n  \n  private p(c: Uint8Array, f: boolean) {\n    this.c.p(c);\n    const raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n    if (this.v) zlh(raw, this.o), this.v = 0;\n    if (f) wbytes(raw, raw.length - 4, this.c.d());\n    this.ondata(raw, f);\n  }\n}\n\n/**\n * Asynchronous streaming Zlib compression\n */\nexport class AsyncZlib {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous DEFLATE stream\n   * @param opts The compression options\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(opts: ZlibOptions, cb?: AsyncFlateStreamHandler);\n  /**\n   * Creates an asynchronous DEFLATE stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler);\n  constructor(opts?: ZlibOptions | AsyncFlateStreamHandler, cb?: AsyncFlateStreamHandler) {\n    astrmify([\n      bDflt,\n      zle,\n      () => [astrm, Deflate, Zlib]\n    ], this as unknown as Astrm, AsyncCmpStrm.call(this, opts, cb), ev => {\n      const strm = new Zlib(ev.data);\n      onmessage = astrm(strm);\n    }, 10);\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously compresses data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @param cb The function to be called upon compression completion\n */\nexport function zlib(data: Uint8Array, opts: AsyncZlibOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously compresses data with Zlib\n * @param data The data to compress\n * @param cb The function to be called upon compression completion\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function zlib(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function zlib(data: Uint8Array, opts: AsyncZlibOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncZlibOptions, [\n    bDflt,\n    zle,\n    () => [zlibSync]\n  ], ev => pbf(zlibSync(ev.data[0], ev.data[1])), 4, cb);\n}\n\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data: Uint8Array, opts: ZlibOptions) {\n  if (!opts) opts = {};\n  const a = adler();\n  a.p(data);\n  const d = dopt(data, opts, 2, 4);\n  return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n\n/**\n * Streaming Zlib decompression\n */\nexport class Unzlib {\n  private v = 1;\n  private p: Uint8Array;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n  /**\n   * Creates a Zlib decompression stream\n   * @param cb The callback to call whenever data is inflated\n   */\n  constructor(cb?: FlateStreamHandler) { Inflate.call(this, cb); }\n\n  /**\n   * Pushes a chunk to be unzlibbed\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    (Inflate.prototype as unknown as { e: typeof Inflate.prototype['e'] }).e.call(this, chunk);\n    if (this.v) {\n      if (this.p.length < 2 && !final) return;\n      this.p = this.p.subarray(2), this.v = 0;\n    }\n    if (final) {\n      if (this.p.length < 4) err(6, 'invalid zlib data');\n      this.p = this.p.subarray(0, -4);\n    }\n    // necessary to prevent TS from using the closure value\n    // This allows for workerization to function correctly\n    (Inflate.prototype as unknown as { c: typeof Inflate.prototype['c'] }).c.call(this, final);\n  }\n}\n\n/**\n * Asynchronous streaming Zlib decompression\n */\nexport class AsyncUnzlib {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates an asynchronous Zlib decompression stream\n   * @param cb The callback to call whenever data is deflated\n   */\n  constructor(cb?: AsyncFlateStreamHandler) {\n    this.ondata = cb;\n    astrmify([\n      bInflt,\n      zule,\n      () => [astrm, Inflate, Unzlib]\n    ], this as unknown as Astrm, 0, () => {\n      const strm = new Unzlib();\n      onmessage = astrm(strm);\n    }, 11);\n  }\n\n  /**\n   * Pushes a chunk to be decompressed from Zlib\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  // @ts-ignore\n  push(chunk: Uint8Array, final?: boolean): void;\n\n  /**\n   * A method to terminate the stream's internal worker. Subsequent calls to\n   * push() will silently fail.\n   */\n  terminate: AsyncTerminable;\n}\n\n/**\n * Asynchronously expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function unzlib(data: Uint8Array, opts: AsyncGunzipOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously expands Zlib data\n * @param data The data to decompress\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function unzlib(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function unzlib(data: Uint8Array, opts: AsyncGunzipOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return cbify(data, opts as AsyncUnzlibOptions, [\n    bInflt,\n    zule,\n    () => [unzlibSync]\n  ], ev => pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))), 5, cb);\n}\n\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data: Uint8Array, out?: Uint8Array) {\n  return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress }\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress }\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nexport class Decompress {\n  private G = Gunzip;\n  private I = Inflate;\n  private Z = Unzlib;\n  /**\n   * Creates a decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n  constructor(cb?: FlateStreamHandler) { this.ondata = cb; }\n  private s: Inflate | Gunzip | Unzlib;\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n  private p: Uint8Array;\n\n  /**\n   * Pushes a chunk to be decompressed\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.ondata) err(5);\n    if (!this.s) {\n      if (this.p && this.p.length) {\n        const n = new u8(this.p.length + chunk.length);\n        n.set(this.p), n.set(chunk, this.p.length);\n      } else this.p = chunk;\n      if (this.p.length > 2) {\n        const _this = this;\n        const cb: FlateStreamHandler = function() { _this.ondata.apply(_this, arguments); }\n        this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n          ? new this.G(cb)\n          : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n            ? new this.I(cb)\n            : new this.Z(cb);\n        this.s.push(this.p, final);\n        this.p = null;\n      }\n    } else this.s.push(chunk, final);\n  }\n}\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nexport class AsyncDecompress {\n  private G = AsyncGunzip;\n  private I = AsyncInflate;\n  private Z = AsyncUnzlib;\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n  constructor(cb?: AsyncFlateStreamHandler) { this.ondata = cb; }\n  \n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Pushes a chunk to be decompressed\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    Decompress.prototype.push.call(this, chunk, final);\n  }\n}\n\n/**\n * Asynchrononously expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function decompress(data: Uint8Array, opts: AsyncInflateOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchrononously expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param cb The function to be called upon decompression completion\n * @returns A function that can be used to immediately terminate the decompression\n */\nexport function decompress(data: Uint8Array, cb: FlateCallback): AsyncTerminable;\nexport function decompress(data: Uint8Array, opts: AsyncInflateOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n    ? gunzip(data, opts as AsyncInflateOptions, cb)\n    : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n      ? inflate(data, opts as AsyncInflateOptions, cb)\n      : unzlib(data, opts as AsyncInflateOptions, cb);\n}\n\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data: Uint8Array, out?: Uint8Array) {\n  return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n    ? gunzipSync(data, out)\n    : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n      ? inflateSync(data, out)\n      : unzlibSync(data, out);\n}\n\n/**\n * Attributes for files added to a ZIP archive object\n */\nexport interface ZipAttributes {\n  /**\n   * The operating system of origin for this file. The value is defined\n   * by PKZIP's APPNOTE.txt, section 4.4.2.2. For example, 0 (the default)\n   * is MS/DOS, 3 is UNIX, 19 is macOS.\n   */\n  os?: number;\n\n  /**\n   * The file's attributes. These are traditionally somewhat complicated\n   * and platform-dependent, so using them is scarcely necessary. However,\n   * here is a representation of what this is, bit by bit:\n   * \n   * `TTTTugtrwxrwxrwx0000000000ADVSHR`\n   * \n   * TTTT = file type (rarely useful)\n   * \n   * u = setuid, g = setgid, t = sticky\n   * \n   * rwx = user permissions, rwx = group permissions, rwx = other permissions\n   * \n   * 0000000000 = unused\n   * \n   * A = archive, D = directory, V = volume label, S = system file, H = hidden, R = read-only\n   * \n   * If you want to set the Unix permissions, for instance, just bit shift by 16, e.g. 0644 << 16\n   */\n  attrs?: number;\n\n  /**\n   * Extra metadata to add to the file. This field is defined by PKZIP's APPNOTE.txt,\n   * section 4.4.28. At most 65,535 bytes may be used in each ID. The ID must be an\n   * integer between 0 and 65,535, inclusive.\n   * \n   * This field is incredibly rare and almost never needed except for compliance with\n   * proprietary standards and software.\n   */\n  extra?: Record<number, Uint8Array>;\n\n  /**\n   * The comment to attach to the file. This field is defined by PKZIP's APPNOTE.txt,\n   * section 4.4.26. The comment must be at most 65,535 bytes long UTF-8 encoded. This\n   * field is not read by consumer software.\n   */\n  comment?: string;\n\n  /**\n   * When the file was last modified. Defaults to the current time.\n   */\n  mtime?: GzipOptions['mtime'];\n}\n\n/**\n * Options for creating a ZIP archive\n */\nexport interface ZipOptions extends DeflateOptions, ZipAttributes {}\n\n/**\n * Options for asynchronously creating a ZIP archive\n */\nexport interface AsyncZipOptions extends AsyncDeflateOptions, ZipAttributes {}\n\n/**\n * Options for asynchronously expanding a ZIP archive\n */\nexport interface AsyncUnzipOptions extends AsyncOptions {}\n\n/**\n * A file that can be used to create a ZIP archive\n */\nexport type ZippableFile = Uint8Array | [Uint8Array, ZipOptions];\n\n/**\n * A file that can be used to asynchronously create a ZIP archive\n */\nexport type AsyncZippableFile = Uint8Array | [Uint8Array, AsyncZipOptions];\n\n/**\n * The complete directory structure of a ZIPpable archive\n */\nexport interface Zippable {\n  [path: string]: Zippable | ZippableFile;\n}\n\n/**\n * The complete directory structure of an asynchronously ZIPpable archive\n */\nexport interface AsyncZippable {\n  [path: string]: AsyncZippable | AsyncZippableFile;\n}\n\n/**\n * An unzipped archive. The full path of each file is used as the key,\n * and the file is the value\n */\nexport interface Unzipped {\n  [path: string]: Uint8Array\n}\n\n/**\n * Handler for string generation streams\n * @param data The string output from the stream processor\n * @param final Whether this is the final block\n */\nexport type StringStreamHandler = (data: string, final: boolean) => void;\n\n/**\n * Callback for asynchronous ZIP decompression\n * @param err Any error that occurred\n * @param data The decompressed ZIP archive\n */\nexport type UnzipCallback = (err: FlateError, data: Unzipped) => void;\n\n/**\n * Handler for streaming ZIP decompression\n * @param file The file that was found in the archive\n */\nexport type UnzipFileHandler = (file: UnzipFile) => void;\n\n// flattened Zippable\ntype FlatZippable<A extends boolean> = Record<string, [Uint8Array, (A extends true ? AsyncZipOptions : ZipOptions)]>;\n\n// flatten a directory structure\nconst fltn = <A extends boolean>(d: A extends true ? AsyncZippable : Zippable, p: string, t: FlatZippable<A>, o: ZipOptions) => {\n  for (const k in d) {\n    const val = d[k], n = p + k;\n    if (val instanceof u8) t[n] = [val, o] as unknown as FlatZippable<A>[string];\n    else if (Array.isArray(val)) t[n] = [val[0], mrg(o, val[1])] as FlatZippable<A>[string];\n    else fltn(val as unknown as (A extends true ? AsyncZippable : Zippable), n + '/', t, o);\n  }\n}\n\n// text encoder\nconst te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nconst td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nlet tds = 0;\ntry {\n  td.decode(et, { stream: true });\n  tds = 1;\n} catch(e) {}\n\n// decode UTF8\nconst dutf8 = (d: Uint8Array) => {\n  for (let r = '', i = 0;;) {\n    let c = d[i++];\n    const eb = ((c > 127) as unknown as number) + ((c > 223) as unknown as number) + ((c > 239) as unknown as number);\n    if (i + eb > d.length) return [r, slc(d, i - 1)] as const;\n    if (!eb) r += String.fromCharCode(c)\n    else if (eb == 3) {\n      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n      r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n    } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n    else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n  }\n}\n\n/**\n * Streaming UTF-8 decoding\n */\nexport class DecodeUTF8 {\n  private p: Uint8Array;\n  private t: TextDecoder;\n  /**\n   * Creates a UTF-8 decoding stream\n   * @param cb The callback to call whenever data is decoded\n   */\n  constructor(cb?: StringStreamHandler) {\n    this.ondata = cb;\n    if (tds) this.t = new TextDecoder();\n    else this.p = et;\n  }\n\n  /**\n   * Pushes a chunk to be decoded from UTF-8 binary\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.ondata) err(5);\n    final = !!final;\n    if (this.t) {\n      this.ondata(this.t.decode(chunk, { stream: true }), final);\n      if (final) {\n        if (this.t.decode().length) err(8);\n        this.t = null;\n      }\n      return;\n    }\n    if (!this.p) err(4);\n    const dat = new u8(this.p.length + chunk.length);\n    dat.set(this.p);\n    dat.set(chunk, this.p.length);\n    const [ch, np] = dutf8(dat);\n    if (final) {\n      if (np.length) err(8);\n      this.p = null;\n    } else this.p = np;\n    this.ondata(ch, final);\n  }\n\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: StringStreamHandler;\n}\n\n/**\n * Streaming UTF-8 encoding\n */\nexport class EncodeUTF8 {\n  private d: boolean;\n  /**\n   * Creates a UTF-8 decoding stream\n   * @param cb The callback to call whenever data is encoded\n   */\n  constructor(cb?: FlateStreamHandler) {\n    this.ondata = cb;\n  }\n\n  /**\n   * Pushes a chunk to be encoded to UTF-8\n   * @param chunk The string data to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: string, final?: boolean) {\n    if (!this.ondata) err(5);\n    if (this.d) err(4);\n    this.ondata(strToU8(chunk), this.d = final || false);\n  }\n\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: FlateStreamHandler;\n}\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str: string, latin1?: boolean): Uint8Array {\n  if (latin1) {\n    const ar = new u8(str.length);\n    for (let i = 0; i < str.length; ++i) ar[i] = str.charCodeAt(i);\n    return ar;\n  }\n  if (te) return te.encode(str);\n  const l = str.length;\n  let ar = new u8(str.length + (str.length >> 1));\n  let ai = 0;\n  const w = (v: number) => { ar[ai++] = v; };\n  for (let i = 0; i < l; ++i) {\n    if (ai + 5 > ar.length) {\n      const n = new u8(ai + 8 + ((l - i) << 1));\n      n.set(ar);\n      ar = n;\n    }\n    let c = str.charCodeAt(i);\n    if (c < 128 || latin1) w(c);\n    else if (c < 2048) w(192 | (c >> 6)), w(128 | (c & 63));\n    else if (c > 55295 && c < 57344)\n      c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n      w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    else w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n  }\n  return slc(ar, 0, ai);\n}\n\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat: Uint8Array, latin1?: boolean) {\n  if (latin1) {\n    let r = '';\n    for (let i = 0; i < dat.length; i += 16384)\n      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n    return r;\n  } else if (td) return td.decode(dat)\n  else {\n    const [out, ext] = dutf8(dat);\n    if (ext.length) err(8);\n    return out;\n  } \n};\n\n// deflate bit flag\nconst dbf = (l: number) => l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n\n// skip local zip header\nconst slzh = (d: Uint8Array, b: number) => b + 30 + b2(d, b + 26) + b2(d, b + 28);\n\n// read zip header\nconst zh = (d: Uint8Array, b: number, z: boolean) => {\n  const fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n  const [sc, su, off] = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)];\n  return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off] as const;\n}\n\n// read zip64 extra field\nconst z64e = (d: Uint8Array, b: number) => {\n  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2));\n  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)] as const;\n}\n\n// zip header file\ntype ZHF = Omit<ZipInputFile, 'terminate' | 'ondata' | 'filename'>;\n\n// extra field length\nconst exfl = (ex?: ZHF['extra']) => {\n  let le = 0;\n  if (ex) {\n    for (const k in ex) {\n      const l = ex[k].length;\n      if (l > 65535) err(9);\n      le += l + 4;\n    }\n  }\n  return le;\n}\n\n// write zip header\nconst wzh = (d: Uint8Array, b: number, f: ZHF, fn: Uint8Array, u: boolean, c?: number, ce?: number, co?: Uint8Array) => {\n  const fl = fn.length, ex = f.extra, col = co && co.length;\n  let exl = exfl(ex);\n  wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n  if (ce != null) d[b++] = 20, d[b++] = f.os;\n  d[b] = 20, b += 2; // spec compliance? what's that?\n  d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n  const dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n  if (y < 0 || y > 119) err(10);\n  wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n  if (c != null) {\n    wbytes(d, b, f.crc);\n    wbytes(d, b + 4, c);\n    wbytes(d, b + 8, f.size);\n  }\n  wbytes(d, b + 12, fl);\n  wbytes(d, b + 14, exl), b += 16;\n  if (ce != null) {\n    wbytes(d, b, col);\n    wbytes(d, b + 6, f.attrs);\n    wbytes(d, b + 10, ce), b += 14;\n  }\n  d.set(fn, b);\n  b += fl;\n  if (exl) {\n    for (const k in ex) {\n      const exf = ex[k], l = exf.length;\n      wbytes(d, b, +k);\n      wbytes(d, b + 2, l);\n      d.set(exf, b + 4), b += 4 + l;\n    }\n  }\n  if (col) d.set(co, b), b += col;\n  return b;\n}\n\n// write zip footer (end of central directory)\nconst wzf = (o: Uint8Array, b: number, c: number, d: number, e: number) => {\n  wbytes(o, b, 0x6054B50); // skip disk\n  wbytes(o, b + 8, c);\n  wbytes(o, b + 10, c);\n  wbytes(o, b + 12, d);\n  wbytes(o, b + 16, e);\n}\n\n/**\n * A stream that can be used to create a file in a ZIP archive\n */\nexport interface ZipInputFile extends ZipAttributes {\n  /**\n   * The filename to associate with the data provided to this stream. If you\n   * want a file in a subdirectory, use forward slashes as a separator (e.g.\n   * `directory/filename.ext`). This will still work on Windows.\n   */\n  filename: string;\n\n  /**\n   * The size of the file in bytes. This attribute may be invalid after\n   * the file is added to the ZIP archive; it must be correct only before the\n   * stream completes.\n   * \n   * If you don't want to have to compute this yourself, consider extending the\n   * ZipPassThrough class and overriding its process() method, or using one of\n   * ZipDeflate or AsyncZipDeflate.\n   */\n  size: number;\n\n  /**\n   * A CRC of the original file contents. This attribute may be invalid after\n   * the file is added to the ZIP archive; it must be correct only before the\n   * stream completes.\n   * \n   * If you don't want to have to generate this yourself, consider extending the\n   * ZipPassThrough class and overriding its process() method, or using one of\n   * ZipDeflate or AsyncZipDeflate.\n   */\n  crc: number;\n\n  /**\n   * The compression format for the data stream. This number is determined by\n   * the spec in PKZIP's APPNOTE.txt, section 4.4.5. For example, 0 = no\n   * compression, 8 = deflate, 14 = LZMA\n   */\n  compression: number;\n\n  /**\n   * Bits 1 and 2 of the general purpose bit flag, specified in PKZIP's\n   * APPNOTE.txt, section 4.4.4. Should be between 0 and 3. This is unlikely\n   * to be necessary.\n   */\n  flag?: number;\n\n  /**\n   * The handler to be called when data is added. After passing this stream to\n   * the ZIP file object, this handler will always be defined. To call it:\n   * \n   * `stream.ondata(error, chunk, final)`\n   * \n   * error = any error that occurred (null if there was no error)\n   * \n   * chunk = a Uint8Array of the data that was added (null if there was an\n   * error)\n   * \n   * final = boolean, whether this is the final chunk in the stream\n   */\n  ondata?: AsyncFlateStreamHandler;\n  \n  /**\n   * A method called when the stream is no longer needed, for clean-up\n   * purposes. This will not always be called after the stream completes,\n   * so you may wish to call this.terminate() after the final chunk is\n   * processed if you have clean-up logic.\n   */\n  terminate?: AsyncTerminable;\n}\n\ntype AsyncZipDat = ZHF & {\n  // compressed data\n  c: Uint8Array;\n  // filename\n  f: Uint8Array;\n  // comment\n  m?: Uint8Array;\n  // unicode\n  u: boolean;\n};\n\ntype ZipDat = AsyncZipDat & {\n  // offset\n  o: number;\n}\n\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nexport class ZipPassThrough implements ZipInputFile {\n  filename: string;\n  crc: number;\n  size: number;\n  compression: number;\n  os?: number;\n  attrs?: number;\n  comment?: string;\n  extra?: Record<number, Uint8Array>;\n  mtime?: GzipOptions['mtime'];\n  ondata: AsyncFlateStreamHandler;\n  private c: CRCV;\n\n  /**\n   * Creates a pass-through stream that can be added to ZIP archives\n   * @param filename The filename to associate with this data stream\n   */\n  constructor(filename: string) {\n    this.filename = filename;\n    this.c = crc();\n    this.size = 0;\n    this.compression = 0;\n  }\n\n  /**\n   * Processes a chunk and pushes to the output stream. You can override this\n   * method in a subclass for custom behavior, but by default this passes\n   * the data through. You must call this.ondata(err, chunk, final) at some\n   * point in this method.\n   * @param chunk The chunk to process\n   * @param final Whether this is the last chunk\n   */\n  protected process(chunk: Uint8Array, final: boolean) {\n    this.ondata(null, chunk, final);\n  }\n\n  /**\n   * Pushes a chunk to be added. If you are subclassing this with a custom\n   * compression algorithm, note that you must push data from the source\n   * file only, pre-compression.\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.ondata) err(5);\n    this.c.p(chunk);\n    this.size += chunk.length;\n    if (final) this.crc = this.c.d();\n    this.process(chunk, final || false);\n  }\n}\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nexport class ZipDeflate implements ZipInputFile {\n  filename: string;\n  crc: number;\n  size: number;\n  compression: number;\n  flag: 0 | 1 | 2 | 3;\n  os?: number;\n  attrs?: number;\n  comment?: string;\n  extra?: Record<number, Uint8Array>;\n  mtime?: GzipOptions['mtime'];\n  ondata: AsyncFlateStreamHandler;\n  private d: Deflate;\n\n  /**\n   * Creates a DEFLATE stream that can be added to ZIP archives\n   * @param filename The filename to associate with this data stream\n   * @param opts The compression options\n   */\n  constructor(filename: string, opts?: DeflateOptions) {\n    if (!opts) opts = {};\n    ZipPassThrough.call(this, filename);\n    this.d = new Deflate(opts, (dat, final) => {\n      this.ondata(null, dat, final);\n    });\n    this.compression = 8;\n    this.flag = dbf(opts.level);\n  }\n  \n  process(chunk: Uint8Array, final: boolean) {\n    try {\n      this.d.push(chunk, final);\n    } catch(e) {\n      this.ondata(e, null, final);\n    }\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    ZipPassThrough.prototype.push.call(this, chunk, final);\n  }\n}\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nexport class AsyncZipDeflate implements ZipInputFile {\n  filename: string;\n  crc: number;\n  size: number;\n  compression: number;\n  flag: 0 | 1 | 2 | 3;\n  os?: number;\n  attrs?: number;\n  comment?: string;\n  extra?: Record<number, Uint8Array>;\n  mtime?: GzipOptions['mtime'];\n  ondata: AsyncFlateStreamHandler;\n  private d: AsyncDeflate;\n  terminate: AsyncTerminable;\n\n  /**\n   * Creates a DEFLATE stream that can be added to ZIP archives\n   * @param filename The filename to associate with this data stream\n   * @param opts The compression options\n   */\n  constructor(filename: string, opts?: DeflateOptions) {\n    if (!opts) opts = {};\n    ZipPassThrough.call(this, filename);\n    this.d = new AsyncDeflate(opts, (err, dat, final) => {\n      this.ondata(err, dat, final);\n    });\n    this.compression = 8;\n    this.flag = dbf(opts.level);\n    this.terminate = this.d.terminate;\n  }\n  \n  process(chunk: Uint8Array, final: boolean) {\n    this.d.push(chunk, final);\n  }\n\n  /**\n   * Pushes a chunk to be deflated\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    ZipPassThrough.prototype.push.call(this, chunk, final);\n  }\n}\n\ntype ZIFE = {\n  // compressed size\n  c: number;\n  // filename\n  f: Uint8Array;\n  // comment\n  o?: Uint8Array;\n  // unicode\n  u: boolean;\n  // byte offset\n  b: number;\n  // header offset\n  h: number;\n  // terminator\n  t: () => void;\n  // turn\n  r: () => void;\n};\n\ntype ZipInternalFile = ZHF & ZIFE;\n\n// TODO: Better tree shaking\n\n/**\n * A zippable archive to which files can incrementally be added\n */\nexport class Zip {\n  private u: ZipInternalFile[];\n  private d: number;\n\n  /**\n   * Creates an empty ZIP archive to which files can be added\n   * @param cb The callback to call whenever data for the generated ZIP archive\n   *           is available\n   */\n  constructor(cb?: AsyncFlateStreamHandler) {\n    this.ondata = cb;\n    this.u = [];\n    this.d = 1;\n  }\n  /**\n   * Adds a file to the ZIP archive\n   * @param file The file stream to add\n   */\n  add(file: ZipInputFile) {\n    if (!this.ondata) err(5);\n    // finishing or finished\n    if (this.d & 2) this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n    else {\n      const f = strToU8(file.filename), fl = f.length;\n      const com = file.comment, o = com && strToU8(com);\n      const u = fl != file.filename.length || (o && (com.length != o.length));\n      const hl = fl + exfl(file.extra) + 30;\n      if (fl > 65535) this.ondata(err(11, 0, 1), null, false);\n      const header = new u8(hl);\n      wzh(header, 0, file, f, u);\n      let chks: Uint8Array[] = [header];\n      const pAll = () => {\n        for (const chk of chks) this.ondata(null, chk, false);\n        chks = [];\n      };\n      let tr = this.d;\n      this.d = 0;\n      const ind = this.u.length;\n      const uf = mrg(file, {\n        f,\n        u,\n        o,\n        t: () => { \n          if (file.terminate) file.terminate();\n        },\n        r: () => {\n          pAll();\n          if (tr) {\n            const nxt = this.u[ind + 1];\n            if (nxt) nxt.r();\n            else this.d = 1;\n          }\n          tr = 1;\n        }\n      } as ZIFE);\n      let cl = 0;\n      file.ondata = (err, dat, final) => {\n        if (err) {\n          this.ondata(err, dat, final);\n          this.terminate();\n        } else {\n          cl += dat.length;\n          chks.push(dat);\n          if (final) {\n            const dd = new u8(16);\n            wbytes(dd, 0, 0x8074B50)\n            wbytes(dd, 4, file.crc);\n            wbytes(dd, 8, cl);\n            wbytes(dd, 12, file.size);\n            chks.push(dd);\n            uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n            if (tr) uf.r();\n            tr = 1;\n          } else if (tr) pAll();\n        }\n      }\n      this.u.push(uf);\n    }\n  }\n\n  /**\n   * Ends the process of adding files and prepares to emit the final chunks.\n   * This *must* be called after adding all desired files for the resulting\n   * ZIP file to work properly.\n   */\n  end() {\n    if (this.d & 2) {\n      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n      return;\n    }\n    if (this.d) this.e();\n    else this.u.push({\n      r: () => {\n        if (!(this.d & 1)) return;\n        this.u.splice(-1, 1);\n        this.e();\n      },\n      t: () => {}\n    } as unknown as ZipInternalFile);\n    this.d = 3;\n  }\n\n  private e() {\n    let bt = 0, l = 0, tl = 0;\n    for (const f of this.u) tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n    const out = new u8(tl + 22);\n    for (const f of this.u) {\n      wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n    }\n    wzf(out, bt, this.u.length, tl, l)\n    this.ondata(null, out, true);\n    this.d = 2;\n  }\n\n  /**\n   * A method to terminate any internal workers used by the stream. Subsequent\n   * calls to add() will fail.\n   */\n  terminate() {\n    for (const f of this.u) f.t();\n    this.d = 2;\n  }\n\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n}\n\n/**\n * Asynchronously creates a ZIP file\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @param cb The callback to call with the generated ZIP archive\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function zip(data: AsyncZippable, opts: AsyncZipOptions, cb: FlateCallback): AsyncTerminable;\n/**\n * Asynchronously creates a ZIP file\n * @param data The directory structure for the ZIP archive\n * @param cb The callback to call with the generated ZIP archive\n * @returns A function that can be used to immediately terminate the compression\n */\nexport function zip(data: AsyncZippable, cb: FlateCallback): AsyncTerminable;\nexport function zip(data: AsyncZippable, opts: AsyncZipOptions | FlateCallback, cb?: FlateCallback) {\n  if (!cb) cb = opts as FlateCallback, opts = {};\n  if (typeof cb != 'function') err(7);\n  const r: FlatZippable<true> = {};\n  fltn(data, '', r, opts as AsyncZipOptions);\n  const k = Object.keys(r);\n  let lft = k.length, o = 0, tot = 0;\n  const slft = lft, files = new Array<AsyncZipDat>(lft);\n  const term: AsyncTerminable[] = [];\n  const tAll = () => {\n    for (let i = 0; i < term.length; ++i) term[i]();\n  }\n  let cbd: FlateCallback = (a, b) => {\n    mt(() => { cb(a, b); });\n  }\n  mt(() => { cbd = cb; });\n  const cbf = () => {\n    const out = new u8(tot + 22), oe = o, cdl = tot - o;\n    tot = 0;\n    for (let i = 0; i < slft; ++i) {\n      const f = files[i];\n      try {\n        const l = f.c.length;\n        wzh(out, tot, f, f.f, f.u, l);\n        const badd = 30 + f.f.length + exfl(f.extra);\n        const loc = tot + badd;\n        out.set(f.c, loc);\n        wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n      } catch(e) {\n        return cbd(e, null);\n      }\n    }\n    wzf(out, o, files.length, cdl, oe);\n    cbd(null, out);\n  }\n  if (!lft) cbf();\n  // Cannot use lft because it can decrease\n  for (let i = 0; i < slft; ++i) {\n    const fn = k[i];\n    const [file, p] = r[fn];\n    const c = crc(), size = file.length;\n    c.p(file);\n    const f = strToU8(fn), s = f.length;\n    const com = p.comment, m = com && strToU8(com), ms = m && m.length;\n    const exl = exfl(p.extra);\n    const compression = p.level == 0 ? 0 : 8;\n    const cbl: FlateCallback = (e, d) => {\n      if (e) {\n        tAll();\n        cbd(e, null);\n      } else {\n        const l = d.length;\n        files[i] = mrg(p, {\n          size,\n          crc: c.d(),\n          c: d,\n          f,\n          m,\n          u: s != fn.length || (m && (com.length != ms)),\n          compression\n        });\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n        if (!--lft) cbf();\n      }\n    }\n    if (s > 65535) cbl(err(11, 0, 1), null);\n    if (!compression) cbl(null, file);\n    else if (size < 160000) {\n      try {\n        cbl(null, deflateSync(file, p));\n      } catch(e) {\n        cbl(e, null);\n      }\n    } else term.push(deflate(file, p, cbl));\n  }\n  return tAll;\n}\n\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data: Zippable, opts?: ZipOptions) {\n  if (!opts) opts = {};\n  const r: FlatZippable<false> = {};\n  const files: ZipDat[] = [];\n  fltn(data, '', r, opts);\n  let o = 0;\n  let tot = 0;\n  for (const fn in r) {\n    const [file, p] = r[fn];\n    const compression = p.level == 0 ? 0 : 8;\n    const f = strToU8(fn), s = f.length;\n    const com = p.comment, m = com && strToU8(com), ms = m && m.length;\n    const exl = exfl(p.extra);\n    if (s > 65535) err(11);\n    const d = compression ? deflateSync(file, p) : file, l = d.length;\n    const c = crc();\n    c.p(file);\n    files.push(mrg(p, {\n      size: file.length,\n      crc: c.d(),\n      c: d,\n      f,\n      m,\n      u: s != fn.length || (m && (com.length != ms)),\n      o,\n      compression\n    }));\n    o += 30 + s + exl + l;\n    tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n  }\n  const out = new u8(tot + 22), oe = o, cdl = tot - o;\n  for (let i = 0; i < files.length; ++i) {\n    const f = files[i];\n    wzh(out, f.o, f, f.f, f.u, f.c.length);\n    const badd = 30 + f.f.length + exfl(f.extra);\n    out.set(f.c, f.o + badd);\n    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n  }\n  wzf(out, o, files.length, cdl, oe);\n  return out;\n}\n\n/**\n * A decoder for files in ZIP streams\n */\nexport interface UnzipDecoder {  \n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n  \n  /**\n   * Pushes a chunk to be decompressed\n   * @param data The data in this chunk. Do not consume (detach) this data.\n   * @param final Whether this is the last chunk in the data stream\n   */\n  push(data: Uint8Array, final: boolean): void;\n\n  /**\n   * A method to terminate any internal workers used by the stream. Subsequent\n   * calls to push() should silently fail.\n   */\n  terminate?: AsyncTerminable\n}\n\n/**\n * A constructor for a decoder for unzip streams\n */\nexport interface UnzipDecoderConstructor {\n  /**\n   * Creates an instance of the decoder\n   * @param filename The name of the file\n   * @param size The compressed size of the file\n   * @param originalSize The original size of the file\n   */\n  new(filename: string, size?: number, originalSize?: number): UnzipDecoder;\n\n  /**\n   * The compression format for the data stream. This number is determined by\n   * the spec in PKZIP's APPNOTE.txt, section 4.4.5. For example, 0 = no\n   * compression, 8 = deflate, 14 = LZMA\n   */\n  compression: number;\n}\n\n/**\n * Streaming file extraction from ZIP archives\n */\nexport interface UnzipFile {\n  /**\n   * The handler to call whenever data is available\n   */\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * The name of the file\n   */\n  name: string;\n\n  /**\n   * The compression format for the data stream. This number is determined by\n   * the spec in PKZIP's APPNOTE.txt, section 4.4.5. For example, 0 = no\n   * compression, 8 = deflate, 14 = LZMA. If start() is called but there is no\n   * decompression stream available for this method, start() will throw.\n   */\n  compression: number;\n\n  /**\n   * The compressed size of the file\n   */\n  size?: number;\n\n  /**\n   * The original size of the file\n   */\n  originalSize?: number;\n\n  /**\n   * Starts reading from the stream. Calling this function will always enable\n   * this stream, but ocassionally the stream will be enabled even without\n   * this being called.\n   */\n  start(): void;\n\n  /**\n   * A method to terminate any internal workers used by the stream. ondata\n   * will not be called any further.\n   */\n  terminate: AsyncTerminable\n}\n\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nexport class UnzipPassThrough implements UnzipDecoder {\n  static compression = 0;\n  ondata: AsyncFlateStreamHandler;\n  push(data: Uint8Array, final: boolean) {\n    this.ondata(null, data, final);\n  }\n}\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nexport class UnzipInflate implements UnzipDecoder {\n  static compression = 8;\n  private i: Inflate;\n  ondata: AsyncFlateStreamHandler;\n\n  /**\n   * Creates a DEFLATE decompression that can be used in ZIP archives\n   */\n  constructor() {\n    this.i = new Inflate((dat, final) => {\n      this.ondata(null, dat, final);\n    });\n  }\n\n  push(data: Uint8Array, final: boolean) {\n    try {\n      this.i.push(data, final);\n    } catch(e) {\n      this.ondata(e, data, final);\n    }\n  }\n}\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nexport class AsyncUnzipInflate implements UnzipDecoder {\n  static compression = 8;\n  private i: AsyncInflate | Inflate;\n  ondata: AsyncFlateStreamHandler;\n  terminate: AsyncTerminable;\n\n  /**\n   * Creates a DEFLATE decompression that can be used in ZIP archives\n   */\n  constructor(_: string, sz?: number) {\n    if (sz < 320000) {\n      this.i = new Inflate((dat, final) => {\n        this.ondata(null, dat, final);\n      });\n    } else {\n      this.i = new AsyncInflate((err, dat, final) => {\n        this.ondata(err, dat, final);\n      });\n      this.terminate = this.i.terminate;\n    }\n  }\n\n  push(data: Uint8Array, final: boolean) {\n    if ((this.i as AsyncInflate).terminate) data = slc(data, 0);\n    this.i.push(data, final);\n  }\n}\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nexport class Unzip {\n  private d: UnzipDecoder;\n  private c: number;\n  private p: Uint8Array;\n  private k: Uint8Array[][];\n  private o: Record<number, UnzipDecoderConstructor>;\n\n  /**\n   * Creates a ZIP decompression stream\n   * @param cb The callback to call whenever a file in the ZIP archive is found\n   */\n  constructor(cb?: UnzipFileHandler) {\n    this.onfile = cb;\n    this.k = [];\n    this.o = {\n      0: UnzipPassThrough\n    };\n    this.p = et;\n  }\n  \n  /**\n   * Pushes a chunk to be unzipped\n   * @param chunk The chunk to push\n   * @param final Whether this is the last chunk\n   */\n  push(chunk: Uint8Array, final?: boolean) {\n    if (!this.onfile) err(5);\n    if (!this.p) err(4);\n    if (this.c > 0) {\n      const len = Math.min(this.c, chunk.length);\n      const toAdd = chunk.subarray(0, len);\n      this.c -= len;\n      if (this.d) this.d.push(toAdd, !this.c);\n      else this.k[0].push(toAdd);\n      chunk = chunk.subarray(len);\n      if (chunk.length) return this.push(chunk, final);\n    } else {\n      let f = 0, i = 0, is: number, buf: Uint8Array;\n      if (!this.p.length) buf = chunk;\n      else if (!chunk.length) buf = this.p;\n      else {\n        buf = new u8(this.p.length + chunk.length)\n        buf.set(this.p), buf.set(chunk, this.p.length);\n      }\n      const l = buf.length, oc = this.c, add = oc && this.d;\n      for (; i < l - 4; ++i) {\n        const sig = b4(buf, i);\n        if (sig == 0x4034B50) {\n          f = 1, is = i;\n          this.d = null;\n          this.c = 0;\n          const bf = b2(buf, i + 6), cmp = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n          if (l > i + 30 + fnl + es) {\n            const chks: Uint8Array[] = [];\n            this.k.unshift(chks);\n            f = 2;\n            let sc = b4(buf, i + 18), su = b4(buf, i + 22);\n            const fn = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n            if (sc == 4294967295) { [sc, su] = dd ? [-2] : z64e(buf, i); }\n            else if (dd) sc = -1;\n            i += es;\n            this.c = sc;\n            let d: UnzipDecoder;\n            const file = {\n              name: fn,\n              compression: cmp,\n              start: () => {\n                if (!file.ondata) err(5);\n                if (!sc) file.ondata(null, et, true);\n                else {\n                  const ctr = this.o[cmp];\n                  if (!ctr) file.ondata(err(14, 'unknown compression type ' + cmp, 1), null, false);\n                  d = sc < 0 ? new ctr(fn) : new ctr(fn, sc, su);\n                  d.ondata = (err, dat, final) => { file.ondata(err, dat, final); }\n                  for (const dat of chks) d.push(dat, false);\n                  if (this.k[0] == chks && this.c) this.d = d;\n                  else d.push(et, true);\n                }\n              },\n              terminate: () => {\n                if (d && d.terminate) d.terminate();\n              }\n            } as UnzipFile;\n            if (sc >= 0) file.size = sc, file.originalSize = su;\n            this.onfile(file);\n          }\n          break;\n        } else if (oc) {\n          if (sig == 0x8074B50) {\n            is = i += 12 + (oc == -2 && 8), f = 3, this.c = 0;\n            break;\n          } else if (sig == 0x2014B50) {\n            is = i -= 4, f = 3, this.c = 0;\n            break;\n          }\n        }\n      }\n      this.p = et\n      if (oc < 0) {\n        const dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n        if (add) add.push(dat, !!f);\n        else this.k[+(f == 2)].push(dat);\n      }\n      if (f & 2) return this.push(buf.subarray(i), final);\n      this.p = buf.subarray(i);\n    }\n    if (final) {\n      if (this.c) err(13);\n      this.p = null;\n    }\n  }\n\n  /**\n   * Registers a decoder with the stream, allowing for files compressed with\n   * the compression type provided to be expanded correctly\n   * @param decoder The decoder constructor\n   */\n  register(decoder: UnzipDecoderConstructor) {\n    this.o[decoder.compression] = decoder;\n  }\n\n  /**\n   * The handler to call whenever a file is discovered\n   */\n  onfile: UnzipFileHandler;\n}\n\nconst mt = typeof queueMicrotask == 'function' ? queueMicrotask : setTimeout;\n\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data: Uint8Array, cb: UnzipCallback): AsyncTerminable {\n  if (typeof cb != 'function') err(7);\n  const term: AsyncTerminable[] = [];\n  const tAll = () => {\n    for (let i = 0; i < term.length; ++i) term[i]();\n  }\n  const files: Unzipped = {};\n  let cbd: UnzipCallback = (a, b) => {\n    mt(() => { cb(a, b); });\n  }\n  mt(() => { cbd = cb; });\n  let e = data.length - 22;\n  for (; b4(data, e) != 0x6054B50; --e) {\n    if (!e || data.length - e > 65558) {\n      cbd(err(13, 0, 1), null);\n      return tAll;\n    }\n  };\n  let lft = b2(data, e + 8);\n  if (lft) {\n    let c = lft;\n    let o = b4(data, e + 16);\n    const z = o == 4294967295;\n    if (z) {\n      e = b4(data, e - 12);\n      if (b4(data, e) != 0x6064B50) {\n        cbd(err(13, 0, 1), null);\n        return tAll;\n      }\n      c = lft = b4(data, e + 32);\n      o = b4(data, e + 48);\n    }\n    for (let i = 0; i < c; ++i) {\n      const [c, sc, su, fn, no, off] = zh(data, o, z), b = slzh(data, off);\n      o = no\n      const cbl: FlateCallback = (e, d) => {\n        if (e) {\n          tAll();\n          cbd(e, null);\n        } else {\n          files[fn] = d;\n          if (!--lft) cbd(null, files);\n        }\n      }\n      if (!c) cbl(null, slc(data, b, b + sc))\n      else if (c == 8) {\n        const infl = data.subarray(b, b + sc);\n        if (sc < 320000) {\n          try {\n            cbl(null, inflateSync(infl, new u8(su)));\n          } catch(e) {\n            cbl(e, null);\n          }\n        }\n        else term.push(inflate(infl, { size: su }, cbl));\n      } else cbl(err(14, 'unknown compression type ' + c, 1), null);\n    }\n  } else cbd(null, {});\n  return tAll;\n}\n\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data: Uint8Array) {\n  const files: Unzipped = {};\n  let e = data.length - 22;\n  for (; b4(data, e) != 0x6054B50; --e) {\n    if (!e || data.length - e > 65558) err(13);\n  };\n  let c = b2(data, e + 8);\n  if (!c) return {};\n  let o = b4(data, e + 16);\n  const z = o == 4294967295;\n  if (z) {\n    e = b4(data, e - 12);\n    if (b4(data, e) != 0x6064B50) err(13);\n    c = b4(data, e + 32);\n    o = b4(data, e + 48);\n  }\n  for (let i = 0; i < c; ++i) {\n    const [c, sc, su, fn, no, off] = zh(data, o, z), b = slzh(data, off);\n    o = no;\n    if (!c) files[fn] = slc(data, b, b + sc);\n    else if (c == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n    else err(14, 'unknown compression type ' + c);\n  }\n  return files;\n}","// @ts-nocheck\n\nimport { strFromU8, strToU8, zlibSync } from '../fflate';\nimport { PackFn, MARK, eventWithTimeAndPacker } from './base';\n\nexport const pack: PackFn = (event) => {\n  const _e: eventWithTimeAndPacker = {\n    ...event,\n    v: MARK,\n  };\n  return strFromU8(zlibSync(strToU8(JSON.stringify(_e))), true);\n};\n","import { eventWithTime } from '../types';\n\nexport type PackFn = (event: eventWithTime) => string;\nexport type UnpackFn = (raw: string) => eventWithTime;\n\nexport type eventWithTimeAndPacker = eventWithTime & {\n  v: string;\n};\n\nexport const MARK = 'v1';\n","import { AskLevel } from \"../types/types\"\nimport { config } from \"../config/config\"\nimport { W } from \"../constants\"\nimport record from \"../rrweb/record\"\nimport { pack } from \"../rrweb/packer\"\nimport { eventWithTime } from \"../rrweb/types\"\nimport { warn } from \"../utils/console\"\n/**\n * Error Trap\n */\n\nexport default class ErrorTrace {\n  private static instance: ErrorTrace | null = null\n  private eventsMatrix: Array<Array<eventWithTime>> = [[]]\n\n  private constructor() {\n    this.globalErrorTrace()\n    this.networkErrorTrace()\n    this.promiseErrorTrace()\n    this.iframeErrorTrace()\n    record({\n      ...config.recordOptions,\n      emit: (event, isCheckout) => {\n        if (isCheckout) {\n          this.eventsMatrix.push([]);\n        }\n        const lastEvents = this.eventsMatrix[this.eventsMatrix.length - 1];\n        lastEvents.push(event);\n      },\n      recordLog: false,\n      checkoutEveryNth: 10,\n      packFn: pack,\n    })\n  }\n\n  public static getInstance(): ErrorTrace {\n    if (!this.instance) {\n      this.instance = new ErrorTrace()\n    }\n    return this.instance\n  }\n\n  /**\n   * Globally catch synchronous or asynchronous errors\n   * 捕获异常的能力比try-catch稍微强点，无论是异步还是非异步，onerror都能捕获到运行时错误，返回true就不回报红\n   * 当时当<img src=\"\" />这种情况是捕获不到的\n   * 使用未使用的变量\n   */\n  private globalErrorTrace(): void {\n    W.onerror = (\n      event: Event | string,\n      source?: string,\n      lineno?: number,\n      colno?: number,\n      error?: Error\n    ) => {\n\n      warn({\n        source,\n        lineno,\n        colno,\n        error,\n      })\n\n      const len = this.eventsMatrix.length;\n\n      if (config.errEventRoute && len >= 2) {\n        const events = this.eventsMatrix[len - 2].concat(this.eventsMatrix[len - 1]);\n        config.reportData?.fetch(\n          AskLevel.IDLE,\n          JSON.stringify({ events }),\n          config.errEventRoute\n        )\n      }\n\n      if (config.errLogRoute) {\n        config.reportData?.fetch(\n          AskLevel.IDLE,\n          JSON.stringify({\n            source,\n            lineno,\n            colno,\n            error: JSON.stringify({\n              message: error?.message,\n              stack: error?.stack,\n              name: error?.name,\n            }),\n          }),\n          config.errLogRoute\n        )\n      }\n      return true\n    }\n  }\n  /**\n   * Catch network errors\n   * 图片加载失败等\n   */\n  private networkErrorTrace(): void {\n    W.addEventListener(\n      \"error\",\n      (e: ErrorEvent) => {\n        if (e.target !== W) {\n          warn(e.target)\n        }\n      },\n      true\n    )\n  }\n\n  /**\n   * Catching Promise errors\n   */\n  private promiseErrorTrace(): void {\n    window.addEventListener(\"unhandledrejection\", (e) => {\n      e.preventDefault()\n      warn(e.reason)\n      return true\n    })\n  }\n\n  private iframeErrorTrace(): void {\n    const frames = W.frames\n    for (let i = 0; i < frames.length; i++) {\n      frames[i].addEventListener(\n        \"error\",\n        (e: ErrorEvent) => {\n          warn(e)\n        },\n        true\n      )\n      frames[i].addEventListener(\n        \"unhandledrejection\",\n        (e) => {\n          warn(e)\n        },\n        true\n      )\n    }\n  }\n}\n","import { AskLevel, ReportDataAchieve } from \"../types/types\"\nimport { W, WN } from \"../constants\"\nimport { config } from \"../config/config\"\n\nexport interface ReportDataOptions {\n  logDomain: string | undefined,\n}\n\n/**\n * Log collection\n * 日志收集\n */\nexport default class ReportData implements ReportDataAchieve {\n  /**\n   * Log report, error report\n   * If the level is urgent, use http request directly, otherwise use navigator.sendBeacon\n   * 日志上报、错误上报\n   * 如果level很紧急，直接使用http请求，否者使用navigator.sendBeacon\n   * @param level\n   * @param body \n   * @param uri \n   */\n  public fetch(level: AskLevel, body: string, uri: string): void {\n    uri = config.fetchDomain + uri\n\n    switch (level) {\n      case AskLevel.URGENT: {\n        if (!!W.fetch) {\n          fetch(uri, { body, method: \"POST\", keepalive: true })\n        } else {\n          let xhr: XMLHttpRequest | null = new XMLHttpRequest()\n          xhr.open(\"post\", uri, true)\n          xhr.setRequestHeader(\"Content-Type\", \"application/json\")\n          xhr.send(body)\n          xhr.onload = () => xhr = null // 防止内存泄漏\n        }\n        return\n      }\n      default:\n        if (!!WN.sendBeacon) {\n          navigator.sendBeacon(uri, body)\n        } else {\n          let image: HTMLImageElement | null = new Image()\n          image.src = `${uri}?body=${body}`\n          image.onload = () => image = null // 防止内存泄漏\n        }\n    }\n  }\n}","import { W, WP } from \"../constants\"\n\n/**\n * Determine whether the browser supports getEntriesByType\n * @returns \n */\nexport const isPerformanceSupported = (): boolean => {\n  return WP && !!WP.getEntriesByType && !!WP.now && !!WP.mark\n}\n\n/**\n * bytes to kb\n * @param {number} bytes\n */\nexport const bytes2kb = (bytes: number) => {\n  return parseFloat((bytes / Math.pow(1024, 2)).toFixed(2))\n}\n\n/**\n * Keep two decimal places\n * @param {number} num\n * @returns \n */\nexport const roundByTwo = (num: number) => {\n  return parseFloat(num.toFixed(2))\n}\n\n/**\n * PushTask to requestIdleCallback\n * Efficient use of each frame for data collection\n * @param {() => void} callback\n */\nexport const pushTask = (callback: () => void) => {\n  if (\"requestIdleCallback\" in W) {\n    (W as any).requestIdleCallback(callback, { timeout: 3000 })\n  } else {\n    callback()\n  }\n}","import { bytes2kb } from \"../utils/helper\"\nimport { WN } from \"../constants\"\nimport type { StorageOpt } from \"../types/types\"\n\n/**\n  * Record local cache information\n*/\n\nexport const recordingStorage = async (): Promise<StorageOpt> => {\n  const { quota, usage, usageDetails } = await WN.storage.estimate() as StorageOpt\n  let res = {\n    quota: bytes2kb(quota || 0),\n    usage: bytes2kb(usage || 0),\n    usageDetails,\n  }\n  if (res.usageDetails) {\n    Object.keys(res.usageDetails || {}).forEach(key => res.usageDetails[key] = bytes2kb(res.usageDetails[key]))\n  }\n  return res\n}","import { WN } from \"../constants\"\nimport type { EffectiveType, NavigatorOpt } from \"../types/types\"\nimport { pushTask } from \"../utils/helper\"\n\nexport let effectiveType: EffectiveType = \"4g\"\nexport let saveData: boolean = false\n\n/**\n   * Get user's browser information, internet speed and other information\n   * Calculating network speed formula\n   * T1 = DNS + New Connection(TCP) + RTT(One-time transmission)\n   * T2 = New Connection(TCP) + RTT(One-time transmission)\n   * T3 = RTT(One-time transmission)\n   * bandwidth = (100k-50k)/(t5-t4)\n   * @return {NavigatorOpt}\n   */\nexport const recordClientNavigator = async (): Promise<NavigatorOpt> => {\n  return new Promise(resolve => {\n    let res = {} as NavigatorOpt\n    if (\"connection\" in WN) {\n      res.connection = {\n        downlink: WN.connection.downlink,\n        effectiveType: WN.connection.effectiveType,\n        rtt: WN.connection.rtt,\n        saveData: WN.connection.saveData,\n      }\n      saveData = res.connection.saveData || saveData\n      effectiveType = res.connection.effectiveType || effectiveType\n    }\n    // Doppler Velocity\n    if (\"fetch\" in window) {\n      pushTask(async () => {\n        let times = []\n        const sizes = [0, 0, 0, 50, 100]\n        const fetchs = sizes.map(i => (() => new Promise(async resolve => {\n          await fetch(`http://performance-monitoring.zhourengui.top/performance-monitoring/doppler-velocity?size=${i}`)\n          resolve(true)\n        })))\n\n        times.push(+ new Date())\n\n        while (fetchs.length) {\n          const f = fetchs.shift()\n          await f?.()\n          times.push(+ new Date())\n        }\n        res.connection.bandwidth = `${((sizes[4] - sizes[3]) / ((times[5] - times[4]) / 1000)).toFixed(2)} k/s`\n        resolve(res)\n      })\n    }\n\n    res.userAgent = WN.userAgent\n  })\n}","import { WP } from \"../constants\"\nimport { isPerformanceSupported } from \"../utils/helper\"\nimport type { TimingOpt } from \"../types/types\"\n/**\n  * Navigation Timing API provides performance metrics for HTML documents.\n  * w3c.github.io/navigation-timing/\n  * developers.google.com/web/fundamentals/performance/navigation-and-resource-timing\n  */\nexport const recordTiming = async (): Promise<TimingOpt> => {\n  let res = {} as TimingOpt\n  if (isPerformanceSupported()) {\n    // There is an open issue to type correctly getEntriesByType\n    // github.com/microsoft/TypeScript/issues/33866\n    const n = WP.getEntriesByType(\"navigation\")[0] as any\n    if (n) {\n      const responseEnd = n.responseEnd\n      const responseStart = n.responseStart\n      const requestStart = n.requestStart\n      res = {\n        // fetchStart marks when the browser starts to fetch a resource\n        // responseEnd is when the last byte of the response arrives\n        fetchTime: responseEnd - n.fetchStart,\n        // Service worker time plus response time\n        workerTime: responseEnd - n.workerStart,\n        // Request plus response time (network only)\n        networkTime: responseEnd - requestStart,\n        // Response time only (download)\n        downloadTime: responseEnd - responseStart,\n        // Time to First Byte (TTFB)\n        timeToFirstByte: responseStart - requestStart,\n        // HTTP header size\n        headerSize: n.decodedBodySize - n.transferSize || 0,\n        // DNS Lookup Time\n        dnsLookupTime: n.domainLookupStart - n.domainLookupEnd,\n        // TCP time\n        tcpTime: n.connectStart - n.connectEnd || 0,\n        // First paint\n        firstPaintTime: responseEnd - responseStart || 0,\n        // Dom Parse Time\n        domParseTime: n.domComplete - n.domInteractive,\n        // Dom Render Time\n        domRenderTime: n.domContentLoadedEventEnd - n.domContentLoadedEventStart || 0,\n        // onload time\n        onloadTime: n.loadEventEnd - n.loadEventStart\n      }\n    }\n  }\n\n  return res\n}","import { WN } from \"../constants\"\nimport { effectiveType, saveData } from \"../performance/record-client-navigator\"\nimport { EffectiveType, NavigatorInformation } from \"../types/types\"\n\nexport const isLowEndDevice = (): boolean => {\n  return WN.deviceMemory <= 4 || WN.hardwareConcurrency <= 4\n}\n\nexport const isLowEndExperience = (\n  effectiveType: EffectiveType,\n  saveData: boolean\n): boolean => {\n  if ([\"slow-2g\", \"2g\", \"3g\"].includes(effectiveType)) {\n    return true\n  }\n\n  return isLowEndDevice() || saveData\n}\n\n/**\n * 信息来源于 window.navigator:\n * 1. Device Memory 设备内存\n * 2. Hardware Concurency 并发数\n * 3. Status of the service worker:\n *     - controlled: a service worker is controlling the page\n *     - supported: the browser supports service worker\n *     - unsupported: the user's browser does not support service worker\n */\nexport const getNavigatorInformation = (): NavigatorInformation | undefined => {\n  if (WN) {\n    return {\n      deviceMemory: WN.deviceMemory || 0,\n      hardwareConcurrency: WN.hardwareConcurrency || 0,\n      serviceWorkerStatus:\n        'serviceWorker' in WN\n          ? WN.serviceWorker?.controller\n            ? \"controlled\"\n            : \"supported\"\n          : \"unsupported\",\n      isLowEndDevice: isLowEndDevice(),\n      isLowEndExperience: isLowEndExperience(effectiveType, saveData)\n    }\n  }\n}","import { NavigatorOpt, TimingOpt, VitalsScore } from \"../types/types\";\n\n/**\n * https://web.dev/vitals/\n * https://web.dev/cls/\n */\nconst fcpScore = [1000, 2500];\nconst lcpScore = [2500, 4000];\nconst fidcore = [100, 300];\nconst clsScore = [0.1, 0.25];\nconst tbtScore = [300, 600];\n\nexport const webVitalsScore: Record<string, number[]> = {\n  fp: fcpScore,\n  fcp: fcpScore,\n  lcp: lcpScore,\n  lcpFinal: lcpScore,\n  fid: fidcore,\n  fidVitals: fidcore,\n  cls: clsScore,\n  clsFinal: clsScore,\n  tbt: tbtScore,\n  tbt5S: tbtScore,\n  tbt10S: tbtScore,\n  tbtFinal: tbtScore,\n};\n\nexport const getVitalsScore = (\n  measureName: string,\n  value: number\n): VitalsScore => {\n  if (!webVitalsScore[measureName]) {\n    return null\n  }\n\n  if (value <= webVitalsScore[measureName][0]) {\n    return \"good\"\n  }\n\n  return value <= webVitalsScore[measureName][1] ? \"needsImprovement\" : \"poor\"\n}","import { config } from \"../config/config\"\nimport { D } from \"../constants\"\nimport { NavigatorOpt, TimingOpt } from \"../types/types\"\nimport { pushTask } from \"./helper\"\nimport { getNavigatorInformation } from \"./navigator-information\"\nimport { getVitalsScore } from \"./vitals-score\"\n\n/**\n * Sends the User timing measure to analyticsTracker\n * Do not report specific data when the page is hidden\n * @param {string} measureName\n * @param {number} duration\n * @param {object} eventProperties\n */\nexport const reportPerformance = (\n  data: TimingOpt | number | NavigatorOpt | any,\n  measureName: string,\n  eventProperties?: object\n): void => {\n  pushTask(() => {\n    if (D.visibilityState === \"hidden\" && !measureName.includes(\"Final\") || !config.analyticsTracker) return\n    config.analyticsTracker({\n      metricName: measureName,\n      data,\n      eventProperties,\n      navigatorInformation: getNavigatorInformation(),\n      vitalsScore: getVitalsScore(measureName, data as number)\n    })\n  })\n}","import { config } from \"../config/config\"\nimport { roundByTwo } from \"./helper\"\nimport { reportPerformance } from \"./report-performance\"\n\n/**\n * Sends the metric to an external tracking service\n * 将指标发送到外部跟踪服务\n * @param {string} measureName \n * @param {{[key: string]: any}} metric \n * @param {object} customProperties \n */\nexport const logData = (\n  measureName: string,\n  metric: { [key: string]: any },\n  customProperties?: object\n): void => {\n  Object.keys(metric).forEach((key) => {\n    if (typeof metric[key] === 'number') {\n      metric[key] = roundByTwo(metric[key]);\n    }\n  });\n  reportPerformance(metric, measureName, customProperties);\n};\n\n/**\n * Dispatches the metric duration into internal logs\n * and the external time tracking service.\n * @param {string} measureName\n * @param {number} duration\n * @param {object} customProperties\n */\nexport const logMetric = (\n  measureName: string,\n  duration: number,\n  customProperties?: object\n) => {\n  const duration2decimal = roundByTwo(duration)\n  if (duration2decimal <= (config.maxTime as number)) {\n    reportPerformance(duration, measureName, customProperties)\n  }\n}","import { ResourceTime } from \"../types/types\";\n\n// first-pait\nexport const fp = {\n  value: 0\n}\n\n// first-contentful-paint\nexport const fcp = {\n  value: 0\n}\n\n// block-time\nexport const bt = {\n  value: 0\n}\n\n// largest-contentful-paint\nexport const lcp = {\n  value: 0\n}\n\n// resource-time\nexport const rt: { value: ResourceTime } = {\n  value: {\n    beacon: 0,\n    css: 0,\n    fetch: 0,\n    img: 0,\n    other: 0,\n    script: 0,\n    total: 0,\n    xmlhttprequest: 0,\n  },\n};\n\n// cumulative-layout-shift\nexport const cls = {\n  value: 0\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logMetric } from \"../utils/log\"\nimport { fcp, fp, lcp } from \"../utils/metrics\"\nimport { disconnectPO } from \"./performance-observer\"\n\n/**\n * FirstPaintObserverCallback\n * @returns \n */\nexport const initFirstPaint = (\n  callback: () => void\n) => (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (entry.name === \"first-paint\") {\n      fp.value = entry.startTime\n      logMetric(\"fp\", entry.startTime)\n    } else if (entry.name === \"first-contentful-paint\") {\n      fcp.value = entry.startTime\n      logMetric(\"fcp\", entry.startTime)\n      callback()\n      disconnectPO(\"paint\")\n    }\n  }\n}\n\n/**\n * LargestContentfulPaintObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries \n */\nexport const initLargestContentfulPaint = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry) {\n    lcp.value = lastEntry.renderTime || lastEntry.startTime\n  }\n}\n\n/**\n * ElementTimingObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries\n */\nexport const initElementTiming = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (entry.identifier) {\n      logMetric(entry.identifier, entry.startTime, {\n        performanceEntry: entry\n      })\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logMetric } from \"../utils/log\"\nimport { bt, fcp } from \"../utils/metrics\"\n\n/**\n * LongtaskObserverCallback\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Long_Tasks_API\n * The definition of a long task is a task longer than 50ms\n * 长任务的定义是超过50ms的任务\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns \n */\nexport const initLongtask = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    const blockingTime = entry.startTime - 50\n    if (entry.name !== \"self\" && entry.startTime < fcp.value) return\n    if (blockingTime > 0) {\n      bt.value += entry.startTime\n      logMetric(\"longtask\", entry.startTime)\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logData, logMetric } from \"../utils/log\"\nimport { bt, cls, lcp, rt } from \"../utils/metrics\"\nimport { disconnectPO, performanceObserverInstance } from \"./performance-observer\"\n\n/**\n * FirstInputObserverCallback\n * Take the last entry\n * @param {Array<PerformanceEntryEncapsulation>} entries\n */\nexport const initFirstInput = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry) {\n    // Core Web Vitals FID logic\n    // Delayed operation of measurement input events\n    // 测量输入事件的延迟操作\n    logMetric(\n      \"fidVitals\",\n      lastEntry.processingStart - lastEntry.startTime,\n      {\n        performanceEntry: lastEntry\n      }\n    )\n\n    // Measure the duration of processing the first input event\n    // 测量处理第一个输入事件的持续时间\n    logMetric(\n      \"fid\",\n      lastEntry.duration,\n      {\n        performanceEntry: lastEntry\n      }\n    )\n  }\n\n  // Destroy the registered callback for FID to avoid memory leaks caused by too many observers\n  // 销毁对FID的注册回调 避免过多的观察者造成内存泄露\n  disconnectPO(\"first-input\")\n\n  // lcp log\n  logMetric(\"lcp\", lcp.value)\n\n  // Force any pending records to be dispatched\n  // 强制分派所有待处理的记录\n  if (\n    performanceObserverInstance[\"layout-shift\"] &&\n    typeof performanceObserverInstance[\"layout-shift\"].takeRecords === \"function\"\n  ) {\n    performanceObserverInstance[\"layout-shift\"].takeRecords()\n  }\n\n  // cls log\n  logMetric(\"cls\", cls.value)\n\n  // bt log\n  logMetric(\"bt\", bt.value)\n\n  // TBT with 5 second delay after FID\n  setTimeout(() => {\n    logMetric(\"bt5S\", bt.value)\n  }, 5000)\n\n  // TBT with 10 second delay after FID\n  // 10S overall data consumption after FID is activated\n  setTimeout(() => {\n    logMetric(\"bt10S\", bt.value)\n    logData(\"dataConsumption\", rt.value)\n  }, 10000)\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logData, logMetric } from \"../utils/log\"\nimport { bt, fcp, rt } from \"../utils/metrics\"\n\n/**\n * ResouceTimingObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns \n */\nexport const initResouceTiming = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n\n    logData(\"resourceTiming\", entry)\n\n    if (entry.decodedBodySize && entry.initiatorType) {\n      const bodySize = entry.decodedBodySize / 1000\n      rt.value[entry.initiatorType] += bodySize\n      rt.value.total += bodySize\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\";\nimport { cls } from \"../utils/metrics\";\n\n/**\n * https://web.dev/cls/\n * https://requestmetrics.com/web-performance/cumulative-layout-shift\n * \n * Cumulative Layout Shift (CLS), \n * sometimes known as jank, \n * is a measurement of how much elements move due to late-rendered content.\n * You can think of it as a measurement of layout instability. \n * It has become a common problem for many websites due to third-party scripts and tag management and its one of the new Core Web Vital metrics.\n * \n * LayoutShiftObserverCallback\n * Detects new layout shift occurrences and updates the\n * Only count layout shifts without recent user input.\n * 检测新的布局偏移情况并更新\n * 仅在没有最近用户输入的情况下计算布局转移。\n * \n * What is a good CLS score?\n * To provide a good user experience, sites should strive to have a CLS score of 0.1 or less. To ensure you're hitting this target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices.\n * 为了提供良好的用户体验，网站应努力使CLS得分不超过0.1。为确保您达到大多数用户的这一目标，衡量移动设备和台式机设备的页面加载量的第75个百分位数是一个很好的衡量标准。\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns\n */\nexport const initLayoutShift = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry && !lastEntry.hadRecentInput && lastEntry.value) {\n    cls.value += lastEntry.value\n  }\n}","import { PerformanceEntryEncapsulation, PerformanceObserverEventType, PerformanceObservers } from \"../types/types\"\nimport { name } from \"../../package.json\"\nimport { C } from \"../constants\"\nimport { initElementTiming, initFirstPaint, initLargestContentfulPaint } from \"./paint\"\nimport { initLongtask } from \"./longtask\"\nimport { initFirstInput } from \"./first-input\"\nimport { config } from \"../config/config\"\nimport { initResouceTiming } from \"./resource\"\nimport { initLayoutShift } from \"./layout-shift\"\nimport { logMetric } from \"../utils/log\"\nimport { bt, cls, lcp } from \"../utils/metrics\"\n\nexport const performanceObserverInstance: PerformanceObservers = {}\n\n/**\n * PerformanceObserver asynchronous subscription\n * PerformanceObserver异步订阅\n * @param {PerformanceObserverEventType} eventType 监听的事件类型 Types of events monitored\n * @param {(entries: Array<PerformanceEntryEncapsulation>) => void} callback 监听的回调 Listened callback\n */\nconst asyncSubscripePO = (\n  eventType: PerformanceObserverEventType,\n  callback: (entries: Array<PerformanceEntryEncapsulation>) => void\n): PerformanceObserver | null => {\n  try {\n    const Observer = new PerformanceObserver(\n      (entries) =>\n        callback(\n          entries.getEntries() as Array<PerformanceEntryEncapsulation>\n        )\n    )\n    Observer.observe({ type: eventType, buffered: true })\n    return Observer\n  } catch (error) {\n    C.warn(\"PerformanceMonitoring obsever🌲:\",`${name}: ${error}`);\n  }\n  return null\n}\n\n/**\n * Cancel the monitoring of PerformanceObserver\n * 取消PerformanceObserver的监听\n * @param {string} eventType 监听的事件类型 Types of events monitored\n */\nexport const disconnectPO = (eventType: string) => {\n  if (performanceObserverInstance[eventType]) {\n    performanceObserverInstance[eventType]?.disconnect()\n  }\n  delete performanceObserverInstance[eventType]\n}\n\n/**\n * PerformanceObserver initialization\n * PerformanceObserver初始化\n * paint: fp、fcp、largest-contentful-paint\n * longtask\n * first-input\n */\nexport const initPerformanceObserver = (): void => {\n  performanceObserverInstance[\"paint\"] = asyncSubscripePO(\n    \"paint\",\n    initFirstPaint(\n      () => performanceObserverInstance[\"longtask\"] = asyncSubscripePO(\"longtask\", initLongtask)\n    )\n  )\n\n  performanceObserverInstance[\"first-input\"] = asyncSubscripePO(\n    \"first-input\",\n    initFirstInput\n  )\n\n  performanceObserverInstance[\"largest-contentful-paint\"] = asyncSubscripePO(\n    \"largest-contentful-paint\",\n    initLargestContentfulPaint\n  )\n\n  // Collect page performance data\n  // 收集页面性能数据\n  if (config.isObserverResourceTiming) {\n    asyncSubscripePO(\"resource\", initResouceTiming)\n  }\n\n  performanceObserverInstance[\"layout-shift\"] = asyncSubscripePO(\n    \"layout-shift\",\n    initLayoutShift\n  )\n\n  if (config.isObserverElementTiming) {\n    asyncSubscripePO(\"element\", initElementTiming)\n  }\n}\n\n\nexport const disconnectPerformanceObserver = (): void => {\n  if (performanceObserverInstance[\"largest-contentful-paint\"]) {\n    logMetric(\"lcpFinal\", lcp.value)\n    disconnectPO(\"largest-contentful-paint\")\n  }\n\n  if (performanceObserverInstance[\"layout-shift\"]) {\n    // Force any pending records to be dispatched\n    // 强制分派所有待处理的记录\n    if (typeof performanceObserverInstance[\"layout-shift\"].takeRecords === \"function\") {\n      performanceObserverInstance[\"layout-shift\"].takeRecords()\n    }\n    logMetric(\"clsFinal\", cls.value)\n    disconnectPO(\"layout-shift\")\n  }\n\n  if (performanceObserverInstance[\"longtask\"]) {\n    logMetric(\"btFinal\", bt.value)\n    disconnectPO(\"longtask\")\n  }\n}","import ErrorTrace from \"./error-trace\"\nimport ReportData from \"./utils/ReportData\"\nimport { recordingStorage } from \"./performance/record-storage\"\nimport { version } from \"../package.json\"\nimport { config } from \"./config/config\"\nimport { recordClientNavigator } from \"./performance/record-client-navigator\"\nimport { recordTiming } from \"./performance/record-timing\"\nimport { isPerformanceSupported } from \"./utils/helper\"\nimport { AskLevel, PerformanceMonitoringOptions } from \"./types/types\"\nimport { disconnectPerformanceObserver, initPerformanceObserver } from \"./performance/performance-observer\"\nimport { D } from \"./constants\"\nimport { log } from \"./utils/console\"\n\n/**\n * A performance monitoring platform SDK\n * Features include error capture, error recording, performance monitoring\n * 功能包括错误捕获、错误录制、性能监控\n * 一款性能监控平台SDK\n * @packageDocumentation\n */\nexport default class PerformanceMonitoring {\n  constructor(options: PerformanceMonitoringOptions = {}) {\n    const {\n      isObserverElementTiming,\n      isObserverResourceTiming,\n      maxTime,\n      captureError,\n      fetchDomain,\n      errLogRoute,\n      errEventRoute,\n      logRoute,\n      analyticsTracker,\n      recordOptions,\n    } = options\n\n    config.isObserverElementTiming = !!isObserverElementTiming\n    config.isObserverResourceTiming = !!isObserverResourceTiming\n    config.maxTime = maxTime || config.maxTime\n    config.captureError = captureError || config.captureError\n    config.fetchDomain = fetchDomain\n    config.errLogRoute = errLogRoute\n    config.errEventRoute = errEventRoute\n    config.logRoute = logRoute\n    config.reportData = new ReportData()\n    config.analyticsTracker = analyticsTracker || config.analyticsTracker\n    config.recordOptions = recordOptions || config.recordOptions\n\n    log(version)\n\n    if (captureError && fetchDomain) {\n      ErrorTrace.getInstance()\n    }\n\n    if (isPerformanceSupported()) {\n\n      if (D.visibilityState === \"hidden\") {\n        D.addEventListener(\n          \"visibilitychange\",\n          disconnectPerformanceObserver\n        )\n      }\n\n      if (fetchDomain && logRoute) {\n        Promise.all([\n          recordTiming(),\n          recordClientNavigator(),\n          recordingStorage()\n        ]).then(res => {\n          config.reportData?.fetch(\n            AskLevel.IDLE,\n            JSON.stringify(res),\n            logRoute\n          )\n        })\n      }\n\n      initPerformanceObserver()\n    }\n  }\n}"],"names":["AskLevel","W","window","WP","performance","WN","navigator","C","console","D","document","log","message","options","warn","config","isObserverResourceTiming","isObserverElementTiming","maxTime","captureError","reportData","analyticsTracker","recordOptions","NodeType","isShadowRoot","n","host","Boolean","shadowRoot","_id","tagNameRegex","RegExp","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","isCSSImportRule","styleSheet","cssText","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","filePath","maybeQuote","test","url","indexOf","split","slice","extractOrigin","stack","parts","pop","part","push","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","transformAttribute","tagName","name","value","pos","collectCharacters","regEx","chars","match","exec","substring","length","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","nodeType","ELEMENT_NODE","classList","contains","forEach","className","matches","parentNode","lowerIfExists","maybeAttr","undefined","toLowerCase","serializeNodeWithId","blockClass","blockSelector","skipChild","inlineStylesheet","maskInputOptions","maskTextFn","slimDOMOptions","recordCanvas","onSerialize","onIframeLoad","iframeLoadTimeout","preserveWhiteSpace","_serializedNode","rootId","__sn","docId","id","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","eIndex","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","textContent","repeat","checked","parentElement","selected","rr_dataURL","toDataURL","rr_mediaState","paused","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","width","height","getBoundingClientRect","class","rr_width","rr_height","src","Element","isSVG","el","SVGElement","TEXT_NODE","parentTagName","isStyle","isScript","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNode","sn","comment","script","as","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","Object","assign","recordChild","headWhitespace","bypassOptions","childN","serializedChildNode","isElement","isShadowHost","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","timer","setTimeout","addEventListener","clearTimeout","blankUrl","location","onceIframeLoaded","iframeDoc","contentDocument","serializedIframeNode","EventType","IncrementalSource","MouseInteractions","ReplayerEvents","on","fn","target","capture","passive","removeEventListener","DEPARTED_MIRROR_ACCESS_WARNING","_mirror","getId","getNode","removeNodeFromMap","has","reset","throttle","func","wait","timeout","previous","arg","now","Date","leading","remaining","context","this","args","arguments","apply","trailing","hookSetter","key","d","isRevoked","original","getOwnPropertyDescriptor","defineProperty","set","call","patch","source","replacement","wrapped","prototype","defineProperties","__rrweb_original__","enumerable","getWindowHeight","innerHeight","documentElement","clientHeight","body","getWindowWidth","innerWidth","clientWidth","isBlocked","isIgnored","isAncestorRemoved","mirror","isTouchEvent","event","changedTouches","isIframeINode","hasShadowRoot","isNodeInLinkedList","Proxy","Reflect","get","prop","receiver","DoubleLinkedList","constructor","position","Error","current","head","index","next","addNode","__ln","previousSibling","nextSibling","removeNode","moveKey","parentId","isINode","MutationBuffer","Set","mutations","processMutation","emit","frozen","locked","adds","addList","getNextId","ns","nextId","pushAdd","shadowHost","getRootNode","_n$getRootNode","notInDoc","currentN","iframeManager","addIframe","shadowDomManager","addShadowRoot","iframe","childSn","attachIframe","mapRemoves","shift","movedSet","isParentRemoved","removes","addedSet","isAncestorInSet","droppedSet","add","candidate","_node","payload","texts","text","filter","attribute","movedMap","emissionCallback","m","oldValue","getAttribute","attributeName","item","addedNodes","genAdds","removedNodes","nodeId","deepDelete","targetId","delete","init","cb","freeze","unfreeze","isFrozen","lock","unlock","addsSet","some","r","pathToSelector","outerHTML","path","localName","parent","domSiblings","children","i","sibling","stringify","obj","stringifyOptions","numOfKeysLimit","keys","JSON","thisPos","splice","Infinity","_obj","str","toString","stringLengthLimit","Event","eventResult","eventKey","eventValue","isArray","Node","HTMLElement","nodeName","StackFrame","fileName","functionName","lineNumber","columnNumber","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","ErrorStackParser","parse","stacktrace","parseOpera","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","line","sanitizedLine","tokens","locationParts","functionNameRegex","e","parseOpera9","parseOpera11","parseOpera10","lineRE","lines","result","len","parseFloat","mutationBuffers","initMutationObserver","rootEl","mutationBuffer","mutationObserverCtor","MutationObserver","__rrMutationObserver","angularZoneSymbol","_window","Zone","_window$Zone","__symbol__","observer","processMutations","bind","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","INPUT_TAGS","lastInputValueMap","WeakMap","IframeManager","mutationCb","iframes","addLoadListener","loadListener","isAttachIframe","ShadowDomManager","wrapEvent","timestamp","wrappedEmit","takeFullSnapshot","child","hasOwnProperty","record","checkoutEveryNms","checkoutEveryNth","ignoreClass","maskAllInputs","_maskInputOptions","_slimDOMOptions","maskInputFn","hooks","packFn","sampling","mousemoveWait","collectFonts","recordLog","mousemove","color","date","datetime-local","email","month","number","range","search","tel","time","week","textarea","select","defaultLogOptions","level","lengthThreshold","logger","logOptions","lastFullSnapshotEvent","NodeList","DOMTokenList","TypeError","polyfill","incrementalSnapshotCount","isCheckout","FullSnapshot","IncrementalSnapshot","data","Mutation","buf","exceedTime","wrappedMutationEmit","Meta","idNodeMap","slimDOM","password","snapshot","initialOffset","left","pageXOffset","_document2","_document2$body","_document2$body$paren","_document3","top","pageYOffset","_document5","_document5$body","_document5$body$paren","_document6","handlers","DomContentLoaded","o","mousemoveCb","mouseInteractionCb","scrollCb","viewportResizeCb","inputCb","mediaInteractionCb","styleSheetRuleCb","canvasMutationCb","fontCb","logCb","p","mutation","mouseInteraction","scroll","viewportResize","input","mediaInteaction","styleSheetRule","canvasMutation","font","mergeHooks","mutationObserver","mousemoveHandler","threshold","timeBaseline","positions","wrappedCb","totalOffset","timeOffset","mousemoveCallback","updatePosition","evt","clientX","clientY","x","y","MouseEvent","MouseMove","DragEvent","Drag","TouchMove","h","initMoveObserver","mouseInteractionHandler","disableMap","Number","isNaN","endsWith","eventName","handler","getHandler","initMouseInteractionObserver","scrollHandler","scrollEl","scrollingElement","initScrollObserver","viewportResizeHandler","lastH","lastW","initViewportResizeObserver","inputHandler","eventHandler","isChecked","cbWithDedup","querySelectorAll","v","lastInputValue","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","initInputObserver","mediaInteractionHandler","initMediaInteractionObserver","styleSheetObserver","insertRule","CSSStyleSheet","ownerNode","deleteRule","initStyleSheetObserver","canvasMutationObserver","props","getOwnPropertyNames","CanvasRenderingContext2D","restoreHandler","canvas","recordArgs","HTMLCanvasElement","hookHandler","setter","initCanvasMutationObserver","fontObserver","fontMap","originalFontFace","FontFace","family","descriptors","fontFace","buffer","fontSource","Uint8Array","fonts","FonFace","initFontObserver","logObserver","logCount","cancelHandlers","includes","originalOnError","onerror","msg","file","col","trace","stackFrame","levelType","_logger","initLogObserver","disconnect","initObservers","MouseInteraction","Scroll","ViewportResize","Input","MediaInteraction","StyleSheetRule","CanvasMutation","Font","Log","Load","Worker","addCustomEvent","tag","Custom","freezePage","require","u8","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","b","j","fl","revfl","fd","revfd","rev","hMap","cd","mb","l","le","co","rvb","sv","flt","fdt","flm","fdm","shft","slc","subarray","wbits","wbits16","hTree","t","f","t2","et","sort","i0","i1","i2","maxSym","tr","mbt","ln","dt","lft","cst","Math","max","lc","cl","cli","cln","cls","w","clen","cf","wfblk","out","dat","wblk","final","syms","lf","df","li","bs","bl","dlt","mlb","ddt","mdb","lclt","nlc","lcdt","ndc","lcfreq","lct","mlcb","nlcc","flen","ftlen","dtlen","lm","ll","dm","dl","llm","lcts","it","clct","dst","deo","te","TextEncoder","td","TextDecoder","tds","decode","stream","pack","_e","latin1","String","fromCharCode","strFromU8","opts","min","adler","lvl","plvl","pre","post","lst","ceil","opt","msk","prev","bs1","bs2","hsh","wi","hv","imod","pimod","rem","ch","dif","maxn","maxd","ml","nl","mmd","md","ti","lin","din","dflt","mem","lv","zlh","wbytes","zlibSync","encode","ar","ai","charCodeAt","strToU8","ErrorTrace","globalErrorTrace","networkErrorTrace","promiseErrorTrace","iframeErrorTrace","eventsMatrix","[object Object]","instance","lineno","colno","errEventRoute","events","concat","fetch","IDLE","errLogRoute","preventDefault","reason","frames","ReportData","uri","fetchDomain","URGENT","method","keepalive","xhr","XMLHttpRequest","open","setRequestHeader","send","onload","sendBeacon","image","Image","isPerformanceSupported","getEntriesByType","mark","bytes2kb","bytes","pow","toFixed","roundByTwo","num","pushTask","callback","requestIdleCallback","recordingStorage","async","quota","usage","usageDetails","storage","estimate","res","effectiveType","saveData","recordClientNavigator","Promise","resolve","connection","downlink","rtt","times","sizes","fetchs","bandwidth","userAgent","recordTiming","responseEnd","responseStart","requestStart","fetchTime","fetchStart","workerTime","workerStart","networkTime","downloadTime","timeToFirstByte","headerSize","decodedBodySize","transferSize","dnsLookupTime","domainLookupStart","domainLookupEnd","tcpTime","connectStart","connectEnd","firstPaintTime","domParseTime","domComplete","domInteractive","domRenderTime","domContentLoadedEventEnd","domContentLoadedEventStart","onloadTime","loadEventEnd","loadEventStart","isLowEndDevice","deviceMemory","hardwareConcurrency","isLowEndExperience","getNavigatorInformation","serviceWorkerStatus","serviceWorker","controller","fcpScore","lcpScore","fidcore","clsScore","tbtScore","webVitalsScore","fp","fcp","lcp","lcpFinal","fid","fidVitals","clsFinal","tbt","tbt5S","tbt10S","tbtFinal","getVitalsScore","measureName","reportPerformance","eventProperties","visibilityState","metricName","navigatorInformation","vitalsScore","logData","metric","customProperties","logMetric","duration","bt","rt","beacon","css","img","other","total","xmlhttprequest","initLargestContentfulPaint","entries","lastEntry","renderTime","startTime","initElementTiming","entry","identifier","performanceEntry","initLongtask","initFirstInput","processingStart","disconnectPO","performanceObserverInstance","takeRecords","initResouceTiming","initiatorType","bodySize","initLayoutShift","hadRecentInput","asyncSubscripePO","eventType","Observer","PerformanceObserver","getEntries","buffered","disconnectPerformanceObserver","logRoute","getInstance","all","then"],"mappings":"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"}