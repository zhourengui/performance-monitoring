{"version":3,"file":"mini-pm.modern.js","sources":["../src/types/types.ts","../src/constants.ts","../src/utils/console.ts","../src/config/config.ts","../src/rrweb/snapshot/types.ts","../src/rrweb/snapshot/utils.ts","../src/rrweb/snapshot/snapshot.ts","../src/rrweb/types.ts","../src/rrweb/utils.ts","../src/rrweb/record/mutation.ts","../src/rrweb/record/stringify.ts","../src/rrweb/record/error-stack-parser.ts","../src/rrweb/record/observer.ts","../src/rrweb/record/iframe-manager.ts","../src/rrweb/record/shadow-dom-manager.ts","../src/rrweb/record/index.ts","../src/rrweb/packer/pack.ts","../src/rrweb/packer/base.ts","../src/error-trace/index.ts","../src/utils/ReportData.ts","../src/utils/helper.ts","../src/performance/record-storage.ts","../src/performance/record-client-navigator.ts","../src/performance/record-timing.ts","../src/utils/navigator-information.ts","../src/utils/vitals-score.ts","../src/utils/report-performance.ts","../src/utils/log.ts","../src/utils/metrics.ts","../src/performance/paint.ts","../src/performance/longtask.ts","../src/performance/first-input.ts","../src/performance/resource.ts","../src/performance/layout-shift.ts","../src/performance/performance-observer.ts","../src/index.ts"],"sourcesContent":["import { recordOptions } from \"../rrweb/types\";\n\nexport interface PerformanceMonitoringOptions {\n  isObserverResourceTiming?: boolean | undefined,\n  isObserverElementTiming?: boolean | undefined,\n  maxTime?: number | undefined,\n  captureError?: boolean | undefined,\n  reportData?: ReportDataAchieve | undefined,\n  fetchDomain?: string | undefined,\n  errLogRoute?: string | undefined,\n  errEventRoute?: string | undefined,\n  logRoute?: string | undefined,\n  analyticsTracker?: ((options: AnalyticsTrackerOptions) => void) | undefined,\n  recordOptions?: recordOptions<any> | undefined\n}\n\nexport interface StorageOpt {\n  quota?: number | undefined,\n  usage?: number | undefined,\n  usageDetails: { [key: string]: any }\n}\n\nexport interface TimingOpt {\n  // The time to initiate the network is from AppCache to ResponseEnd\n  // 发起网络的时间是从AppCache到ResponseEnd\n  fetchTime: number,\n  // Response time\n  // 响应时间\n  workerTime: number,\n  // Network request time\n  // 网络请求时间\n  networkTime: number,\n  // Server response time\n  // 服务器响应时间\n  downloadTime: number,\n  // The time when the browser received the first byte of the server\n  // 浏览器接收服务端的第一个字节的时间\n  timeToFirstByte: number,\n  // Request header size\n  // 请求头大小\n  headerSize: number,\n  // dns resolution time\n  // dns解析时间\n  dnsLookupTime: number,\n  // tcp connection time\n  // tcp连接时间\n  tcpTime: number,\n  // Blank screen time\n  // 白屏时间\n  firstPaintTime: number,\n  // dom rendering time\n  // dom渲染时间\n  domRenderTime: number,\n  // onload time\n  // onload时间\n  onloadTime: number,\n  // dom parsing time\n  // dom解析时间\n  domParseTime: number,\n}\n\nexport interface NavigatorOpt {\n  // 浏览器信息\n  // Browser information\n  userAgent: string,\n  // User's internet speed\n  // 用户的网速\n  connection: {\n    downlink?: number,\n    effectiveType?: EffectiveType,\n    rtt?: number,\n    saveData?: boolean,\n    [key: string]: unknown,\n    bandwidth?: string\n  }\n}\n\nexport interface ReportDataAchieve {\n  fetch: (label: AskLevel, body: string, uri: string) => void\n}\n\nexport interface PerformanceObservers {\n  [eventType: string]: PerformanceObserver | null;\n}\n\nexport enum AskLevel {\n  URGENT = 1,\n  IDLE = 2,\n}\n\nexport type PerformanceObserverEventType =\n  | \"paint\"\n  | \"longtask\"\n  | \"first-input\"\n  | \"largest-contentful-paint\"\n  | \"resource\"\n  | \"layout-shift\"\n  | \"element\"\n\nexport type VitalsScore = 'good' | 'needsImprovement' | 'poor' | null;\n\nexport interface AnalyticsTrackerOptions {\n  metricName: string;\n  data: TimingOpt | number | NavigatorOpt;\n  eventProperties: object | undefined;\n  navigatorInformation: unknown;\n  vitalsScore: VitalsScore;\n}\n\nexport interface NavigatorInformation {\n  deviceMemory?: number;\n  hardwareConcurrency?: number;\n  isLowEndDevice?: boolean;\n  isLowEndExperience?: boolean;\n  serviceWorkerStatus?: 'controlled' | 'supported' | 'unsupported';\n}\n\nexport type EffectiveType =\n  | '2g'\n  | '3g'\n  | '4g'\n  | '5g'\n  | 'slow-2g'\n  | 'lte';\n\nexport interface PerformanceEntryEncapsulation extends PerformanceEntry {\n  identifier: any;\n  value?: number | undefined;\n  hadRecentInput?: PerformanceEntryEncapsulation | undefined;\n  initiatorType?: string;\n  decodedBodySize?: number;\n  processingStart: DOMHighResTimeStamp;\n  target?: Node;\n  renderTime?: number\n}\n\nexport interface ResourceTime {\n  beacon: number;\n  css: number;\n  fetch: number;\n  img: number;\n  other: number;\n  script: number;\n  total: number;\n  xmlhttprequest: number;\n  [key: string]: number\n}","interface Navigator {\n  sendBeacon: any\n  connection?: any\n  storage: any\n  userAgent: string\n  deviceMemory: number;\n  hardwareConcurrency: number;\n  serviceWorker?: {\n    controller?: string;\n  };\n}\n\nexport const W = window\nexport const WP = W.performance\nexport const WN = W.navigator as any as Navigator\nexport const C = W.console\nexport const D = document","import { C } from \"../constants\"\n\nconst prefix = \"mini-pm🐢：\"\n\nexport const log = (message: any, ...options: any[]): void => C.log(prefix, message, ...options)\n\nexport const warn = (message: any, ...options: any[]) => C.warn(prefix, message, ...options)\n\nexport const error = (message: any, ...options: any[]) => C.error(prefix, message, ...options)","import type { AnalyticsTrackerOptions, PerformanceMonitoringOptions } from \"../types/types\";\nimport { log } from \"../utils/console\";\n\nexport const config: PerformanceMonitoringOptions = {\n  isObserverResourceTiming: false,\n  isObserverElementTiming: false,\n  maxTime: 15000,\n  captureError: true,\n  reportData: undefined,\n  analyticsTracker: (options: AnalyticsTrackerOptions) => {\n    log(options)\n  },\n  recordOptions: {},\n  fetchDomain: \"\",\n  errLogRoute: \"\",\n  errEventRoute: \"\",\n  logRoute: \"\"\n}","export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n\nexport type MaskTextFn = (text: string) => string;\n","import { INode } from './types';\n\nexport function isElement(n: Node | INode): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n  MaskTextFn,\n} from './types';\nimport { isElement, isShadowRoot } from './utils';\n\nlet _id = 1;\nconst tagNameRegex = RegExp('[^a-z0-9-_]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule)\n    ? getCssRulesString(rule.styleSheet) || ''\n    : rule.cssText;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin;\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    var chars,\n      match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  let output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        let c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n\nfunction getHref() {\n  // return a href without hash\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: string,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || ((name === 'href' || name === 'xlink:href') && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    value &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    // tslint:disable-next-line: prefer-for-of\n    for (let eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      const className = element.classList[eIndex];\n      if (blockClass.test(className)) {\n        return true;\n      }\n    }\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nexport function needMaskingText(\n  node: Node | null,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (typeof maskTextClass === 'string') {\n      if ((node as HTMLElement).classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (maskTextClass.test(className)) {\n          return true;\n        }\n      });\n    }\n    if (maskTextSelector) {\n      if ((node as HTMLElement).matches(maskTextSelector)) {\n        return true;\n      }\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    listener();\n    return;\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    recordCanvas: boolean;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    recordCanvas,\n  } = options;\n  // Only record root id when document object is not the base document\n  let rootId: number | undefined;\n  if (((doc as unknown) as INode).__sn) {\n    const docId = ((doc as unknown) as INode).__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      return {\n        type: NodeType.Document,\n        childNodes: [],\n        rootId,\n      };\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, tagName, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        const cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value =\n            maskInputOptions[attributes.type as keyof MaskInputOptions] ||\n            maskInputOptions[tagName as keyof MaskInputOptions]\n              ? '*'.repeat(value.length)\n              : value;\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        const selectValue = (n as HTMLOptionElement).parentElement;\n        if (attributes.value === (selectValue as HTMLSelectElement).value) {\n          attributes.selected = (n as HTMLOptionElement).selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL();\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      // block element\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      // iframe\n      if (tagName === 'iframe') {\n        delete attributes.src;\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n        rootId,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n      if (isStyle && textContent) {\n        textContent = absoluteToStylesheet(textContent, getHref());\n      }\n      if (isScript) {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      if (\n        !isStyle &&\n        !isScript &&\n        needMaskingText(n, maskTextClass, maskTextSelector) &&\n        textContent\n      ) {\n        textContent = maskTextFn\n          ? maskTextFn(textContent)\n          : textContent.replace(/[\\S]/g, '*');\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n        rootId,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      (sn.tagName === 'script' ||\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script'))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions?: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskTextFn,\n    slimDOMOptions,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    recordCanvas,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  if (onSerialize) {\n    onSerialize(n as INode);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      map,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      serializedNode.isShadowHost = true;\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            map,\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            slimDOMOptions,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(n as INode, serializedIframeNode);\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    slimDOM?: boolean | SlimDOMOptions;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    blockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskTextFn,\n    slimDOM = false,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      slimDOMOptions,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","import {\n  serializedNodeWithId,\n  idNodeMap,\n  INode,\n  MaskInputOptions,\n  SlimDOMOptions,\n} from './snapshot';\nimport { PackFn, UnpackFn } from './packer/base';\nimport { FontFaceDescriptors } from 'css-font-loading-module';\nimport { IframeManager } from './record/iframe-manager';\nimport { ShadowDomManager } from './record/shadow-dom-manager';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n  Custom,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport type logEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type customEvent<T = unknown> = {\n  type: EventType.Custom;\n  data: {\n    tag: string;\n    payload: T;\n  };\n};\n\nexport type styleSheetEvent = {};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n  TouchMove,\n  MediaInteraction,\n  StyleSheetRule,\n  CanvasMutation,\n  Font,\n  Log,\n  Drag,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source:\n  | IncrementalSource.MouseMove\n  | IncrementalSource.TouchMove\n  | IncrementalSource.Drag;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimension;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type mediaInteractionData = {\n  source: IncrementalSource.MediaInteraction;\n} & mediaInteractionParam;\n\nexport type styleSheetRuleData = {\n  source: IncrementalSource.StyleSheetRule;\n} & styleSheetRuleParam;\n\nexport type canvasMutationData = {\n  source: IncrementalSource.CanvasMutation;\n} & canvasMutationParam;\n\nexport type fontData = {\n  source: IncrementalSource.Font;\n} & fontParam;\n\nexport type logData = {\n  source: IncrementalSource.Log;\n} & LogParam;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData\n  | mediaInteractionData\n  | styleSheetRuleData\n  | canvasMutationData\n  | fontData\n  | logData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent\n  | logEvent\n  | customEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type blockClass = string | RegExp;\n\nexport type maskTextClass = string | RegExp;\n\nexport type SamplingStrategy = Partial<{\n  /**\n   * false means not to record mouse/touch move events\n   * number is the throttle threshold of recording mouse/touch move\n   */\n  mousemove: boolean | number;\n  /**\n   * number is the throttle threshold of mouse/touch move callback\n   */\n  mousemoveCallback: number;\n  /**\n   * false means not to record mouse interaction events\n   * can also specify record some kinds of mouse interactions\n   */\n  mouseInteraction: boolean | Record<string, boolean | undefined>;\n  /**\n   * number is the throttle threshold of recording scroll\n   */\n  scroll: number;\n  /**\n   * 'all' will record all the input events\n   * 'last' will only record the last input value while input a sequence of chars\n   */\n  input: 'all' | 'last';\n}>;\n\nexport type recordOptions<T> = {\n  emit?: (e: T, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n  blockClass?: blockClass;\n  blockSelector?: string;\n  ignoreClass?: string;\n  maskTextClass?: maskTextClass;\n  maskTextSelector?: string;\n  maskAllInputs?: boolean;\n  maskInputOptions?: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  slimDOMOptions?: SlimDOMOptions | 'all' | true;\n  inlineStylesheet?: boolean;\n  hooks?: hooksParam;\n  packFn?: PackFn;\n  sampling?: SamplingStrategy;\n  recordCanvas?: boolean;\n  collectFonts?: boolean;\n  // departed, please use sampling options\n  mousemoveWait?: number;\n  recordLog?: boolean | LogRecordOptions;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n  mediaInteractionCb: mediaInteractionCallback;\n  blockClass: blockClass;\n  blockSelector: string | null;\n  ignoreClass: string;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  maskInputOptions: MaskInputOptions;\n  maskInputFn?: MaskInputFn;\n  maskTextFn?: MaskTextFn;\n  inlineStylesheet: boolean;\n  styleSheetRuleCb: styleSheetRuleCallback;\n  canvasMutationCb: canvasMutationCallback;\n  fontCb: fontCallback;\n  logCb: logCallback;\n  logOptions: LogRecordOptions;\n  sampling: SamplingStrategy;\n  recordCanvas: boolean;\n  collectFonts: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  doc: Document;\n  mirror: Mirror;\n  iframeManager: IframeManager;\n  shadowDomManager: ShadowDomManager;\n};\n\nexport type hooksParam = {\n  mutation?: mutationCallBack;\n  mousemove?: mousemoveCallBack;\n  mouseInteraction?: mouseInteractionCallBack;\n  scroll?: scrollCallback;\n  viewportResize?: viewportResizeCallback;\n  input?: inputCallback;\n  mediaInteaction?: mediaInteractionCallback;\n  styleSheetRule?: styleSheetRuleCallback;\n  canvasMutation?: canvasMutationCallback;\n  font?: fontCallback;\n  log?: logCallback;\n};\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\nexport type mutationRecord = {\n  type: string;\n  target: Node;\n  oldValue: string | null;\n  addedNodes: NodeList;\n  removedNodes: NodeList;\n  attributeName: string | null;\n};\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n  isShadow?: boolean;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  // Newly recorded mutations will not have previousId any more, just for compatibility\n  previousId?: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\nexport type mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n  isAttachIframe?: true;\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (\n  p: mousePosition[],\n  source:\n    | IncrementalSource.MouseMove\n    | IncrementalSource.TouchMove\n    | IncrementalSource.Drag,\n) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove_Departed, // we will start a separate observer for touch move event\n  TouchEnd,\n}\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type styleSheetAddRule = {\n  rule: string;\n  index?: number;\n};\n\nexport type styleSheetDeleteRule = {\n  index: number;\n};\n\nexport type styleSheetRuleParam = {\n  id: number;\n  removes?: styleSheetDeleteRule[];\n  adds?: styleSheetAddRule[];\n};\n\nexport type styleSheetRuleCallback = (s: styleSheetRuleParam) => void;\n\nexport type canvasMutationCallback = (p: canvasMutationParam) => void;\n\nexport type canvasMutationParam = {\n  id: number;\n  property: string;\n  args: Array<unknown>;\n  setter?: true;\n};\n\nexport type fontParam = {\n  family: string;\n  fontSource: string;\n  buffer: boolean;\n  descriptors?: FontFaceDescriptors;\n};\n\nexport type LogLevel =\n  | 'assert'\n  | 'clear'\n  | 'count'\n  | 'countReset'\n  | 'debug'\n  | 'dir'\n  | 'dirxml'\n  | 'error'\n  | 'group'\n  | 'groupCollapsed'\n  | 'groupEnd'\n  | 'info'\n  | 'log'\n  | 'table'\n  | 'time'\n  | 'timeEnd'\n  | 'timeLog'\n  | 'trace'\n  | 'warn';\n\n/* fork from interface Console */\n// all kinds of console functions\nexport type Logger = {\n  assert?: typeof console.assert;\n  clear?: typeof console.clear;\n  count?: typeof console.count;\n  countReset?: typeof console.countReset;\n  debug?: typeof console.debug;\n  dir?: typeof console.dir;\n  dirxml?: typeof console.dirxml;\n  error?: typeof console.error;\n  group?: typeof console.group;\n  groupCollapsed?: typeof console.groupCollapsed;\n  groupEnd?: () => void;\n  info?: typeof console.info;\n  log?: typeof console.log;\n  table?: typeof console.table;\n  time?: typeof console.time;\n  timeEnd?: typeof console.timeEnd;\n  timeLog?: typeof console.timeLog;\n  trace?: typeof console.trace;\n  warn?: typeof console.warn;\n};\n\n/**\n * define an interface to replay log records\n * (data: logData) => void> function to display the log data\n */\nexport type ReplayLogger = Partial<Record<LogLevel, (data: logData) => void>>;\n\nexport type LogParam = {\n  level: LogLevel;\n  trace: string[];\n  payload: string[];\n};\n\nexport type fontCallback = (p: fontParam) => void;\n\nexport type logCallback = (p: LogParam) => void;\n\nexport type viewportResizeDimension = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimension) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport const enum MediaInteractions {\n  Play,\n  Pause,\n}\n\nexport type mediaInteractionParam = {\n  type: MediaInteractions;\n  id: number;\n};\n\nexport type mediaInteractionCallback = (p: mediaInteractionParam) => void;\n\nexport type DocumentDimension = {\n  x: number;\n  y: number;\n  // scale value relative to its parent iframe\n  relativeScale: number;\n  // scale value relative to the root iframe\n  absoluteScale: number;\n};\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n  reset: () => void;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type playerConfig = {\n  speed: number;\n  maxSpeed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: boolean;\n  showWarning: boolean;\n  showDebug: boolean;\n  blockClass: string;\n  liveMode: boolean;\n  insertStyleRules: string[];\n  triggerFocus: boolean;\n  UNSAFE_replayCanvas: boolean;\n  pauseAnimation?: boolean;\n  mouseTail:\n  | boolean\n  | {\n    duration?: number;\n    lineCap?: string;\n    lineWidth?: number;\n    strokeStyle?: string;\n  };\n  unpackFn?: UnpackFn;\n  logConfig: LogReplayConfig;\n};\n\nexport type LogReplayConfig = {\n  level?: LogLevel[] | undefined;\n  replayLogger: ReplayLogger | undefined;\n};\n\nexport type playerMetaData = {\n  startTime: number;\n  endTime: number;\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport type Handler = (event?: unknown) => void;\n\nexport type Emitter = {\n  on(type: string, handler: Handler): void;\n  emit(type: string, event?: unknown): void;\n  off(type: string, handler: Handler): void;\n};\n\nexport type Arguments<T> = T extends (...payload: infer U) => unknown\n  ? U\n  : unknown;\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n  MouseInteraction = 'mouse-interaction',\n  EventCast = 'event-cast',\n  CustomEvent = 'custom-event',\n  Flush = 'flush',\n  StateChange = 'state-change',\n  PlayBack = 'play-back',\n}\n\nexport type MaskInputFn = (text: string) => string;\n\nexport type MaskTextFn = (text: string) => string;\n\n// store the state that would be changed during the process(unmount from dom and mount again)\nexport type ElementState = {\n  // [scrollLeft,scrollTop]\n  scroll?: [number, number];\n};\n\nexport type StringifyOptions = {\n  // limit of string length\n  stringLengthLimit?: number;\n  /**\n   * limit of number of keys in an object\n   * if an object contains more keys than this limit, we would call its toString function directly\n   */\n  numOfKeysLimit: number;\n};\n\nexport type LogRecordOptions = {\n  level?: LogLevel[] | undefined;\n  lengthThreshold?: number;\n  stringifyOptions?: StringifyOptions;\n  logger?: Logger;\n};\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n  blockClass,\n  eventWithTime,\n  EventType,\n  IncrementalSource,\n  addedNodeMutation,\n  removedNodeMutation,\n  textMutation,\n  attributeMutation,\n  mutationData,\n  scrollData,\n  inputData,\n  DocumentDimension,\n} from './types';\nimport {\n  INode,\n  IGNORED_NODE,\n  serializedNodeWithId,\n  NodeType,\n  isShadowRoot,\n} from './snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | Window = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport function createMirror(): Mirror {\n  return {\n    map: {},\n    getId(n) {\n      // if n is not a serialized INode, use -1 as its id.\n      if (!n.__sn) {\n        return -1;\n      }\n      return n.__sn.id;\n    },\n    getNode(id) {\n      return this.map[id] || null;\n    },\n    // TODO: use a weakmap to get rid of manually memory management\n    removeNodeFromMap(n) {\n      const id = n.__sn && n.__sn.id;\n      delete this.map[id];\n      if (n.childNodes) {\n        n.childNodes.forEach((child) =>\n          this.removeNodeFromMap((child as Node) as INode),\n        );\n      }\n    },\n    has(id) {\n      return this.map.hasOwnProperty(id);\n    },\n    reset() {\n      this.map = {};\n    },\n  };\n}\n\n// https://github.com/rrweb-io/rrweb/pull/407\nconst DEPARTED_MIRROR_ACCESS_WARNING =\n  'Please stop import mirror directly. Instead of that,' +\n  '\\r\\n' +\n  'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\n  '\\r\\n' +\n  'or you can use record.mirror to access the mirror instance during recording.';\nexport let _mirror: Mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n};\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === 'map') {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: number | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function (arg: T) {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait - (now - previous);\n    let context = this;\n    let args = arguments as any;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        window.clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = window.setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n  isRevoked?: boolean,\n  win = window,\n): hookResetter {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked\n      ? d\n      : {\n        set(value) {\n          // put hooked setter into event loop to avoid of set latency\n          setTimeout(() => {\n            d.set!.call(this, value);\n          }, 0);\n          if (original && original.set) {\n            original.set.call(this, value);\n          }\n        },\n      },\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\n\n// copy from https://github.com/getsentry/sentry-javascript/blob/b2109071975af8bf0316d3b5b38f519bdaf5dc15/packages/utils/src/object.ts\nexport function patch(\n  // tslint:disable-next-line:no-any\n  source: { [key: string]: any },\n  name: string,\n  // tslint:disable-next-line:no-any\n  replacement: (...args: any[]) => any,\n): () => void {\n  try {\n    if (!(name in source)) {\n      return () => { };\n    }\n\n    const original = source[name] as () => unknown;\n    const wrapped = replacement(original);\n\n    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n    // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    }\n\n    source[name] = wrapped;\n\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => { };\n    // This can throw if multiple fill happens on a global object like XMLHttpRequest\n    // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n  }\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nexport function isBlocked(node: Node | null, blockClass: blockClass): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    let needBlock = false;\n    if (typeof blockClass === 'string') {\n      needBlock = (node as HTMLElement).classList.contains(blockClass);\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (blockClass.test(className)) {\n          needBlock = true;\n        }\n      });\n    }\n    return needBlock || isBlocked(node.parentNode, blockClass);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return isBlocked(node.parentNode, blockClass);\n  }\n  return isBlocked(node.parentNode, blockClass);\n}\n\nexport function isIgnored(n: Node | INode): boolean {\n  if ('__sn' in n) {\n    return (n as INode).__sn.id === IGNORED_NODE;\n  }\n  // The main part of the slimDOM check happens in\n  // rrweb-snapshot::serializeNodeWithId\n  return false;\n}\n\nexport function isAncestorRemoved(target: INode, mirror: Mirror): boolean {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode, mirror);\n}\n\nexport function isTouchEvent(\n  event: MouseEvent | TouchEvent,\n): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches);\n}\n\nexport function polyfill(win = window) {\n  if ('NodeList' in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as NodeList['forEach'];\n  }\n\n  if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as DOMTokenList['forEach'];\n  }\n\n  // https://github.com/Financial-Times/polyfill-service/pull/183\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = function contains(node) {\n      if (!(0 in arguments)) {\n        throw new TypeError('1 argument is required');\n      }\n\n      do {\n        if (this === node) {\n          return true;\n        }\n        // tslint:disable-next-line: no-conditional-assignment\n      } while ((node = node && node.parentNode));\n\n      return false;\n    };\n  }\n}\n\nexport function needCastInSyncMode(event: eventWithTime): boolean {\n  switch (event.type) {\n    case EventType.DomContentLoaded:\n    case EventType.Load:\n    case EventType.Custom:\n      return false;\n    case EventType.FullSnapshot:\n    case EventType.Meta:\n      return true;\n    default:\n      break;\n  }\n\n  switch (event.data.source) {\n    case IncrementalSource.MouseMove:\n    case IncrementalSource.MouseInteraction:\n    case IncrementalSource.TouchMove:\n    case IncrementalSource.MediaInteraction:\n      return false;\n    case IncrementalSource.ViewportResize:\n    case IncrementalSource.StyleSheetRule:\n    case IncrementalSource.Scroll:\n    case IncrementalSource.Input:\n      return true;\n    default:\n      break;\n  }\n\n  return true;\n}\n\nexport type TreeNode = {\n  id: number;\n  mutation: addedNodeMutation;\n  parent?: TreeNode;\n  children: Record<number, TreeNode>;\n  texts: textMutation[];\n  attributes: attributeMutation[];\n};\nexport class TreeIndex {\n  public tree!: Record<number, TreeNode>;\n\n  private removeNodeMutations!: removedNodeMutation[];\n  private textMutations!: textMutation[];\n  private attributeMutations!: attributeMutation[];\n  private indexes!: Map<number, TreeNode>;\n  private removeIdSet!: Set<number>;\n  private scrollMap!: Map<number, scrollData>;\n  private inputMap!: Map<number, inputData>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public add(mutation: addedNodeMutation) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode: TreeNode = {\n      id: mutation.node.id,\n      mutation,\n      children: [],\n      texts: [],\n      attributes: [],\n    };\n    if (!parentTreeNode) {\n      this.tree[treeNode.id] = treeNode;\n    } else {\n      treeNode.parent = parentTreeNode;\n      parentTreeNode.children[treeNode.id] = treeNode;\n    }\n    this.indexes.set(treeNode.id, treeNode);\n  }\n\n  public remove(mutation: removedNodeMutation, mirror: Mirror) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode = this.indexes.get(mutation.id);\n\n    const deepRemoveFromMirror = (id: number) => {\n      this.removeIdSet.add(id);\n      const node = mirror.getNode(id);\n      node?.childNodes.forEach((childNode) => {\n        if ('__sn' in childNode) {\n          deepRemoveFromMirror(((childNode as unknown) as INode).__sn.id);\n        }\n      });\n    };\n    const deepRemoveFromTreeIndex = (node: TreeNode) => {\n      this.removeIdSet.add(node.id);\n      Object.values(node.children).forEach((n) => deepRemoveFromTreeIndex(n));\n      const _treeNode = this.indexes.get(node.id);\n      if (_treeNode) {\n        const _parentTreeNode = _treeNode.parent;\n        if (_parentTreeNode) {\n          delete _treeNode.parent;\n          delete _parentTreeNode.children[_treeNode.id];\n          this.indexes.delete(mutation.id);\n        }\n      }\n    };\n\n    if (!treeNode) {\n      this.removeNodeMutations.push(mutation);\n      deepRemoveFromMirror(mutation.id);\n    } else if (!parentTreeNode) {\n      delete this.tree[treeNode.id];\n      this.indexes.delete(treeNode.id);\n      deepRemoveFromTreeIndex(treeNode);\n    } else {\n      delete treeNode.parent;\n      delete parentTreeNode.children[treeNode.id];\n      this.indexes.delete(mutation.id);\n      deepRemoveFromTreeIndex(treeNode);\n    }\n  }\n\n  public text(mutation: textMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.texts.push(mutation);\n    } else {\n      this.textMutations.push(mutation);\n    }\n  }\n\n  public attribute(mutation: attributeMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.attributes.push(mutation);\n    } else {\n      this.attributeMutations.push(mutation);\n    }\n  }\n\n  public scroll(d: scrollData) {\n    this.scrollMap.set(d.id, d);\n  }\n\n  public input(d: inputData) {\n    this.inputMap.set(d.id, d);\n  }\n\n  public flush(): {\n    mutationData: mutationData;\n    scrollMap: TreeIndex['scrollMap'];\n    inputMap: TreeIndex['inputMap'];\n  } {\n    const {\n      tree,\n      removeNodeMutations,\n      textMutations,\n      attributeMutations,\n    } = this;\n\n    const batchMutationData: mutationData = {\n      source: IncrementalSource.Mutation,\n      removes: removeNodeMutations,\n      texts: textMutations,\n      attributes: attributeMutations,\n      adds: [],\n    };\n\n    const walk = (treeNode: TreeNode, removed: boolean) => {\n      if (removed) {\n        this.removeIdSet.add(treeNode.id);\n      }\n      batchMutationData.texts = batchMutationData.texts\n        .concat(removed ? [] : treeNode.texts)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      batchMutationData.attributes = batchMutationData.attributes\n        .concat(removed ? [] : treeNode.attributes)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      if (\n        !this.removeIdSet.has(treeNode.id) &&\n        !this.removeIdSet.has(treeNode.mutation.parentId) &&\n        !removed\n      ) {\n        batchMutationData.adds.push(treeNode.mutation);\n        if (treeNode.children) {\n          Object.values(treeNode.children).forEach((n) => walk(n, false));\n        }\n      } else {\n        Object.values(treeNode.children).forEach((n) => walk(n, true));\n      }\n    };\n\n    Object.values(tree).forEach((n) => walk(n, false));\n\n    for (const id of this.scrollMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.scrollMap.delete(id);\n      }\n    }\n    for (const id of this.inputMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.inputMap.delete(id);\n      }\n    }\n\n    const scrollMap = new Map(this.scrollMap);\n    const inputMap = new Map(this.inputMap);\n\n    this.reset();\n\n    return {\n      mutationData: batchMutationData,\n      scrollMap,\n      inputMap,\n    };\n  }\n\n  private reset() {\n    this.tree = [];\n    this.indexes = new Map();\n    this.removeNodeMutations = [];\n    this.textMutations = [];\n    this.attributeMutations = [];\n    this.removeIdSet = new Set();\n    this.scrollMap = new Map();\n    this.inputMap = new Map();\n  }\n}\n\ntype ResolveTree = {\n  value: addedNodeMutation;\n  children: ResolveTree[];\n  parent: ResolveTree | null;\n};\n\nexport function queueToResolveTrees(queue: addedNodeMutation[]): ResolveTree[] {\n  const queueNodeMap: Record<number, ResolveTree> = {};\n  const putIntoMap = (\n    m: addedNodeMutation,\n    parent: ResolveTree | null,\n  ): ResolveTree => {\n    const nodeInTree: ResolveTree = {\n      value: m,\n      parent,\n      children: [],\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n\n  const queueNodeTrees: ResolveTree[] = [];\n  for (const mutation of queue) {\n    const { nextId, parentId } = mutation;\n    if (nextId && nextId in queueNodeMap) {\n      const nextInTree = queueNodeMap[nextId];\n      if (nextInTree.parent) {\n        const idx = nextInTree.parent.children.indexOf(nextInTree);\n        nextInTree.parent.children.splice(\n          idx,\n          0,\n          putIntoMap(mutation, nextInTree.parent),\n        );\n      } else {\n        const idx = queueNodeTrees.indexOf(nextInTree);\n        queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n      }\n      continue;\n    }\n    if (parentId in queueNodeMap) {\n      const parentInTree = queueNodeMap[parentId];\n      parentInTree.children.push(putIntoMap(mutation, parentInTree));\n      continue;\n    }\n    queueNodeTrees.push(putIntoMap(mutation, null));\n  }\n\n  return queueNodeTrees;\n}\n\nexport function iterateResolveTree(\n  tree: ResolveTree,\n  cb: (mutation: addedNodeMutation) => unknown,\n) {\n  cb(tree.value);\n  /**\n   * The resolve tree was designed to reflect the DOM layout,\n   * but we need append next sibling first, so we do a reverse\n   * loop here.\n   */\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    iterateResolveTree(tree.children[i], cb);\n  }\n}\n\ntype HTMLIFrameINode = HTMLIFrameElement & {\n  __sn: serializedNodeWithId;\n};\nexport type AppendedIframe = {\n  mutationInQueue: addedNodeMutation;\n  builtNode: HTMLIFrameINode;\n};\n\nexport function isIframeINode(\n  node: INode | ShadowRoot,\n): node is HTMLIFrameINode {\n  if ('__sn' in node) {\n    return (\n      node.__sn.type === NodeType.Element && node.__sn.tagName === 'iframe'\n    );\n  }\n  // node can be document fragment when using the virtual parent feature\n  return false;\n}\n\nexport function getBaseDimension(\n  node: Node,\n  rootIframe: Node,\n): DocumentDimension {\n  const frameElement = node.ownerDocument?.defaultView?.frameElement;\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1,\n    };\n  }\n\n  const frameDimension = frameElement.getBoundingClientRect();\n  const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  // the iframe element may have a scale transform\n  const relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x:\n      frameDimension.x * frameBaseDimension.relativeScale +\n      frameBaseDimension.x,\n    y:\n      frameDimension.y * frameBaseDimension.relativeScale +\n      frameBaseDimension.y,\n    relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale,\n  };\n}\n\nexport function hasShadowRoot<T extends Node>(\n  n: T,\n): n is T & { shadowRoot: ShadowRoot } {\n  return Boolean(((n as unknown) as Element)?.shadowRoot);\n}\n","// @ts-nocheck\nimport {\n  INode,\n  serializeNodeWithId,\n  transformAttribute,\n  MaskInputOptions,\n  SlimDOMOptions,\n  IGNORED_NODE,\n  isShadowRoot,\n  needMaskingText,\n} from '../snapshot';\nimport {\n  mutationRecord,\n  blockClass,\n  maskTextClass,\n  mutationCallBack,\n  textCursor,\n  attributeCursor,\n  removedNodeMutation,\n  addedNodeMutation,\n  MaskTextFn,\n  Mirror,\n} from '../types';\nimport {\n  isBlocked,\n  isAncestorRemoved,\n  isIgnored,\n  isIframeINode,\n  hasShadowRoot,\n} from '../utils';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\n\ntype DoubleLinkedListNode = {\n  previous: DoubleLinkedListNode | null;\n  next: DoubleLinkedListNode | null;\n  value: NodeInLinkedList;\n};\ntype NodeInLinkedList = Node & {\n  __ln: DoubleLinkedListNode;\n};\n\nfunction isNodeInLinkedList(n: Node | NodeInLinkedList): n is NodeInLinkedList {\n  return '__ln' in n;\n}\nclass DoubleLinkedList {\n  public length = 0;\n  public head: DoubleLinkedListNode | null = null;\n\n  public get(position: number) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n\n  public addNode(n: Node) {\n    const node: DoubleLinkedListNode = {\n      value: n as NodeInLinkedList,\n      previous: null,\n      next: null,\n    };\n    (n as NodeInLinkedList).__ln = node;\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      const current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (\n      n.nextSibling &&\n      isNodeInLinkedList(n.nextSibling) &&\n      n.nextSibling.__ln.previous\n    ) {\n      const current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    this.length++;\n  }\n\n  public removeNode(n: NodeInLinkedList) {\n    const current = n.__ln;\n    if (!this.head) {\n      return;\n    }\n\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      }\n    }\n    if (n.__ln) {\n      delete n.__ln;\n    }\n    this.length--;\n  }\n}\n\nconst moveKey = (id: number, parentId: number) => `${id}@${parentId}`;\nfunction isINode(n: Node | INode): n is INode {\n  return '__sn' in n;\n}\n\n/**\n * controls behaviour of a MutationObserver\n */\nexport default class MutationBuffer {\n  private frozen: boolean = false;\n  private locked: boolean = false;\n\n  private texts: textCursor[] = [];\n  private attributes: attributeCursor[] = [];\n  private removes: removedNodeMutation[] = [];\n  private mapRemoves: Node[] = [];\n\n  private movedMap: Record<string, true> = {};\n\n  /**\n   * the browser MutationObserver emits multiple mutations after\n   * a delay for performance reasons, making tracing added nodes hard\n   * in our `processMutations` callback function.\n   * For example, if we append an element el_1 into body, and then append\n   * another element el_2 into el_1, these two mutations may be passed to the\n   * callback function together when the two operations were done.\n   * Generally we need to trace child nodes of newly added nodes, but in this\n   * case if we count el_2 as el_1's child node in the first mutation record,\n   * then we will count el_2 again in the second mutation record which was\n   * duplicated.\n   * To avoid of duplicate counting added nodes, we use a Set to store\n   * added nodes and its child nodes during iterate mutation records. Then\n   * collect added nodes from the Set which have no duplicate copy. But\n   * this also causes newly added nodes will not be serialized with id ASAP,\n   * which means all the id related calculation should be lazy too.\n   */\n  private addedSet = new Set<Node>();\n  private movedSet = new Set<Node>();\n  private droppedSet = new Set<Node>();\n\n  private emissionCallback: mutationCallBack;\n  private blockClass: blockClass;\n  private blockSelector: string | null;\n  private maskTextClass: maskTextClass;\n  private maskTextSelector: string | null;\n  private inlineStylesheet: boolean;\n  private maskInputOptions: MaskInputOptions;\n  private maskTextFn: MaskTextFn | undefined;\n  private recordCanvas: boolean;\n  private slimDOMOptions: SlimDOMOptions;\n  private doc: Document;\n\n  private mirror: Mirror;\n  private iframeManager: IframeManager;\n  private shadowDomManager: ShadowDomManager;\n\n  public init(\n    cb: mutationCallBack,\n    blockClass: blockClass,\n    blockSelector: string | null,\n    maskTextClass: maskTextClass,\n    maskTextSelector: string | null,\n    inlineStylesheet: boolean,\n    maskInputOptions: MaskInputOptions,\n    maskTextFn: MaskTextFn | undefined,\n    recordCanvas: boolean,\n    slimDOMOptions: SlimDOMOptions,\n    doc: Document,\n    mirror: Mirror,\n    iframeManager: IframeManager,\n    shadowDomManager: ShadowDomManager,\n  ) {\n    this.blockClass = blockClass;\n    this.blockSelector = blockSelector;\n    this.maskTextClass = maskTextClass;\n    this.maskTextSelector = maskTextSelector;\n    this.inlineStylesheet = inlineStylesheet;\n    this.maskInputOptions = maskInputOptions;\n    this.maskTextFn = maskTextFn;\n    this.recordCanvas = recordCanvas;\n    this.slimDOMOptions = slimDOMOptions;\n    this.emissionCallback = cb;\n    this.doc = doc;\n    this.mirror = mirror;\n    this.iframeManager = iframeManager;\n    this.shadowDomManager = shadowDomManager;\n  }\n\n  public freeze() {\n    this.frozen = true;\n  }\n\n  public unfreeze() {\n    this.frozen = false;\n    this.emit();\n  }\n\n  public isFrozen() {\n    return this.frozen;\n  }\n\n  public lock() {\n    this.locked = true;\n  }\n\n  public unlock() {\n    this.locked = false;\n    this.emit();\n  }\n\n  public processMutations = (mutations: mutationRecord[]) => {\n    mutations.forEach(this.processMutation);\n    this.emit();\n  };\n\n  public emit = () => {\n    if (this.frozen || this.locked) {\n      return;\n    }\n\n    // delay any modification of the mirror until this function\n    // so that the mirror for takeFullSnapshot doesn't get mutated while it's event is being processed\n\n    const adds: addedNodeMutation[] = [];\n\n    /**\n     * Sometimes child node may be pushed before its newly added\n     * parent, so we init a queue to store these nodes.\n     */\n    const addList = new DoubleLinkedList();\n    const getNextId = (n: Node): number | null => {\n      let ns: Node | null = n;\n      let nextId: number | null = IGNORED_NODE; // slimDOM: ignored\n      while (nextId === IGNORED_NODE) {\n        ns = ns && ns.nextSibling;\n        nextId = ns && this.mirror.getId((ns as unknown) as INode);\n      }\n      if (nextId === -1 && isBlocked(n.nextSibling, this.blockClass)) {\n        nextId = null;\n      }\n      return nextId;\n    };\n    const pushAdd = (n: Node) => {\n      const shadowHost: Element | null = n.getRootNode\n        ? (n.getRootNode() as ShadowRoot)?.host\n        : null;\n      const notInDoc = !this.doc.contains(n) && !this.doc.contains(shadowHost);\n      if (!n.parentNode || notInDoc) {\n        return;\n      }\n      const parentId = isShadowRoot(n.parentNode)\n        ? this.mirror.getId((shadowHost as unknown) as INode)\n        : this.mirror.getId((n.parentNode as Node) as INode);\n      const nextId = getNextId(n);\n      if (parentId === -1 || nextId === -1) {\n        return addList.addNode(n);\n      }\n      let sn = serializeNodeWithId(n, {\n        doc: this.doc,\n        map: this.mirror.map,\n        blockClass: this.blockClass,\n        blockSelector: this.blockSelector,\n        maskTextClass: this.maskTextClass,\n        maskTextSelector: this.maskTextSelector,\n        skipChild: true,\n        inlineStylesheet: this.inlineStylesheet,\n        maskInputOptions: this.maskInputOptions,\n        maskTextFn: this.maskTextFn,\n        slimDOMOptions: this.slimDOMOptions,\n        recordCanvas: this.recordCanvas,\n        onSerialize: (currentN) => {\n          if (isIframeINode(currentN)) {\n            this.iframeManager.addIframe(currentN);\n          }\n          if (hasShadowRoot(n)) {\n            this.shadowDomManager.addShadowRoot(n.shadowRoot, document);\n          }\n        },\n        onIframeLoad: (iframe, childSn) => {\n          this.iframeManager.attachIframe(iframe, childSn);\n        },\n      });\n      if (sn) {\n        adds.push({\n          parentId,\n          nextId,\n          node: sn,\n        });\n      }\n    };\n\n    while (this.mapRemoves.length) {\n      this.mirror.removeNodeFromMap(this.mapRemoves.shift() as INode);\n    }\n\n    for (const n of this.movedSet) {\n      if (\n        isParentRemoved(this.removes, n, this.mirror) &&\n        !this.movedSet.has(n.parentNode!)\n      ) {\n        continue;\n      }\n      pushAdd(n);\n    }\n\n    for (const n of this.addedSet) {\n      if (\n        !isAncestorInSet(this.droppedSet, n) &&\n        !isParentRemoved(this.removes, n, this.mirror)\n      ) {\n        pushAdd(n);\n      } else if (isAncestorInSet(this.movedSet, n)) {\n        pushAdd(n);\n      } else {\n        this.droppedSet.add(n);\n      }\n    }\n\n    let candidate: DoubleLinkedListNode | null = null;\n    while (addList.length) {\n      let node: DoubleLinkedListNode | null = null;\n      if (candidate) {\n        const parentId = this.mirror.getId(\n          (candidate.value.parentNode as Node) as INode,\n        );\n        const nextId = getNextId(candidate.value);\n        if (parentId !== -1 && nextId !== -1) {\n          node = candidate;\n        }\n      }\n      if (!node) {\n        for (let index = addList.length - 1; index >= 0; index--) {\n          const _node = addList.get(index)!;\n          const parentId = this.mirror.getId(\n            (_node.value.parentNode as Node) as INode,\n          );\n          const nextId = getNextId(_node.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = _node;\n            break;\n          }\n        }\n      }\n      if (!node) {\n        /**\n         * If all nodes in queue could not find a serialized parent,\n         * it may be a bug or corner case. We need to escape the\n         * dead while loop at once.\n         */\n        while (addList.head) {\n          addList.removeNode(addList.head.value);\n        }\n        break;\n      }\n      candidate = node.previous;\n      addList.removeNode(node.value);\n      pushAdd(node.value);\n    }\n\n    const payload = {\n      texts: this.texts\n        .map((text) => ({\n          id: this.mirror.getId(text.node as INode),\n          value: text.value,\n        }))\n        // text mutation's id was not in the mirror map means the target node has been removed\n        .filter((text) => this.mirror.has(text.id)),\n      attributes: this.attributes\n        .map((attribute) => ({\n          id: this.mirror.getId(attribute.node as INode),\n          attributes: attribute.attributes,\n        }))\n        // attribute mutation's id was not in the mirror map means the target node has been removed\n        .filter((attribute) => this.mirror.has(attribute.id)),\n      removes: this.removes,\n      adds,\n    };\n    // payload may be empty if the mutations happened in some blocked elements\n    if (\n      !payload.texts.length &&\n      !payload.attributes.length &&\n      !payload.removes.length &&\n      !payload.adds.length\n    ) {\n      return;\n    }\n\n    // reset\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.addedSet = new Set<Node>();\n    this.movedSet = new Set<Node>();\n    this.droppedSet = new Set<Node>();\n    this.movedMap = {};\n\n    this.emissionCallback(payload);\n  };\n\n  private processMutation = (m: mutationRecord) => {\n    // console.log({ m });\n    if (isIgnored(m.target)) {\n      return;\n    }\n    switch (m.type) {\n      case 'characterData': {\n        const value = m.target.textContent;\n        if (!isBlocked(m.target, this.blockClass) && value !== m.oldValue) {\n          this.texts.push({\n            value:\n              needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n              ) && value\n                ? this.maskTextFn\n                  ? this.maskTextFn(value)\n                  : value.replace(/[\\S]/g, '*')\n                : value,\n            node: m.target,\n          });\n        }\n        break;\n      }\n      case 'attributes': {\n        const value = (m.target as HTMLElement).getAttribute(m.attributeName!);\n        if (isBlocked(m.target, this.blockClass) || value === m.oldValue) {\n          return;\n        }\n        let item: attributeCursor | undefined = this.attributes.find(\n          (a) => a.node === m.target,\n        );\n        if (!item) {\n          item = {\n            node: m.target,\n            attributes: {},\n          };\n          this.attributes.push(item);\n        }\n        // overwrite attribute if the mutations was triggered in same time\n        item.attributes[m.attributeName!] = transformAttribute(\n          this.doc,\n          (m.target as HTMLElement).tagName,\n          m.attributeName!,\n          value!,\n        );\n        break;\n      }\n      case 'childList': {\n        m.addedNodes.forEach((n) => this.genAdds(n, m.target));\n        m.removedNodes.forEach((n) => {\n          const nodeId = this.mirror.getId(n as INode);\n          const parentId = isShadowRoot(m.target)\n            ? this.mirror.getId((m.target.host as unknown) as INode)\n            : this.mirror.getId(m.target as INode);\n          if (\n            isBlocked(n, this.blockClass) ||\n            isBlocked(m.target, this.blockClass) ||\n            isIgnored(n)\n          ) {\n            return;\n          }\n          // removed node has not been serialized yet, just remove it from the Set\n          if (this.addedSet.has(n)) {\n            deepDelete(this.addedSet, n);\n            this.droppedSet.add(n);\n          } else if (this.addedSet.has(m.target) && nodeId === -1) {\n            /**\n             * If target was newly added and removed child node was\n             * not serialized, it means the child node has been removed\n             * before callback fired, so we can ignore it because\n             * newly added node will be serialized without child nodes.\n             * TODO: verify this\n             */\n          } else if (isAncestorRemoved(m.target as INode, this.mirror)) {\n            /**\n             * If parent id was not in the mirror map any more, it\n             * means the parent node has already been removed. So\n             * the node is also removed which we do not need to track\n             * and replay.\n             */\n          } else if (\n            this.movedSet.has(n) &&\n            this.movedMap[moveKey(nodeId, parentId)]\n          ) {\n            deepDelete(this.movedSet, n);\n          } else {\n            this.removes.push({\n              parentId,\n              id: nodeId,\n              isShadow: isShadowRoot(m.target) ? true : undefined,\n            });\n          }\n          this.mapRemoves.push(n);\n        });\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  private genAdds = (n: Node | INode, target?: Node | INode) => {\n    if (isBlocked(n, this.blockClass)) {\n      return;\n    }\n    if (target && isBlocked(target, this.blockClass)) {\n      return;\n    }\n    if (isINode(n)) {\n      if (isIgnored(n)) {\n        return;\n      }\n      this.movedSet.add(n);\n      let targetId: number | null = null;\n      if (target && isINode(target)) {\n        targetId = target.__sn.id;\n      }\n      if (targetId) {\n        this.movedMap[moveKey(n.__sn.id, targetId)] = true;\n      }\n    } else {\n      this.addedSet.add(n);\n      this.droppedSet.delete(n);\n    }\n    n.childNodes.forEach((childN) => this.genAdds(childN));\n  };\n}\n\n/**\n * Some utils to handle the mutation observer DOM records.\n * It should be more clear to extend the native data structure\n * like Set and Map, but currently Typescript does not support\n * that.\n */\nfunction deepDelete(addsSet: Set<Node>, n: Node) {\n  addsSet.delete(n);\n  n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\n\nfunction isParentRemoved(\n  removes: removedNodeMutation[],\n  n: Node,\n  mirror: Mirror,\n): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId((parentNode as Node) as INode);\n  if (removes.some((r) => r.id === parentId)) {\n    return true;\n  }\n  return isParentRemoved(removes, parentNode, mirror);\n}\n\nfunction isAncestorInSet(set: Set<Node>, n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return isAncestorInSet(set, parentNode);\n}\n","// tslint:disable:no-any no-bitwise forin\n/**\n * this file is used to serialize log message to string\n *\n */\n\nimport { StringifyOptions } from '../types';\n\n/**\n * transfer the node path in Event to string\n * @param node the first node in a node path array\n */\nfunction pathToSelector(node: HTMLElement): string | '' {\n  if (!node || !node.outerHTML) {\n    return '';\n  }\n\n  let path = '';\n  while (node.parentElement) {\n    let name = node.localName;\n    if (!name) {\n      break;\n    }\n    name = name.toLowerCase();\n    let parent = node.parentElement;\n\n    let domSiblings = [];\n\n    if (parent.children && parent.children.length > 0) {\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < parent.children.length; i++) {\n        let sibling = parent.children[i];\n        if (sibling.localName && sibling.localName.toLowerCase) {\n          if (sibling.localName.toLowerCase() === name) {\n            domSiblings.push(sibling);\n          }\n        }\n      }\n    }\n\n    if (domSiblings.length > 1) {\n      name += ':eq(' + domSiblings.indexOf(node) + ')';\n    }\n    path = name + (path ? '>' + path : '');\n    node = parent;\n  }\n\n  return path;\n}\n\n/**\n * stringify any js object\n * @param obj the object to stringify\n */\nexport function stringify(\n  obj: any,\n  stringifyOptions?: StringifyOptions,\n): string {\n  const options: StringifyOptions = {\n    numOfKeysLimit: 50,\n  };\n  Object.assign(options, stringifyOptions);\n  const stack: any[] = [];\n  const keys: any[] = [];\n  return JSON.stringify(obj, function (key, value) {\n    /**\n     * forked from https://github.com/moll/json-stringify-safe/blob/master/stringify.js\n     * to deCycle the object\n     */\n    if (stack.length > 0) {\n      const thisPos = stack.indexOf(this);\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n      if (~stack.indexOf(value)) {\n        if (stack[0] === value) {\n          value = '[Circular ~]';\n        } else {\n          value =\n            '[Circular ~.' +\n            keys.slice(0, stack.indexOf(value)).join('.') +\n            ']';\n        }\n      }\n    } else {\n      stack.push(value);\n    }\n    /* END of the FORK */\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n    if (shouldToString(value)) {\n      return toString(value);\n    }\n    if (value instanceof Event) {\n      const eventResult: any = {};\n      for (const eventKey in value) {\n        const eventValue = (value as any)[eventKey];\n        if (Array.isArray(eventValue)) {\n          eventResult[eventKey] = pathToSelector(\n            eventValue.length ? eventValue[0] : null,\n          );\n        } else {\n          eventResult[eventKey] = eventValue;\n        }\n      }\n      return eventResult;\n    } else if (value instanceof Node) {\n      if (value instanceof HTMLElement) {\n        return value ? value.outerHTML : '';\n      }\n      return value.nodeName;\n    }\n    return value;\n  });\n\n  /**\n   * whether we should call toString function of this object\n   */\n  function shouldToString(_obj: object): boolean {\n    if (\n      typeof _obj === 'object' &&\n      Object.keys(_obj).length > options.numOfKeysLimit\n    ) {\n      return true;\n    }\n    if (typeof _obj === 'function') {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * limit the toString() result according to option\n   */\n  function toString(_obj: object): string {\n    let str = _obj.toString();\n    if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n      str = `${str.slice(0, options.stringLengthLimit)}...`;\n    }\n    return str;\n  }\n}\n","/**\n * Class StackFrame is a fork of https://github.com/stacktracejs/stackframe/blob/master/stackframe.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n * 3. StackFrame contains some functions we don't need.\n */\nexport class StackFrame {\n  private fileName: string;\n  private functionName: string;\n  private lineNumber?: number;\n  private columnNumber?: number;\n\n  constructor(obj: {\n    fileName?: string;\n    functionName?: string;\n    lineNumber?: number;\n    columnNumber?: number;\n  }) {\n    this.fileName = obj.fileName || '';\n    this.functionName = obj.functionName || '';\n    this.lineNumber = obj.lineNumber;\n    this.columnNumber = obj.columnNumber;\n  }\n\n  toString() {\n    const lineNumber = this.lineNumber || '';\n    const columnNumber = this.columnNumber || '';\n    if (this.functionName) {\n      return (\n        this.functionName +\n        ' (' +\n        this.fileName +\n        ':' +\n        lineNumber +\n        ':' +\n        columnNumber +\n        ')'\n      );\n    }\n    return this.fileName + ':' + lineNumber + ':' + columnNumber;\n  }\n}\n\n/**\n * ErrorStackParser is a fork of https://github.com/stacktracejs/error-stack-parser/blob/master/error-stack-parser.js\n * I fork it because:\n * 1. There are some build issues when importing this package.\n * 2. Rewrites into typescript give us a better type interface.\n */\nconst FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nexport const ErrorStackParser = {\n  /**\n   * Given an Error object, extract the most information from it.\n   *\n   * @param {Error} error object\n   * @return {Array} of StackFrames\n   */\n  parse: function (error: Error): StackFrame[] {\n    if (\n      // @ts-ignore\n      typeof error.stacktrace !== 'undefined' ||\n      // @ts-ignore\n      typeof error['opera#sourceloc'] !== 'undefined'\n    ) {\n      return this.parseOpera(\n        error as {\n          stacktrace?: string;\n          message: string;\n          stack?: string;\n        },\n      );\n    } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n      return this.parseV8OrIE(error as { stack: string });\n    } else if (error.stack) {\n      return this.parseFFOrSafari(error as { stack: string });\n    } else {\n      throw new Error('Cannot parse given Error object');\n    }\n  },\n  // Separate line and column numbers from a string of the form: (URI:Line:Column)\n  extractLocation: function (urlLike: string) {\n    // Fail-fast but return locations like \"(native)\"\n    if (urlLike.indexOf(':') === -1) {\n      return [urlLike];\n    }\n\n    const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n    const parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n    if (!parts) throw new Error(`Cannot parse given url: ${urlLike}`);\n    return [parts[1], parts[2] || undefined, parts[3] || undefined];\n  },\n  parseV8OrIE: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !!line.match(CHROME_IE_STACK_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      if (line.indexOf('(eval ') > -1) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        line = line\n          .replace(/eval code/g, 'eval')\n          .replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n      }\n      let sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n      // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n      // case it has spaces in it, as the string is split on \\s+ later on\n      const location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n      // remove the parenthesized location from the line, if it was matched\n      sanitizedLine = location\n        ? sanitizedLine.replace(location[0], '')\n        : sanitizedLine;\n\n      const tokens = sanitizedLine.split(/\\s+/).slice(1);\n      // if a location was matched, pass it to extractLocation() otherwise pop the last token\n      const locationParts = this.extractLocation(\n        location ? location[1] : tokens.pop(),\n      );\n      const functionName = tokens.join(' ') || undefined;\n      const fileName =\n        ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1\n          ? undefined\n          : locationParts[0];\n\n      return new StackFrame({\n        functionName,\n        fileName,\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n  parseFFOrSafari: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n    }, this);\n\n    return filtered.map(function (line) {\n      // Throw away eval information until we implement stacktrace.js/stackframe#8\n      if (line.indexOf(' > eval') > -1) {\n        line = line.replace(\n          / line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,\n          ':$1',\n        );\n      }\n\n      if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n        // Safari eval frames only have function names and nothing else\n        return new StackFrame({\n          functionName: line,\n        });\n      } else {\n        const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n        const matches = line.match(functionNameRegex);\n        const functionName = matches && matches[1] ? matches[1] : undefined;\n        const locationParts = this.extractLocation(\n          line.replace(functionNameRegex, ''),\n        );\n\n        return new StackFrame({\n          functionName,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n        });\n      }\n    }, this);\n  },\n  parseOpera: function (e: {\n    stacktrace?: string;\n    message: string;\n    stack?: string;\n  }): StackFrame[] {\n    if (\n      !e.stacktrace ||\n      (e.message.indexOf('\\n') > -1 &&\n        e.message.split('\\n').length > e.stacktrace.split('\\n').length)\n    ) {\n      return this.parseOpera9(e as { message: string });\n    } else if (!e.stack) {\n      return this.parseOpera10(e as { stacktrace: string });\n    } else {\n      return this.parseOpera11(e as { stack: string });\n    }\n  },\n  parseOpera9: function (e: { message: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n    const lines = e.message.split('\\n');\n    const result = [];\n\n    for (let i = 2, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  parseOpera10: function (e: { stacktrace: string }) {\n    const lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n    const lines = e.stacktrace.split('\\n');\n    const result = [];\n\n    for (let i = 0, len = lines.length; i < len; i += 2) {\n      const match = lineRE.exec(lines[i]);\n      if (match) {\n        result.push(\n          new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: parseFloat(match[1]),\n          }),\n        );\n      }\n    }\n\n    return result;\n  },\n  // Opera 10.65+ Error.stack very similar to FF/Safari\n  parseOpera11: function (error: { stack: string }) {\n    const filtered = error.stack.split('\\n').filter(function (line) {\n      return (\n        !!line.match(FIREFOX_SAFARI_STACK_REGEXP) &&\n        !line.match(/^Error created at/)\n      );\n    }, this);\n\n    return filtered.map(function (line: string) {\n      const tokens = line.split('@');\n      const locationParts = this.extractLocation(tokens.pop());\n      const functionCall = tokens.shift() || '';\n      const functionName =\n        functionCall\n          .replace(/<anonymous function(: (\\w+))?>/, '$2')\n          .replace(/\\([^)]*\\)/g, '') || undefined;\n      return new StackFrame({\n        functionName,\n        fileName: locationParts[0],\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n      });\n    }, this);\n  },\n};\n","// @ts-nocheck\nimport { INode, MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { FontFaceDescriptors, FontFaceSet } from 'css-font-loading-module';\nimport {\n  throttle,\n  on,\n  hookSetter,\n  getWindowHeight,\n  getWindowWidth,\n  isBlocked,\n  isTouchEvent,\n  patch,\n} from '../utils';\nimport {\n  mutationCallBack,\n  observerParam,\n  mousemoveCallBack,\n  mousePosition,\n  mouseInteractionCallBack,\n  MouseInteractions,\n  listenerHandler,\n  scrollCallback,\n  styleSheetRuleCallback,\n  viewportResizeCallback,\n  inputValue,\n  inputCallback,\n  hookResetter,\n  blockClass,\n  maskTextClass,\n  IncrementalSource,\n  hooksParam,\n  Arguments,\n  mediaInteractionCallback,\n  MediaInteractions,\n  SamplingStrategy,\n  canvasMutationCallback,\n  fontCallback,\n  fontParam,\n  MaskInputFn,\n  MaskTextFn,\n  logCallback,\n  LogRecordOptions,\n  Logger,\n  LogLevel,\n  Mirror,\n} from '../types';\nimport MutationBuffer from './mutation';\nimport { stringify } from './stringify';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\nimport { StackFrame, ErrorStackParser } from './error-stack-parser';\n\ntype WindowWithStoredMutationObserver = Window & {\n  __rrMutationObserver?: MutationObserver;\n};\ntype WindowWithAngularZone = Window & {\n  Zone?: {\n    __symbol__?: (key: string) => string;\n  };\n};\n\nexport const mutationBuffers: MutationBuffer[] = [];\n\nexport function initMutationObserver(\n  cb: mutationCallBack,\n  doc: Document,\n  blockClass: blockClass,\n  blockSelector: string | null,\n  maskTextClass: maskTextClass,\n  maskTextSelector: string | null,\n  inlineStylesheet: boolean,\n  maskInputOptions: MaskInputOptions,\n  maskTextFn: MaskTextFn | undefined,\n  recordCanvas: boolean,\n  slimDOMOptions: SlimDOMOptions,\n  mirror: Mirror,\n  iframeManager: IframeManager,\n  shadowDomManager: ShadowDomManager,\n  rootEl: Node,\n): MutationObserver {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  // see mutation.ts for details\n  mutationBuffer.init(\n    cb,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    recordCanvas,\n    slimDOMOptions,\n    doc,\n    mirror,\n    iframeManager,\n    shadowDomManager,\n  );\n  let mutationObserverCtor =\n    window.MutationObserver ||\n    /**\n     * Some websites may disable MutationObserver by removing it from the window object.\n     * If someone is using rrweb to build a browser extention or things like it, they\n     * could not change the website's code but can have an opportunity to inject some\n     * code before the website executing its JS logic.\n     * Then they can do this to store the native MutationObserver:\n     * window.__rrMutationObserver = MutationObserver\n     */\n    (window as WindowWithStoredMutationObserver).__rrMutationObserver;\n  const angularZoneSymbol = (window as WindowWithAngularZone)?.Zone?.__symbol__?.(\n    'MutationObserver',\n  );\n  if (\n    angularZoneSymbol &&\n    ((window as unknown) as Record<string, typeof MutationObserver>)[\n    angularZoneSymbol\n    ]\n  ) {\n    mutationObserverCtor = ((window as unknown) as Record<\n      string,\n      typeof MutationObserver\n    >)[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    mutationBuffer.processMutations.bind(mutationBuffer),\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  return observer;\n}\n\nfunction initMoveObserver(\n  cb: mousemoveCallBack,\n  sampling: SamplingStrategy,\n  doc: Document,\n  mirror: Mirror,\n): listenerHandler {\n  if (sampling.mousemove === false) {\n    return () => { };\n  }\n\n  const threshold =\n    typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\n  const callbackThreshold =\n    typeof sampling.mousemoveCallback === 'number'\n      ? sampling.mousemoveCallback\n      : 500;\n\n  let positions: mousePosition[] = [];\n  let timeBaseline: number | null;\n  const wrappedCb = throttle(\n    (\n      source:\n        | IncrementalSource.MouseMove\n        | IncrementalSource.TouchMove\n        | IncrementalSource.Drag,\n    ) => {\n      const totalOffset = Date.now() - timeBaseline!;\n      cb(\n        positions.map((p) => {\n          p.timeOffset -= totalOffset;\n          return p;\n        }),\n        source,\n      );\n      positions = [];\n      timeBaseline = null;\n    },\n    callbackThreshold,\n  );\n  const updatePosition = throttle<MouseEvent | TouchEvent | DragEvent>(\n    (evt) => {\n      const { target } = evt;\n      const { clientX, clientY } = isTouchEvent(evt)\n        ? evt.changedTouches[0]\n        : evt;\n      if (!timeBaseline) {\n        timeBaseline = Date.now();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror.getId(target as INode),\n        timeOffset: Date.now() - timeBaseline,\n      });\n      wrappedCb(\n        evt instanceof MouseEvent\n          ? IncrementalSource.MouseMove\n          : evt instanceof DragEvent\n            ? IncrementalSource.Drag\n            : IncrementalSource.TouchMove,\n      );\n    },\n    threshold,\n    {\n      trailing: false,\n    },\n  );\n  const handlers = [\n    on('mousemove', updatePosition, doc),\n    on('touchmove', updatePosition, doc),\n    on('drag', updatePosition, doc),\n  ];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initMouseInteractionObserver(\n  cb: mouseInteractionCallBack,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  if (sampling.mouseInteraction === false) {\n    return () => { };\n  }\n  const disableMap: Record<string, boolean | undefined> =\n    sampling.mouseInteraction === true ||\n      sampling.mouseInteraction === undefined\n      ? {}\n      : sampling.mouseInteraction;\n\n  const handlers: listenerHandler[] = [];\n  const getHandler = (eventKey: keyof typeof MouseInteractions) => {\n    return (event: MouseEvent | TouchEvent) => {\n      if (isBlocked(event.target as Node, blockClass)) {\n        return;\n      }\n      const e = isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e) {\n        return;\n      }\n      const id = mirror.getId(event.target as INode);\n      const { clientX, clientY } = e;\n      cb({\n        type: MouseInteractions[eventKey],\n        id,\n        x: clientX,\n        y: clientY,\n      });\n    };\n  };\n  Object.keys(MouseInteractions)\n    .filter(\n      (key) =>\n        Number.isNaN(Number(key)) &&\n        !key.endsWith('_Departed') &&\n        disableMap[key] !== false,\n    )\n    .forEach((eventKey: keyof typeof MouseInteractions) => {\n      const eventName = eventKey.toLowerCase();\n      const handler = getHandler(eventKey);\n      handlers.push(on(eventName, handler, doc));\n    });\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initScrollObserver(\n  cb: scrollCallback,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  const updatePosition = throttle<UIEvent>((evt) => {\n    if (!evt.target || isBlocked(evt.target as Node, blockClass)) {\n      return;\n    }\n    const id = mirror.getId(evt.target as INode);\n    if (evt.target === doc) {\n      const scrollEl = (doc.scrollingElement || doc.documentElement)!;\n      cb({\n        id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n      });\n    } else {\n      cb({\n        id,\n        x: (evt.target as HTMLElement).scrollLeft,\n        y: (evt.target as HTMLElement).scrollTop,\n      });\n    }\n  }, sampling.scroll || 100);\n  return on('scroll', updatePosition);\n}\n\nfunction initViewportResizeObserver(\n  cb: viewportResizeCallback,\n): listenerHandler {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = throttle(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    if (lastH !== height || lastW !== width) {\n      cb({\n        width: Number(width),\n        height: Number(height),\n      });\n      lastH = height;\n      lastW = width;\n    }\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nexport const INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nconst lastInputValueMap: WeakMap<EventTarget, inputValue> = new WeakMap();\nfunction initInputObserver(\n  cb: inputCallback,\n  doc: Document,\n  mirror: Mirror,\n  blockClass: blockClass,\n  ignoreClass: string,\n  maskInputOptions: MaskInputOptions,\n  maskInputFn: MaskInputFn | undefined,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  function eventHandler(event: Event) {\n    const { target } = event;\n    if (\n      !target ||\n      !(target as Element).tagName ||\n      INPUT_TAGS.indexOf((target as Element).tagName) < 0 ||\n      isBlocked(target as Node, blockClass)\n    ) {\n      return;\n    }\n    const type: string | undefined = (target as HTMLInputElement).type;\n    if (\n      type === 'password' ||\n      (target as HTMLElement).classList.contains(ignoreClass)\n    ) {\n      return;\n    }\n    let text = (target as HTMLInputElement).value;\n    let isChecked = false;\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = (target as HTMLInputElement).checked;\n    } else if (\n      maskInputOptions[\n      (target as Element).tagName.toLowerCase() as keyof MaskInputOptions\n      ] ||\n      maskInputOptions[type as keyof MaskInputOptions]\n    ) {\n      if (maskInputFn) {\n        text = maskInputFn(text);\n      } else {\n        text = '*'.repeat(text.length);\n      }\n    }\n    cbWithDedup(target, { text, isChecked });\n    // if a radio was checked\n    // the other radios with the same name attribute will be unchecked.\n    const name: string | undefined = (target as HTMLInputElement).name;\n    if (type === 'radio' && name && isChecked) {\n      doc\n        .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\n        .forEach((el) => {\n          if (el !== target) {\n            cbWithDedup(el, {\n              text: (el as HTMLInputElement).value,\n              isChecked: !isChecked,\n            });\n          }\n        });\n    }\n  }\n  function cbWithDedup(target: EventTarget, v: inputValue) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (\n      !lastInputValue ||\n      lastInputValue.text !== v.text ||\n      lastInputValue.isChecked !== v.isChecked\n    ) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target as INode);\n      cb({\n        ...v,\n        id,\n      });\n    }\n  }\n  const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\n  const handlers: Array<\n    listenerHandler | hookResetter\n  > = events.map((eventName) => on(eventName, eventHandler, doc));\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    HTMLInputElement.prototype,\n    'value',\n  );\n  const hookProperties: Array<[HTMLElement, string]> = [\n    [HTMLInputElement.prototype, 'value'],\n    [HTMLInputElement.prototype, 'checked'],\n    [HTMLSelectElement.prototype, 'value'],\n    [HTMLTextAreaElement.prototype, 'value'],\n    // Some UI library use selectedIndex to set select value\n    [HTMLSelectElement.prototype, 'selectedIndex'],\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map((p) =>\n        hookSetter<HTMLElement>(p[0], p[1], {\n          set() {\n            // mock to a normal event\n            eventHandler({ target: this } as Event);\n          },\n        }),\n      ),\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initStyleSheetObserver(\n  cb: styleSheetRuleCallback,\n  mirror: Mirror,\n): listenerHandler {\n  const insertRule = CSSStyleSheet.prototype.insertRule;\n  CSSStyleSheet.prototype.insertRule = function (rule: string, index?: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        adds: [{ rule, index }],\n      });\n    }\n    return insertRule.apply(this, arguments);\n  };\n\n  const deleteRule = CSSStyleSheet.prototype.deleteRule;\n  CSSStyleSheet.prototype.deleteRule = function (index: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        removes: [{ index }],\n      });\n    }\n    return deleteRule.apply(this, arguments);\n  };\n\n  return () => {\n    CSSStyleSheet.prototype.insertRule = insertRule;\n    CSSStyleSheet.prototype.deleteRule = deleteRule;\n  };\n}\n\nfunction initMediaInteractionObserver(\n  mediaInteractionCb: mediaInteractionCallback,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const handler = (type: 'play' | 'pause') => (event: Event) => {\n    const { target } = event;\n    if (!target || isBlocked(target as Node, blockClass)) {\n      return;\n    }\n    mediaInteractionCb({\n      type: type === 'play' ? MediaInteractions.Play : MediaInteractions.Pause,\n      id: mirror.getId(target as INode),\n    });\n  };\n  const handlers = [on('play', handler('play')), on('pause', handler('pause'))];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initCanvasMutationObserver(\n  cb: canvasMutationCallback,\n  blockClass: blockClass,\n  mirror: Mirror,\n): listenerHandler {\n  const props = Object.getOwnPropertyNames(CanvasRenderingContext2D.prototype);\n  const handlers: listenerHandler[] = [];\n  for (const prop of props) {\n    try {\n      if (\n        typeof CanvasRenderingContext2D.prototype[\n        prop as keyof CanvasRenderingContext2D\n        ] !== 'function'\n      ) {\n        continue;\n      }\n      const restoreHandler = patch(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        function (original) {\n          return function (\n            this: CanvasRenderingContext2D,\n            ...args: Array<unknown>\n          ) {\n            if (!isBlocked(this.canvas, blockClass)) {\n              setTimeout(() => {\n                const recordArgs = [...args];\n                if (prop === 'drawImage') {\n                  if (\n                    recordArgs[0] &&\n                    recordArgs[0] instanceof HTMLCanvasElement\n                  ) {\n                    recordArgs[0] = recordArgs[0].toDataURL();\n                  }\n                }\n                cb({\n                  id: mirror.getId((this.canvas as unknown) as INode),\n                  property: prop,\n                  args: recordArgs,\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        },\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter<CanvasRenderingContext2D>(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v) {\n            cb({\n              id: mirror.getId((this.canvas as unknown) as INode),\n              property: prop,\n              args: [v],\n              setter: true,\n            });\n          },\n        },\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initFontObserver(cb: fontCallback): listenerHandler {\n  const handlers: listenerHandler[] = [];\n\n  const fontMap = new WeakMap<FontFace, fontParam>();\n\n  const originalFontFace = FontFace;\n  // tslint:disable-next-line: no-any\n  (window as any).FontFace = function FontFace(\n    family: string,\n    source: string | ArrayBufferView,\n    descriptors?: FontFaceDescriptors,\n  ) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== 'string',\n      descriptors,\n      fontSource:\n        typeof source === 'string'\n          ? source\n          : // tslint:disable-next-line: no-any\n          JSON.stringify(Array.from(new Uint8Array(source as any))),\n    });\n    return fontFace;\n  };\n\n  const restoreHandler = patch(document.fonts, 'add', function (original) {\n    return function (this: FontFaceSet, fontFace: FontFace) {\n      setTimeout(() => {\n        const p = fontMap.get(fontFace);\n        if (p) {\n          cb(p);\n          fontMap.delete(fontFace);\n        }\n      }, 0);\n      return original.apply(this, [fontFace]);\n    };\n  });\n\n  handlers.push(() => {\n    // tslint:disable-next-line: no-any\n    (window as any).FonFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initLogObserver(\n  cb: logCallback,\n  logOptions: LogRecordOptions,\n): listenerHandler {\n  const logger = logOptions.logger;\n  if (!logger) {\n    return () => { };\n  }\n  let logCount = 0;\n  const cancelHandlers: listenerHandler[] = [];\n  // add listener to thrown errors\n  if (logOptions.level!.includes('error')) {\n    if (window) {\n      const originalOnError = window.onerror;\n      window.onerror = (\n        msg: Event | string,\n        file: string,\n        line: number,\n        col: number,\n        error: Error,\n      ) => {\n        if (originalOnError) {\n          originalOnError.apply(this, [msg, file, line, col, error]);\n        }\n        const trace: string[] = ErrorStackParser.parse(\n          error,\n        ).map((stackFrame: StackFrame) => stackFrame.toString());\n        const payload = [stringify(msg, logOptions.stringifyOptions)];\n        cb({\n          level: 'error',\n          trace,\n          payload,\n        });\n      };\n      cancelHandlers.push(() => {\n        window.onerror = originalOnError;\n      });\n    }\n  }\n  for (const levelType of logOptions.level!) {\n    cancelHandlers.push(replace(logger, levelType));\n  }\n  return () => {\n    cancelHandlers.forEach((h) => h());\n  };\n\n  /**\n   * replace the original console function and record logs\n   * @param logger the logger object such as Console\n   * @param level the name of log function to be replaced\n   */\n  function replace(_logger: Logger, level: LogLevel) {\n    if (!_logger[level]) {\n      return () => { };\n    }\n    // replace the logger.{level}. return a restore function\n    return patch(_logger, level, (original) => {\n      return (...args: unknown[]) => {\n        original.apply(this, args);\n        try {\n          const trace = ErrorStackParser.parse(new Error())\n            .map((stackFrame: StackFrame) => stackFrame.toString())\n            .splice(1); // splice(1) to omit the hijacked log function\n          const payload = args.map((s) =>\n            stringify(s, logOptions.stringifyOptions),\n          );\n          logCount++;\n          if (logCount < logOptions.lengthThreshold!) {\n            cb({\n              level,\n              trace,\n              payload,\n            });\n          } else if (logCount === logOptions.lengthThreshold) {\n            // notify the user\n            cb({\n              level: 'warn',\n              trace: [],\n              payload: [\n                stringify('The number of log records reached the threshold.'),\n              ],\n            });\n          }\n        } catch (error) {\n          original('rrweb logger error:', error, ...args);\n        }\n      };\n    });\n  }\n}\n\nfunction mergeHooks(o: observerParam, hooks: hooksParam) {\n  const {\n    mutationCb,\n    mousemoveCb,\n    mouseInteractionCb,\n    scrollCb,\n    viewportResizeCb,\n    inputCb,\n    mediaInteractionCb,\n    styleSheetRuleCb,\n    canvasMutationCb,\n    fontCb,\n    logCb,\n  } = o;\n  o.mutationCb = (...p: Arguments<mutationCallBack>) => {\n    if (hooks.mutation) {\n      hooks.mutation(...p);\n    }\n    mutationCb(...p);\n  };\n  o.mousemoveCb = (...p: Arguments<mousemoveCallBack>) => {\n    if (hooks.mousemove) {\n      hooks.mousemove(...p);\n    }\n    mousemoveCb(...p);\n  };\n  o.mouseInteractionCb = (...p: Arguments<mouseInteractionCallBack>) => {\n    if (hooks.mouseInteraction) {\n      hooks.mouseInteraction(...p);\n    }\n    mouseInteractionCb(...p);\n  };\n  o.scrollCb = (...p: Arguments<scrollCallback>) => {\n    if (hooks.scroll) {\n      hooks.scroll(...p);\n    }\n    scrollCb(...p);\n  };\n  o.viewportResizeCb = (...p: Arguments<viewportResizeCallback>) => {\n    if (hooks.viewportResize) {\n      hooks.viewportResize(...p);\n    }\n    viewportResizeCb(...p);\n  };\n  o.inputCb = (...p: Arguments<inputCallback>) => {\n    if (hooks.input) {\n      hooks.input(...p);\n    }\n    inputCb(...p);\n  };\n  o.mediaInteractionCb = (...p: Arguments<mediaInteractionCallback>) => {\n    if (hooks.mediaInteaction) {\n      hooks.mediaInteaction(...p);\n    }\n    mediaInteractionCb(...p);\n  };\n  o.styleSheetRuleCb = (...p: Arguments<styleSheetRuleCallback>) => {\n    if (hooks.styleSheetRule) {\n      hooks.styleSheetRule(...p);\n    }\n    styleSheetRuleCb(...p);\n  };\n  o.canvasMutationCb = (...p: Arguments<canvasMutationCallback>) => {\n    if (hooks.canvasMutation) {\n      hooks.canvasMutation(...p);\n    }\n    canvasMutationCb(...p);\n  };\n  o.fontCb = (...p: Arguments<fontCallback>) => {\n    if (hooks.font) {\n      hooks.font(...p);\n    }\n    fontCb(...p);\n  };\n  o.logCb = (...p: Arguments<logCallback>) => {\n    if (hooks.log) {\n      hooks.log(...p);\n    }\n    logCb(...p);\n  };\n}\n\nexport function initObservers(\n  o: observerParam,\n  hooks: hooksParam = {},\n): listenerHandler {\n  mergeHooks(o, hooks);\n  const mutationObserver = initMutationObserver(\n    o.mutationCb,\n    o.doc,\n    o.blockClass,\n    o.blockSelector,\n    o.maskTextClass,\n    o.maskTextSelector,\n    o.inlineStylesheet,\n    o.maskInputOptions,\n    o.maskTextFn,\n    o.recordCanvas,\n    o.slimDOMOptions,\n    o.mirror,\n    o.iframeManager,\n    o.shadowDomManager,\n    o.doc,\n  );\n  const mousemoveHandler = initMoveObserver(\n    o.mousemoveCb,\n    o.sampling,\n    o.doc,\n    o.mirror,\n  );\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.sampling,\n  );\n  const scrollHandler = initScrollObserver(\n    o.scrollCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.sampling,\n  );\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);\n  const inputHandler = initInputObserver(\n    o.inputCb,\n    o.doc,\n    o.mirror,\n    o.blockClass,\n    o.ignoreClass,\n    o.maskInputOptions,\n    o.maskInputFn,\n    o.sampling,\n  );\n  const mediaInteractionHandler = initMediaInteractionObserver(\n    o.mediaInteractionCb,\n    o.blockClass,\n    o.mirror,\n  );\n  const styleSheetObserver = initStyleSheetObserver(\n    o.styleSheetRuleCb,\n    o.mirror,\n  );\n  const canvasMutationObserver = o.recordCanvas\n    ? initCanvasMutationObserver(o.canvasMutationCb, o.blockClass, o.mirror)\n    : () => { };\n  const fontObserver = o.collectFonts ? initFontObserver(o.fontCb) : () => { };\n  const logObserver = o.logOptions\n    ? initLogObserver(o.logCb, o.logOptions)\n    : () => { };\n\n  return () => {\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    canvasMutationObserver();\n    fontObserver();\n    logObserver();\n  };\n}\n","import { serializedNodeWithId, INode } from '../snapshot';\nimport { mutationCallBack } from '../types';\n\nexport class IframeManager {\n  private iframes: WeakMap<HTMLIFrameElement, true> = new WeakMap();\n  private mutationCb: mutationCallBack;\n  private loadListener?: (iframeEl: HTMLIFrameElement) => unknown;\n\n  constructor(options: { mutationCb: mutationCallBack }) {\n    this.mutationCb = options.mutationCb;\n  }\n\n  public addIframe(iframeEl: HTMLIFrameElement) {\n    this.iframes.set(iframeEl, true);\n  }\n\n  public addLoadListener(cb: (iframeEl: HTMLIFrameElement) => unknown) {\n    this.loadListener = cb;\n  }\n\n  public attachIframe(iframeEl: INode, childSn: serializedNodeWithId) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: iframeEl.__sn.id,\n          nextId: null,\n          node: childSn,\n        },\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true,\n    });\n    this.loadListener?.((iframeEl as unknown) as HTMLIFrameElement);\n  }\n}\n","import {\n  mutationCallBack,\n  blockClass,\n  maskTextClass,\n  MaskTextFn,\n  Mirror,\n} from '../types';\nimport { MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { IframeManager } from './iframe-manager';\nimport { initMutationObserver } from './observer';\n\ntype BypassOptions = {\n  blockClass: blockClass;\n  blockSelector: string | null;\n  maskTextClass: maskTextClass;\n  maskTextSelector: string | null;\n  inlineStylesheet: boolean;\n  maskInputOptions: MaskInputOptions;\n  maskTextFn: MaskTextFn | undefined;\n  recordCanvas: boolean;\n  slimDOMOptions: SlimDOMOptions;\n  iframeManager: IframeManager;\n};\n\nexport class ShadowDomManager {\n  private mutationCb: mutationCallBack;\n  private bypassOptions: BypassOptions;\n  private mirror: Mirror;\n\n  constructor(options: {\n    mutationCb: mutationCallBack;\n    bypassOptions: BypassOptions;\n    mirror: Mirror;\n  }) {\n    this.mutationCb = options.mutationCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n  }\n\n  public addShadowRoot(shadowRoot: ShadowRoot, doc: Document) {\n    initMutationObserver(\n      this.mutationCb,\n      doc,\n      this.bypassOptions.blockClass,\n      this.bypassOptions.blockSelector,\n      this.bypassOptions.maskTextClass,\n      this.bypassOptions.maskTextSelector,\n      this.bypassOptions.inlineStylesheet,\n      this.bypassOptions.maskInputOptions,\n      this.bypassOptions.maskTextFn,\n      this.bypassOptions.recordCanvas,\n      this.bypassOptions.slimDOMOptions,\n      this.mirror,\n      this.bypassOptions.iframeManager,\n      this,\n      shadowRoot,\n    );\n  }\n}\n","import { snapshot, MaskInputOptions, SlimDOMOptions } from '../snapshot';\nimport { initObservers, mutationBuffers } from './observer';\nimport {\n  on,\n  getWindowWidth,\n  getWindowHeight,\n  polyfill,\n  isIframeINode,\n  hasShadowRoot,\n  createMirror,\n} from '../utils';\nimport {\n  EventType,\n  event,\n  eventWithTime,\n  recordOptions,\n  IncrementalSource,\n  listenerHandler,\n  LogRecordOptions,\n  mutationCallbackParam,\n} from '../types';\nimport { IframeManager } from './iframe-manager';\nimport { ShadowDomManager } from './shadow-dom-manager';\n\nfunction wrapEvent(e: event): eventWithTime {\n  return {\n    ...e,\n    timestamp: Date.now(),\n  };\n}\n\nlet wrappedEmit!: (e: eventWithTime, isCheckout?: boolean) => void;\n\nlet takeFullSnapshot!: (isCheckout?: boolean) => void;\n\nconst mirror = createMirror();\nfunction record<T = eventWithTime>(\n  options: recordOptions<T> = {},\n): listenerHandler | undefined {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = 'rr-block',\n    blockSelector = null,\n    ignoreClass = 'rr-ignore',\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskInputFn,\n    maskTextFn,\n    hooks,\n    packFn,\n    sampling = {},\n    mousemoveWait,\n    recordCanvas = false,\n    collectFonts = false,\n    recordLog = false,\n  } = options;\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n  // move departed options to new options\n  if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n    sampling.mousemove = mousemoveWait;\n  }\n\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n        }\n      : _maskInputOptions !== undefined\n      ? _maskInputOptions\n      : {};\n\n  const slimDOMOptions: SlimDOMOptions =\n    _slimDOMOptions === true || _slimDOMOptions === 'all'\n      ? {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaVerification: true,\n          // the following are off for slimDOMOptions === true,\n          // as they destroy some (hidden) info:\n          headMetaAuthorship: _slimDOMOptions === 'all',\n          headMetaDescKeywords: _slimDOMOptions === 'all',\n        }\n      : _slimDOMOptions\n      ? _slimDOMOptions\n      : {};\n  const defaultLogOptions: LogRecordOptions = {\n    level: [\n      'assert',\n      'clear',\n      'count',\n      'countReset',\n      'debug',\n      'dir',\n      'dirxml',\n      // 'error',\n      'group',\n      'groupCollapsed',\n      'groupEnd',\n      'info',\n      'log',\n      'table',\n      'time',\n      'timeEnd',\n      'timeLog',\n      'trace',\n      'warn',\n    ],\n    lengthThreshold: 1000,\n    logger: console,\n  };\n\n  const logOptions: LogRecordOptions = recordLog\n    ? recordLog === true\n      ? defaultLogOptions\n      : Object.assign({}, defaultLogOptions, recordLog)\n    : {};\n\n  polyfill();\n\n  let lastFullSnapshotEvent: eventWithTime;\n  let incrementalSnapshotCount = 0;\n  wrappedEmit = (e: eventWithTime, isCheckout?: boolean) => {\n    if (\n      mutationBuffers[0]?.isFrozen() &&\n      e.type !== EventType.FullSnapshot &&\n      !(\n        e.type === EventType.IncrementalSnapshot &&\n        e.data.source === IncrementalSource.Mutation\n      )\n    ) {\n      // we've got a user initiated event so first we need to apply\n      // all DOM changes that have been buffering during paused state\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n\n    emit(((packFn ? packFn(e) : e) as unknown) as T, isCheckout);\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      // attch iframe should be considered as full snapshot\n      if (\n        e.data.source === IncrementalSource.Mutation &&\n        e.data.isAttachIframe\n      ) {\n        return;\n      }\n\n      incrementalSnapshotCount++;\n      const exceedCount =\n        checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime =\n        checkoutEveryNms &&\n        e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  const wrappedMutationEmit = (m: mutationCallbackParam) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.Mutation,\n          ...m,\n        },\n      }),\n    );\n  };\n\n  const iframeManager = new IframeManager({\n    mutationCb: wrappedMutationEmit,\n  });\n\n  const shadowDomManager = new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    bypassOptions: {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      recordCanvas,\n      slimDOMOptions,\n      iframeManager,\n    },\n    mirror,\n  });\n\n  takeFullSnapshot = (isCheckout = false) => {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight(),\n        },\n      }),\n      isCheckout,\n    );\n\n    mutationBuffers.forEach((buf) => buf.lock()); // don't allow any mirror modifications during snapshotting\n    const [node, idNodeMap] = snapshot(document, {\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      recordCanvas,\n      onSerialize: (n) => {\n        if (isIframeINode(n)) {\n          iframeManager.addIframe(n);\n        }\n        if (hasShadowRoot(n)) {\n          shadowDomManager.addShadowRoot(n.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n      },\n    });\n\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n\n    mirror.map = idNodeMap;\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: {\n            left:\n              window.pageXOffset !== undefined\n                ? window.pageXOffset\n                : document?.documentElement.scrollLeft ||\n                  document?.body?.parentElement?.scrollLeft ||\n                  document?.body.scrollLeft ||\n                  0,\n            top:\n              window.pageYOffset !== undefined\n                ? window.pageYOffset\n                : document?.documentElement.scrollTop ||\n                  document?.body?.parentElement?.scrollTop ||\n                  document?.body.scrollTop ||\n                  0,\n          },\n        },\n      }),\n    );\n    mutationBuffers.forEach((buf) => buf.unlock()); // generate & emit any mutations that happened during snapshotting, as can now apply against the newly built mirror\n  };\n\n  try {\n    const handlers: listenerHandler[] = [];\n    handlers.push(\n      on('DOMContentLoaded', () => {\n        wrappedEmit(\n          wrapEvent({\n            type: EventType.DomContentLoaded,\n            data: {},\n          }),\n        );\n      }),\n    );\n\n    const observe = (doc: Document) => {\n      return initObservers(\n        {\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source,\n                  positions,\n                },\n              }),\n            ),\n          mouseInteractionCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MouseInteraction,\n                  ...d,\n                },\n              }),\n            ),\n          scrollCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Scroll,\n                  ...p,\n                },\n              }),\n            ),\n          viewportResizeCb: (d) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.ViewportResize,\n                  ...d,\n                },\n              }),\n            ),\n          inputCb: (v) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Input,\n                  ...v,\n                },\n              }),\n            ),\n          mediaInteractionCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MediaInteraction,\n                  ...p,\n                },\n              }),\n            ),\n          styleSheetRuleCb: (r) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.StyleSheetRule,\n                  ...r,\n                },\n              }),\n            ),\n          canvasMutationCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.CanvasMutation,\n                  ...p,\n                },\n              }),\n            ),\n          fontCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Font,\n                  ...p,\n                },\n              }),\n            ),\n          logCb: (p) =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Log,\n                  ...p,\n                },\n              }),\n            ),\n          blockClass,\n          ignoreClass,\n          maskTextClass,\n          maskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordCanvas,\n          collectFonts,\n          doc,\n          maskInputFn,\n          maskTextFn,\n          logOptions,\n          blockSelector,\n          slimDOMOptions,\n          mirror,\n          iframeManager,\n          shadowDomManager,\n        },\n        hooks,\n      );\n    };\n\n    iframeManager.addLoadListener((iframeEl) => {\n      handlers.push(observe(iframeEl.contentDocument!));\n    });\n\n    const init = () => {\n      takeFullSnapshot();\n      handlers.push(observe(document));\n    };\n    if (\n      document.readyState === 'interactive' ||\n      document.readyState === 'complete'\n    ) {\n      init();\n    } else {\n      handlers.push(\n        on(\n          'load',\n          () => {\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.Load,\n                data: {},\n              }),\n            );\n            init();\n          },\n          window,\n        ),\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  } catch (error) {\n    // TODO: handle internal error\n    console.warn(error);\n  }\n}\n\nrecord.addCustomEvent = <T>(tag: string, payload: T) => {\n  if (!wrappedEmit) {\n    throw new Error('please add custom event after start recording');\n  }\n  wrappedEmit(\n    wrapEvent({\n      type: EventType.Custom,\n      data: {\n        tag,\n        payload,\n      },\n    }),\n  );\n};\n\nrecord.freezePage = () => {\n  mutationBuffers.forEach((buf) => buf.freeze());\n};\n\nrecord.takeFullSnapshot = (isCheckout?: boolean) => {\n  if (!takeFullSnapshot) {\n    throw new Error('please take full snapshot after start recording');\n  }\n  takeFullSnapshot(isCheckout);\n};\n\nrecord.mirror = mirror;\n\nexport default record;\n","// @ts-nocheck\n\nimport { strFromU8, strToU8, zlibSync } from 'fflate';\nimport { PackFn, MARK, eventWithTimeAndPacker } from './base';\n\nexport const pack: PackFn = (event) => {\n  const _e: eventWithTimeAndPacker = {\n    ...event,\n    v: MARK,\n  };\n  return strFromU8(zlibSync(strToU8(JSON.stringify(_e))), true);\n};\n","import { eventWithTime } from '../types';\n\nexport type PackFn = (event: eventWithTime) => string;\nexport type UnpackFn = (raw: string) => eventWithTime;\n\nexport type eventWithTimeAndPacker = eventWithTime & {\n  v: string;\n};\n\nexport const MARK = 'v1';\n","import { AskLevel } from \"../types/types\"\nimport { config } from \"../config/config\"\nimport { W } from \"../constants\"\nimport record from \"../rrweb/record\"\nimport { pack } from \"../rrweb/packer\"\nimport { eventWithTime } from \"../rrweb/types\"\nimport { warn } from \"../utils/console\"\n\n/**\n * Error Trap\n */\n\nexport default class ErrorTrace {\n  private static instance: ErrorTrace | null = null\n  private eventsMatrix: Array<Array<eventWithTime>> = [[]]\n\n  private constructor() {\n    this.globalErrorTrace()\n    this.networkErrorTrace()\n    this.promiseErrorTrace()\n    this.iframeErrorTrace()\n    record({\n      ...config.recordOptions,\n      emit: (event, isCheckout) => {\n        if (isCheckout) {\n          this.eventsMatrix.push([]);\n        }\n        const lastEvents = this.eventsMatrix[this.eventsMatrix.length - 1];\n        lastEvents.push(event);\n      },\n      recordLog: false,\n      checkoutEveryNth: 10,\n      packFn: pack,\n    })\n  }\n\n  public static getInstance(): ErrorTrace {\n    if (!this.instance) {\n      this.instance = new ErrorTrace()\n    }\n    return this.instance\n  }\n\n  /**\n   * Globally catch synchronous or asynchronous errors\n   * 捕获异常的能力比try-catch稍微强点，无论是异步还是非异步，onerror都能捕获到运行时错误，返回true就不回报红\n   * 当时当<img src=\"\" />这种情况是捕获不到的\n   * 使用未使用的变量\n   */\n  private globalErrorTrace(): void {\n    W.onerror = (\n      event: Event | string,\n      source?: string,\n      lineno?: number,\n      colno?: number,\n      error?: Error\n    ) => {\n\n      warn({\n        source,\n        lineno,\n        colno,\n        error,\n      })\n\n      const len = this.eventsMatrix.length;\n\n      if (config.errEventRoute && len >= 2) {\n        const events = this.eventsMatrix[len - 2].concat(this.eventsMatrix[len - 1]);\n        config.reportData?.fetch(\n          AskLevel.IDLE,\n          JSON.stringify({ events }),\n          config.errEventRoute\n        )\n      }\n\n      if (config.errLogRoute) {\n        config.reportData?.fetch(\n          AskLevel.IDLE,\n          JSON.stringify({\n            source,\n            lineno,\n            colno,\n            error: JSON.stringify({\n              message: error?.message,\n              stack: error?.stack,\n              name: error?.name,\n            }),\n          }),\n          config.errLogRoute\n        )\n      }\n      return true\n    }\n  }\n  /**\n   * Catch network errors\n   * 图片加载失败等\n   */\n  private networkErrorTrace(): void {\n    W.addEventListener(\n      \"error\",\n      (e: ErrorEvent) => {\n        if (e.target !== W) {\n          warn(e.target)\n        }\n      },\n      true\n    )\n  }\n\n  /**\n   * Catching Promise errors\n   */\n  private promiseErrorTrace(): void {\n    window.addEventListener(\"unhandledrejection\", (e) => {\n      e.preventDefault()\n      warn(e.reason)\n      return true\n    })\n  }\n\n  private iframeErrorTrace(): void {\n    const frames = W.frames\n    for (let i = 0; i < frames.length; i++) {\n      frames[i].addEventListener(\n        \"error\",\n        (e: ErrorEvent) => {\n          warn(e)\n        },\n        true\n      )\n      frames[i].addEventListener(\n        \"unhandledrejection\",\n        (e) => {\n          warn(e)\n        },\n        true\n      )\n    }\n  }\n}\n","import { AskLevel, ReportDataAchieve } from \"../types/types\"\nimport { W, WN } from \"../constants\"\nimport { config } from \"../config/config\"\n\nexport interface ReportDataOptions {\n  logDomain: string | undefined,\n}\n\n/**\n * Log collection\n * 日志收集\n */\nexport default class ReportData implements ReportDataAchieve {\n  /**\n   * Log report, error report\n   * If the level is urgent, use http request directly, otherwise use navigator.sendBeacon\n   * 日志上报、错误上报\n   * 如果level很紧急，直接使用http请求，否者使用navigator.sendBeacon\n   * @param level\n   * @param body \n   * @param uri \n   */\n  public fetch(level: AskLevel, body: string, uri: string): void {\n    uri = config.fetchDomain + uri\n\n    switch (level) {\n      case AskLevel.URGENT: {\n        if (!!W.fetch) {\n          fetch(uri, { body, method: \"POST\", keepalive: true })\n        } else {\n          let xhr: XMLHttpRequest | null = new XMLHttpRequest()\n          xhr.open(\"post\", uri, true)\n          xhr.setRequestHeader(\"Content-Type\", \"application/json\")\n          xhr.send(body)\n          xhr.onload = () => xhr = null // 防止内存泄漏\n        }\n        return\n      }\n      default:\n        if (!!WN.sendBeacon) {\n          navigator.sendBeacon(uri, body)\n        } else {\n          let image: HTMLImageElement | null = new Image()\n          image.src = `${uri}?body=${body}`\n          image.onload = () => image = null // 防止内存泄漏\n        }\n    }\n  }\n}","import { W, WP } from \"../constants\"\n\n/**\n * Determine whether the browser supports getEntriesByType\n * @returns \n */\nexport const isPerformanceSupported = (): boolean => {\n  return WP && !!WP.getEntriesByType && !!WP.now && !!WP.mark\n}\n\n/**\n * bytes to kb\n * @param {number} bytes\n */\nexport const bytes2kb = (bytes: number) => {\n  return parseFloat((bytes / Math.pow(1024, 2)).toFixed(2))\n}\n\n/**\n * Keep two decimal places\n * @param {number} num\n * @returns \n */\nexport const roundByTwo = (num: number) => {\n  return parseFloat(num.toFixed(2))\n}\n\n/**\n * PushTask to requestIdleCallback\n * Efficient use of each frame for data collection\n * @param {() => void} callback\n */\nexport const pushTask = (callback: () => void) => {\n  if (\"requestIdleCallback\" in W) {\n    (W as any).requestIdleCallback(callback, { timeout: 3000 })\n  } else {\n    callback()\n  }\n}","import { bytes2kb } from \"../utils/helper\"\nimport { WN } from \"../constants\"\nimport type { StorageOpt } from \"../types/types\"\n\n/**\n  * Record local cache information\n*/\n\nexport const recordingStorage = async (): Promise<StorageOpt> => {\n  if (!WN.storage) return { usageDetails: {} }\n\n  const { quota, usage, usageDetails } = await WN.storage.estimate() as StorageOpt\n  let res = {\n    quota: bytes2kb(quota || 0),\n    usage: bytes2kb(usage || 0),\n    usageDetails,\n  }\n  if (res.usageDetails) {\n    Object.keys(res.usageDetails || {}).forEach(key => res.usageDetails[key] = bytes2kb(res.usageDetails[key]))\n  }\n  return res\n}","import { WN } from \"../constants\"\nimport type { EffectiveType, NavigatorOpt } from \"../types/types\"\nimport { pushTask } from \"../utils/helper\"\n\nexport let effectiveType: EffectiveType = \"4g\"\nexport let saveData: boolean = false\n\n/**\n   * Get user's browser information, internet speed and other information\n   * Calculating network speed formula\n   * T1 = DNS + New Connection(TCP) + RTT(One-time transmission)\n   * T2 = New Connection(TCP) + RTT(One-time transmission)\n   * T3 = RTT(One-time transmission)\n   * bandwidth = (100k-50k)/(t5-t4)\n   * @return {NavigatorOpt}\n   */\nexport const recordClientNavigator = async (): Promise<NavigatorOpt> => {\n  return new Promise(resolve => {\n    let res = {} as NavigatorOpt\n    if (\"connection\" in WN) {\n      res.connection = {\n        downlink: WN.connection.downlink,\n        effectiveType: WN.connection.effectiveType,\n        rtt: WN.connection.rtt,\n        saveData: WN.connection.saveData,\n      }\n      saveData = res.connection.saveData || saveData\n      effectiveType = res.connection.effectiveType || effectiveType\n    }\n    // Doppler Velocity\n    if (\"fetch\" in window) {\n      pushTask(async () => {\n        let times = []\n        const sizes = [0, 0, 0, 50, 100]\n\n        times.push(+ new Date())\n\n        for (let size of sizes) {\n          await fetch(`http://performance-monitoring.zhourengui.top/performance-monitoring/doppler-velocity?size=${size}`)\n          times.push(+ new Date())\n        }\n\n        res.connection.bandwidth = `${((sizes[4] - sizes[3]) / ((times[5] - times[4]) / 1000)).toFixed(2)} k/s`\n        resolve(res)\n      })\n    }\n\n    res.userAgent = WN.userAgent\n  })\n}","import { WP } from \"../constants\"\nimport { isPerformanceSupported } from \"../utils/helper\"\nimport type { TimingOpt } from \"../types/types\"\n/**\n  * Navigation Timing API provides performance metrics for HTML documents.\n  * w3c.github.io/navigation-timing/\n  * developers.google.com/web/fundamentals/performance/navigation-and-resource-timing\n  */\nexport const recordTiming = async (): Promise<TimingOpt> => {\n  let res = {} as TimingOpt\n  if (isPerformanceSupported()) {\n    // There is an open issue to type correctly getEntriesByType\n    // github.com/microsoft/TypeScript/issues/33866\n    const n = WP.getEntriesByType(\"navigation\")[0] as any\n    if (n) {\n      const responseEnd = n.responseEnd\n      const responseStart = n.responseStart\n      const requestStart = n.requestStart\n      res = {\n        // fetchStart marks when the browser starts to fetch a resource\n        // responseEnd is when the last byte of the response arrives\n        fetchTime: responseEnd - n.fetchStart,\n        // Service worker time plus response time\n        workerTime: responseEnd - n.workerStart,\n        // Request plus response time (network only)\n        networkTime: responseEnd - requestStart,\n        // Response time only (download)\n        downloadTime: responseEnd - responseStart,\n        // Time to First Byte (TTFB)\n        timeToFirstByte: responseStart - requestStart,\n        // HTTP header size\n        headerSize: n.decodedBodySize - n.transferSize || 0,\n        // DNS Lookup Time\n        dnsLookupTime: n.domainLookupStart - n.domainLookupEnd,\n        // TCP time\n        tcpTime: n.connectStart - n.connectEnd || 0,\n        // First paint\n        firstPaintTime: responseEnd - responseStart || 0,\n        // Dom Parse Time\n        domParseTime: n.domComplete - n.domInteractive,\n        // Dom Render Time\n        domRenderTime: n.domContentLoadedEventEnd - n.domContentLoadedEventStart || 0,\n        // onload time\n        onloadTime: n.loadEventEnd - n.loadEventStart\n      }\n    }\n  }\n\n  return res\n}","import { WN } from \"../constants\"\nimport { effectiveType, saveData } from \"../performance/record-client-navigator\"\nimport { EffectiveType, NavigatorInformation } from \"../types/types\"\n\nexport const isLowEndDevice = (): boolean => {\n  return WN.deviceMemory <= 4 || WN.hardwareConcurrency <= 4\n}\n\nexport const isLowEndExperience = (\n  effectiveType: EffectiveType,\n  saveData: boolean\n): boolean => {\n  if ([\"slow-2g\", \"2g\", \"3g\"].includes(effectiveType)) {\n    return true\n  }\n\n  return isLowEndDevice() || saveData\n}\n\n/**\n * 信息来源于 window.navigator:\n * 1. Device Memory 设备内存\n * 2. Hardware Concurency 并发数\n * 3. Status of the service worker:\n *     - controlled: a service worker is controlling the page\n *     - supported: the browser supports service worker\n *     - unsupported: the user's browser does not support service worker\n */\nexport const getNavigatorInformation = (): NavigatorInformation | undefined => {\n  if (WN) {\n    return {\n      deviceMemory: WN.deviceMemory || 0,\n      hardwareConcurrency: WN.hardwareConcurrency || 0,\n      serviceWorkerStatus:\n        'serviceWorker' in WN\n          ? WN.serviceWorker?.controller\n            ? \"controlled\"\n            : \"supported\"\n          : \"unsupported\",\n      isLowEndDevice: isLowEndDevice(),\n      isLowEndExperience: isLowEndExperience(effectiveType, saveData)\n    }\n  }\n}","import { NavigatorOpt, TimingOpt, VitalsScore } from \"../types/types\";\n\n/**\n * https://web.dev/vitals/\n * https://web.dev/cls/\n */\nconst fcpScore = [1000, 2500];\nconst lcpScore = [2500, 4000];\nconst fidcore = [100, 300];\nconst clsScore = [0.1, 0.25];\nconst tbtScore = [300, 600];\n\nexport const webVitalsScore: Record<string, number[]> = {\n  fp: fcpScore,\n  fcp: fcpScore,\n  lcp: lcpScore,\n  lcpFinal: lcpScore,\n  fid: fidcore,\n  fidVitals: fidcore,\n  cls: clsScore,\n  clsFinal: clsScore,\n  tbt: tbtScore,\n  tbt5S: tbtScore,\n  tbt10S: tbtScore,\n  tbtFinal: tbtScore,\n};\n\nexport const getVitalsScore = (\n  measureName: string,\n  value: number\n): VitalsScore => {\n  if (!webVitalsScore[measureName]) {\n    return null\n  }\n\n  if (value <= webVitalsScore[measureName][0]) {\n    return \"good\"\n  }\n\n  return value <= webVitalsScore[measureName][1] ? \"needsImprovement\" : \"poor\"\n}","import { config } from \"../config/config\"\nimport { D } from \"../constants\"\nimport { NavigatorOpt, TimingOpt } from \"../types/types\"\nimport { pushTask } from \"./helper\"\nimport { getNavigatorInformation } from \"./navigator-information\"\nimport { getVitalsScore } from \"./vitals-score\"\n\n/**\n * Sends the User timing measure to analyticsTracker\n * Do not report specific data when the page is hidden\n * @param {string} measureName\n * @param {number} duration\n * @param {object} eventProperties\n */\nexport const reportPerformance = (\n  data: TimingOpt | number | NavigatorOpt | any,\n  measureName: string,\n  eventProperties?: object\n): void => {\n  pushTask(() => {\n    if (D.visibilityState === \"hidden\" && !measureName.includes(\"Final\") || !config.analyticsTracker) return\n    config.analyticsTracker({\n      metricName: measureName,\n      data,\n      eventProperties,\n      navigatorInformation: getNavigatorInformation(),\n      vitalsScore: getVitalsScore(measureName, data as number)\n    })\n  })\n}","import { config } from \"../config/config\"\nimport { roundByTwo } from \"./helper\"\nimport { reportPerformance } from \"./report-performance\"\n\n/**\n * Sends the metric to an external tracking service\n * 将指标发送到外部跟踪服务\n * @param {string} measureName \n * @param {{[key: string]: any}} metric \n * @param {object} customProperties \n */\nexport const logData = (\n  measureName: string,\n  metric: { [key: string]: any },\n  customProperties?: object\n): void => {\n  Object.keys(metric).forEach((key) => {\n    if (typeof metric[key] === 'number') {\n      metric[key] = roundByTwo(metric[key]);\n    }\n  });\n  reportPerformance(metric, measureName, customProperties);\n};\n\n/**\n * Dispatches the metric duration into internal logs\n * and the external time tracking service.\n * @param {string} measureName\n * @param {number} duration\n * @param {object} customProperties\n */\nexport const logMetric = (\n  measureName: string,\n  duration: number,\n  customProperties?: object\n) => {\n  const duration2decimal = roundByTwo(duration)\n  if (duration2decimal <= (config.maxTime as number)) {\n    reportPerformance(duration, measureName, customProperties)\n  }\n}","import { ResourceTime } from \"../types/types\";\n\n// first-pait\nexport const fp = {\n  value: 0\n}\n\n// first-contentful-paint\nexport const fcp = {\n  value: 0\n}\n\n// block-time\nexport const tbt = {\n  value: 0\n}\n\n// largest-contentful-paint\nexport const lcp = {\n  value: 0\n}\n\n// resource-time\nexport const rt: { value: ResourceTime } = {\n  value: {\n    beacon: 0,\n    css: 0,\n    fetch: 0,\n    img: 0,\n    other: 0,\n    script: 0,\n    total: 0,\n    xmlhttprequest: 0,\n  },\n};\n\n// cumulative-layout-shift\nexport const cls = {\n  value: 0\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logMetric } from \"../utils/log\"\nimport { fcp, fp, lcp } from \"../utils/metrics\"\nimport { disconnectPO } from \"./performance-observer\"\n\n/**\n * FirstPaintObserverCallback\n * @returns \n */\nexport const initFirstPaint = (\n  callback: () => void\n) => (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (entry.name === \"first-paint\") {\n      fp.value = entry.startTime\n      logMetric(\"fp\", entry.startTime)\n    } else if (entry.name === \"first-contentful-paint\") {\n      fcp.value = entry.startTime\n      logMetric(\"fcp\", entry.startTime)\n      callback()\n      disconnectPO(\"paint\")\n    }\n  }\n}\n\n/**\n * LargestContentfulPaintObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries \n */\nexport const initLargestContentfulPaint = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry) {\n    lcp.value = lastEntry.renderTime || lastEntry.startTime\n  }\n}\n\n/**\n * ElementTimingObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries\n */\nexport const initElementTiming = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (entry.identifier) {\n      logMetric(entry.identifier, entry.startTime, {\n        performanceEntry: entry\n      })\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logMetric } from \"../utils/log\"\nimport { tbt, fcp } from \"../utils/metrics\"\n\n/**\n * LongtaskObserverCallback\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Long_Tasks_API\n * The definition of a long task is a task longer than 50ms\n * 长任务的定义是超过50ms的任务\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns \n */\nexport const initLongtask = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    const blockingTime = entry.startTime - 50\n    if (entry.name !== \"self\" && entry.startTime < fcp.value) return\n    if (blockingTime > 0) {\n      tbt.value += entry.startTime\n      logMetric(\"longtask\", entry.startTime)\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logData, logMetric } from \"../utils/log\"\nimport { tbt, cls, lcp, rt } from \"../utils/metrics\"\nimport { disconnectPO, performanceObserverInstance } from \"./performance-observer\"\n\n/**\n * FirstInputObserverCallback\n * Take the last entry\n * @param {Array<PerformanceEntryEncapsulation>} entries\n */\nexport const initFirstInput = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry) {\n    // Core Web Vitals FID logic\n    // Delayed operation of measurement input events\n    // 测量输入事件的延迟操作\n    logMetric(\n      \"fidVitals\",\n      lastEntry.processingStart - lastEntry.startTime,\n      {\n        performanceEntry: lastEntry\n      }\n    )\n\n    // Measure the duration of processing the first input event\n    // 测量处理第一个输入事件的持续时间\n    logMetric(\n      \"fid\",\n      lastEntry.duration,\n      {\n        performanceEntry: lastEntry\n      }\n    )\n  }\n\n  // Destroy the registered callback for FID to avoid memory leaks caused by too many observers\n  // 销毁对FID的注册回调 避免过多的观察者造成内存泄露\n  disconnectPO(\"first-input\")\n\n  // lcp log\n  logMetric(\"lcp\", lcp.value)\n\n  // Force any pending records to be dispatched\n  // 强制分派所有待处理的记录\n  if (\n    performanceObserverInstance[\"layout-shift\"] &&\n    typeof performanceObserverInstance[\"layout-shift\"].takeRecords === \"function\"\n  ) {\n    performanceObserverInstance[\"layout-shift\"].takeRecords()\n  }\n\n  // cls log\n  logMetric(\"cls\", cls.value)\n\n  // bt log\n  logMetric(\"bt\", tbt.value)\n\n  // TBT with 5 second delay after FID\n  setTimeout(() => {\n    logMetric(\"bt5S\", tbt.value)\n  }, 5000)\n\n  // TBT with 10 second delay after FID\n  // 10S overall data consumption after FID is activated\n  setTimeout(() => {\n    logMetric(\"bt10S\", tbt.value)\n    logData(\"dataConsumption\", rt.value)\n  }, 10000)\n}","import { PerformanceEntryEncapsulation } from \"../types/types\"\nimport { logData } from \"../utils/log\"\nimport { rt } from \"../utils/metrics\"\n\n/**\n * ResouceTimingObserverCallback\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns \n */\nexport const initResouceTiming = (entries: Array<PerformanceEntryEncapsulation>) => {\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n\n    logData(\"resourceTiming\", entry)\n\n    if (entry.decodedBodySize && entry.initiatorType) {\n      const bodySize = entry.decodedBodySize / 1000\n      rt.value[entry.initiatorType] += bodySize\n      rt.value.total += bodySize\n    }\n  }\n}","import { PerformanceEntryEncapsulation } from \"../types/types\";\nimport { cls } from \"../utils/metrics\";\n\n/**\n * https://web.dev/cls/\n * https://requestmetrics.com/web-performance/cumulative-layout-shift\n * \n * Cumulative Layout Shift (CLS), \n * sometimes known as jank, \n * is a measurement of how much elements move due to late-rendered content.\n * You can think of it as a measurement of layout instability. \n * It has become a common problem for many websites due to third-party scripts and tag management and its one of the new Core Web Vital metrics.\n * \n * LayoutShiftObserverCallback\n * Detects new layout shift occurrences and updates the\n * Only count layout shifts without recent user input.\n * 检测新的布局偏移情况并更新\n * 仅在没有最近用户输入的情况下计算布局转移。\n * \n * What is a good CLS score?\n * To provide a good user experience, sites should strive to have a CLS score of 0.1 or less. To ensure you're hitting this target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices.\n * 为了提供良好的用户体验，网站应努力使CLS得分不超过0.1。为确保您达到大多数用户的这一目标，衡量移动设备和台式机设备的页面加载量的第75个百分位数是一个很好的衡量标准。\n * @param {Array<PerformanceEntryEncapsulation>} entries\n * @returns\n */\nexport const initLayoutShift = (entries: Array<PerformanceEntryEncapsulation>) => {\n  const lastEntry = entries.pop()\n  if (lastEntry && !lastEntry.hadRecentInput && lastEntry.value) {\n    cls.value += lastEntry.value\n  }\n}","import { PerformanceEntryEncapsulation, PerformanceObserverEventType, PerformanceObservers } from \"../types/types\"\nimport { name } from \"../../package.json\"\nimport { C } from \"../constants\"\nimport { initElementTiming, initFirstPaint, initLargestContentfulPaint } from \"./paint\"\nimport { initLongtask } from \"./longtask\"\nimport { initFirstInput } from \"./first-input\"\nimport { config } from \"../config/config\"\nimport { initResouceTiming } from \"./resource\"\nimport { initLayoutShift } from \"./layout-shift\"\nimport { logMetric } from \"../utils/log\"\nimport { tbt, cls, lcp } from \"../utils/metrics\"\n\nexport const performanceObserverInstance: PerformanceObservers = {}\n\n/**\n * PerformanceObserver asynchronous subscription\n * PerformanceObserver异步订阅\n * @param {PerformanceObserverEventType} eventType 监听的事件类型 Types of events monitored\n * @param {(entries: Array<PerformanceEntryEncapsulation>) => void} callback 监听的回调 Listened callback\n */\nconst asyncSubscripePO = (\n  eventType: PerformanceObserverEventType,\n  callback: (entries: Array<PerformanceEntryEncapsulation>) => void\n): PerformanceObserver | null => {\n  try {\n    const Observer = new PerformanceObserver(\n      (entries) =>\n        callback(\n          entries.getEntries() as Array<PerformanceEntryEncapsulation>\n        )\n    )\n    Observer.observe({ type: eventType, buffered: true })\n    return Observer\n  } catch (error) {\n    C.warn(\"PerformanceMonitoring obsever🌲:\", `${name}: ${error}`);\n  }\n  return null\n}\n\n/**\n * Cancel the monitoring of PerformanceObserver\n * 取消PerformanceObserver的监听\n * @param {string} eventType 监听的事件类型 Types of events monitored\n */\nexport const disconnectPO = (eventType: string) => {\n  if (performanceObserverInstance[eventType]) {\n    performanceObserverInstance[eventType]?.disconnect()\n  }\n  delete performanceObserverInstance[eventType]\n}\n\n/**\n * PerformanceObserver initialization\n * PerformanceObserver初始化\n * paint: fp、fcp、largest-contentful-paint\n * longtask\n * first-input\n */\nexport const initPerformanceObserver = (): void => {\n  performanceObserverInstance[\"paint\"] = asyncSubscripePO(\n    \"paint\",\n    initFirstPaint(\n      () => performanceObserverInstance[\"longtask\"] = asyncSubscripePO(\"longtask\", initLongtask)\n    )\n  )\n\n  performanceObserverInstance[\"first-input\"] = asyncSubscripePO(\n    \"first-input\",\n    initFirstInput\n  )\n\n  performanceObserverInstance[\"largest-contentful-paint\"] = asyncSubscripePO(\n    \"largest-contentful-paint\",\n    initLargestContentfulPaint\n  )\n\n  // Collect page performance data\n  // 收集页面性能数据\n  if (config.isObserverResourceTiming) {\n    asyncSubscripePO(\"resource\", initResouceTiming)\n  }\n\n  performanceObserverInstance[\"layout-shift\"] = asyncSubscripePO(\n    \"layout-shift\",\n    initLayoutShift\n  )\n\n  if (config.isObserverElementTiming) {\n    asyncSubscripePO(\"element\", initElementTiming)\n  }\n}\n\n\nexport const disconnectPerformanceObserver = (): void => {\n  if (performanceObserverInstance[\"largest-contentful-paint\"]) {\n    logMetric(\"lcpFinal\", lcp.value)\n    disconnectPO(\"largest-contentful-paint\")\n  }\n\n  if (performanceObserverInstance[\"layout-shift\"]) {\n    // Force any pending records to be dispatched\n    // 强制分派所有待处理的记录\n    if (typeof performanceObserverInstance[\"layout-shift\"].takeRecords === \"function\") {\n      performanceObserverInstance[\"layout-shift\"].takeRecords()\n    }\n    logMetric(\"clsFinal\", cls.value)\n    disconnectPO(\"layout-shift\")\n  }\n\n  if (performanceObserverInstance[\"longtask\"]) {\n    logMetric(\"btFinal\", tbt.value)\n    disconnectPO(\"longtask\")\n  }\n}","import ErrorTrace from \"./error-trace\"\nimport ReportData from \"./utils/ReportData\"\nimport { recordingStorage } from \"./performance/record-storage\"\nimport { version } from \"../package.json\"\nimport { config } from \"./config/config\"\nimport { recordClientNavigator } from \"./performance/record-client-navigator\"\nimport { recordTiming } from \"./performance/record-timing\"\nimport { isPerformanceSupported } from \"./utils/helper\"\nimport { AskLevel, PerformanceMonitoringOptions } from \"./types/types\"\nimport { disconnectPerformanceObserver, initPerformanceObserver } from \"./performance/performance-observer\"\nimport { D } from \"./constants\"\nimport { log } from \"./utils/console\"\n\n/**\n * A performance monitoring platform SDK\n * Features include error capture, error recording, performance monitoring\n * 功能包括错误捕获、错误录制、性能监控\n * 一款性能监控平台SDK\n * @packageDocumentation\n */\nexport default class PerformanceMonitoring {\n  constructor(options: PerformanceMonitoringOptions) {\n    const {\n      isObserverElementTiming,\n      isObserverResourceTiming,\n      maxTime,\n      captureError,\n      fetchDomain,\n      errLogRoute,\n      errEventRoute,\n      logRoute,\n      analyticsTracker,\n      recordOptions,\n    } = options || {}\n\n    config.isObserverElementTiming = !!isObserverElementTiming\n    config.isObserverResourceTiming = !!isObserverResourceTiming\n    config.maxTime = maxTime || config.maxTime\n    config.captureError = captureError || config.captureError\n    config.fetchDomain = fetchDomain\n    config.errLogRoute = errLogRoute\n    config.errEventRoute = errEventRoute\n    config.logRoute = logRoute\n    config.reportData = new ReportData()\n    config.analyticsTracker = analyticsTracker || config.analyticsTracker\n    config.recordOptions = recordOptions || config.recordOptions\n\n    log(version)\n\n    if (captureError && fetchDomain) {\n      ErrorTrace.getInstance()\n    }\n\n    if (isPerformanceSupported()) {\n\n      if (D.visibilityState === \"hidden\") {\n        D.addEventListener(\n          \"visibilitychange\",\n          disconnectPerformanceObserver\n        )\n      }\n\n      if (fetchDomain && logRoute) {\n        Promise.all([\n          recordTiming(),\n          recordClientNavigator(),\n          recordingStorage()\n        ]).then(res => {\n          config.reportData?.fetch(\n            AskLevel.IDLE,\n            JSON.stringify(res),\n            logRoute\n          )\n        })\n      }\n\n      initPerformanceObserver()\n    }\n  }\n}"],"names":["AskLevel","W","window","WP","performance","WN","navigator","C","console","D","document","log","message","options","warn","config","isObserverResourceTiming","isObserverElementTiming","maxTime","captureError","reportData","undefined","analyticsTracker","recordOptions","fetchDomain","errLogRoute","errEventRoute","logRoute","NodeType","isShadowRoot","n","host","Boolean","shadowRoot","_id","tagNameRegex","RegExp","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","isCSSImportRule","styleSheet","cssText","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","filePath","maybeQuote","test","url","indexOf","split","slice","extractOrigin","stack","parts","pop","part","push","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","transformAttribute","tagName","name","value","pos","collectCharacters","regEx","chars","match","exec","substring","length","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","nodeType","ELEMENT_NODE","classList","contains","forEach","className","matches","parentNode","lowerIfExists","maybeAttr","toLowerCase","serializeNodeWithId","blockClass","blockSelector","skipChild","inlineStylesheet","maskInputOptions","maskTextFn","slimDOMOptions","recordCanvas","onSerialize","onIframeLoad","iframeLoadTimeout","preserveWhiteSpace","_serializedNode","rootId","__sn","docId","id","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","eIndex","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","textContent","repeat","checked","parentElement","selected","rr_dataURL","toDataURL","rr_mediaState","paused","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","width","height","getBoundingClientRect","class","rr_width","rr_height","src","Element","isSVG","el","SVGElement","TEXT_NODE","parentTagName","isStyle","isScript","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNode","sn","comment","script","as","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","Object","assign","recordChild","headWhitespace","bypassOptions","childN","serializedChildNode","isElement","isShadowHost","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","timer","setTimeout","addEventListener","clearTimeout","blankUrl","location","onceIframeLoaded","iframeDoc","contentDocument","serializedIframeNode","EventType","IncrementalSource","MouseInteractions","ReplayerEvents","on","fn","target","capture","passive","removeEventListener","DEPARTED_MIRROR_ACCESS_WARNING","_mirror","getId","getNode","removeNodeFromMap","has","reset","throttle","func","wait","timeout","previous","arg","now","Date","leading","remaining","context","this","args","arguments","apply","trailing","hookSetter","key","d","isRevoked","original","getOwnPropertyDescriptor","defineProperty","set","call","patch","source","replacement","wrapped","prototype","defineProperties","__rrweb_original__","enumerable","getWindowHeight","innerHeight","documentElement","clientHeight","body","getWindowWidth","innerWidth","clientWidth","isBlocked","isIgnored","isAncestorRemoved","mirror","isTouchEvent","event","changedTouches","isIframeINode","hasShadowRoot","isNodeInLinkedList","Proxy","Reflect","get","prop","receiver","DoubleLinkedList","constructor","position","Error","current","head","index","next","addNode","__ln","previousSibling","nextSibling","removeNode","moveKey","parentId","isINode","MutationBuffer","Set","mutations","processMutation","emit","frozen","locked","adds","addList","getNextId","ns","nextId","pushAdd","shadowHost","getRootNode","_n$getRootNode","notInDoc","currentN","iframeManager","addIframe","shadowDomManager","addShadowRoot","iframe","childSn","attachIframe","mapRemoves","shift","movedSet","isParentRemoved","removes","addedSet","isAncestorInSet","droppedSet","add","candidate","_node","payload","texts","text","filter","attribute","movedMap","emissionCallback","m","oldValue","getAttribute","attributeName","item","addedNodes","genAdds","removedNodes","nodeId","deepDelete","targetId","delete","init","cb","freeze","unfreeze","isFrozen","lock","unlock","addsSet","some","r","pathToSelector","outerHTML","path","localName","parent","domSiblings","children","i","sibling","stringify","obj","stringifyOptions","numOfKeysLimit","keys","JSON","thisPos","splice","Infinity","_obj","str","toString","stringLengthLimit","Event","eventResult","eventKey","eventValue","isArray","Node","HTMLElement","nodeName","StackFrame","fileName","functionName","lineNumber","columnNumber","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","ErrorStackParser","parse","stacktrace","parseOpera","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","line","sanitizedLine","tokens","locationParts","functionNameRegex","e","parseOpera9","parseOpera11","parseOpera10","lineRE","lines","result","len","parseFloat","mutationBuffers","initMutationObserver","rootEl","mutationBuffer","mutationObserverCtor","MutationObserver","__rrMutationObserver","angularZoneSymbol","_window","Zone","_window$Zone","__symbol__","observer","processMutations","bind","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","INPUT_TAGS","lastInputValueMap","WeakMap","IframeManager","mutationCb","iframes","addLoadListener","loadListener","isAttachIframe","ShadowDomManager","wrapEvent","timestamp","wrappedEmit","takeFullSnapshot","child","hasOwnProperty","record","checkoutEveryNms","checkoutEveryNth","ignoreClass","maskAllInputs","_maskInputOptions","_slimDOMOptions","maskInputFn","hooks","packFn","sampling","mousemoveWait","collectFonts","recordLog","mousemove","color","date","datetime-local","email","month","number","range","search","tel","time","week","textarea","select","defaultLogOptions","level","lengthThreshold","logger","logOptions","lastFullSnapshotEvent","NodeList","DOMTokenList","TypeError","polyfill","incrementalSnapshotCount","isCheckout","FullSnapshot","IncrementalSnapshot","data","Mutation","buf","exceedTime","wrappedMutationEmit","Meta","idNodeMap","slimDOM","password","snapshot","initialOffset","left","pageXOffset","_document2","_document2$body","_document2$body$paren","_document3","top","pageYOffset","_document5","_document5$body","_document5$body$paren","_document6","handlers","DomContentLoaded","o","mousemoveCb","mouseInteractionCb","scrollCb","viewportResizeCb","inputCb","mediaInteractionCb","styleSheetRuleCb","canvasMutationCb","fontCb","logCb","p","mutation","mouseInteraction","scroll","viewportResize","input","mediaInteaction","styleSheetRule","canvasMutation","font","mergeHooks","mutationObserver","mousemoveHandler","threshold","timeBaseline","positions","wrappedCb","totalOffset","timeOffset","mousemoveCallback","updatePosition","evt","clientX","clientY","x","y","MouseEvent","MouseMove","DragEvent","Drag","TouchMove","h","initMoveObserver","mouseInteractionHandler","disableMap","Number","isNaN","endsWith","eventName","handler","getHandler","initMouseInteractionObserver","scrollHandler","scrollEl","scrollingElement","initScrollObserver","viewportResizeHandler","lastH","lastW","initViewportResizeObserver","inputHandler","eventHandler","isChecked","cbWithDedup","querySelectorAll","v","lastInputValue","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","initInputObserver","mediaInteractionHandler","initMediaInteractionObserver","styleSheetObserver","insertRule","CSSStyleSheet","ownerNode","deleteRule","initStyleSheetObserver","canvasMutationObserver","props","getOwnPropertyNames","CanvasRenderingContext2D","restoreHandler","canvas","recordArgs","HTMLCanvasElement","hookHandler","setter","initCanvasMutationObserver","fontObserver","fontMap","originalFontFace","FontFace","family","descriptors","fontFace","buffer","fontSource","Uint8Array","fonts","FonFace","initFontObserver","logObserver","logCount","cancelHandlers","includes","originalOnError","onerror","msg","file","col","trace","stackFrame","levelType","_logger","initLogObserver","disconnect","initObservers","MouseInteraction","Scroll","ViewportResize","Input","MediaInteraction","StyleSheetRule","CanvasMutation","Font","Log","Load","addCustomEvent","tag","Custom","freezePage","pack","_e","strFromU8","zlibSync","strToU8","ErrorTrace","globalErrorTrace","networkErrorTrace","promiseErrorTrace","iframeErrorTrace","eventsMatrix","[object Object]","instance","lineno","colno","events","concat","fetch","IDLE","preventDefault","reason","frames","ReportData","uri","URGENT","method","keepalive","xhr","XMLHttpRequest","open","setRequestHeader","send","onload","sendBeacon","image","Image","isPerformanceSupported","getEntriesByType","mark","bytes2kb","bytes","Math","pow","toFixed","roundByTwo","num","pushTask","callback","requestIdleCallback","recordingStorage","async","storage","usageDetails","quota","usage","estimate","res","effectiveType","saveData","recordClientNavigator","Promise","resolve","connection","downlink","rtt","times","sizes","size","bandwidth","userAgent","recordTiming","responseEnd","responseStart","requestStart","fetchTime","fetchStart","workerTime","workerStart","networkTime","downloadTime","timeToFirstByte","headerSize","decodedBodySize","transferSize","dnsLookupTime","domainLookupStart","domainLookupEnd","tcpTime","connectStart","connectEnd","firstPaintTime","domParseTime","domComplete","domInteractive","domRenderTime","domContentLoadedEventEnd","domContentLoadedEventStart","onloadTime","loadEventEnd","loadEventStart","isLowEndDevice","deviceMemory","hardwareConcurrency","isLowEndExperience","getNavigatorInformation","serviceWorkerStatus","serviceWorker","controller","fcpScore","lcpScore","fidcore","clsScore","tbtScore","webVitalsScore","fp","fcp","lcp","lcpFinal","fid","fidVitals","cls","clsFinal","tbt","tbt5S","tbt10S","tbtFinal","getVitalsScore","measureName","reportPerformance","eventProperties","visibilityState","metricName","navigatorInformation","vitalsScore","logData","metric","customProperties","logMetric","duration","rt","beacon","css","img","other","total","xmlhttprequest","initLargestContentfulPaint","entries","lastEntry","renderTime","startTime","initElementTiming","entry","identifier","performanceEntry","initLongtask","initFirstInput","processingStart","disconnectPO","performanceObserverInstance","takeRecords","initResouceTiming","initiatorType","bodySize","initLayoutShift","hadRecentInput","asyncSubscripePO","eventType","Observer","PerformanceObserver","getEntries","buffered","disconnectPerformanceObserver","getInstance","all","then"],"mappings":"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"}